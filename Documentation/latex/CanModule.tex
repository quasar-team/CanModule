%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{2}



\title{CanModule Developer Documentation}
\date{January 14, 2021}
\release{2.0.6}
\author{Michael Ludwig}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Downloading}
\label{\detokenize{downloading:downloading}}\label{\detokenize{downloading::doc}}

\section{sources}
\label{\detokenize{downloading:sources}}
CanModule can be cloned from github, and is integrated in a cmake build chain:

git clone \sphinxurl{https://github.com/quasar-team/CanModule.git}

or a specific tag
git clone \sphinxstylestrong{\sphinxhyphen{}b v2.0} \sphinxurl{https://github.com/quasar-team/CanModule.git}
\begin{itemize}
\item {} 
check out the \sphinxhref{https://readthedocs.web.cern.ch/display/CANDev/CAN+development?src=sidebar}{readthedocs} and the generated doc from gitlab CI

\item {} 
the cross OS CI is on \sphinxhref{https://ics-fd-cpp-master.web.cern.ch/view/CAN/}{jenkins\_can} .

\end{itemize}


\section{runtime dependencies}
\label{\detokenize{downloading:runtime-dependencies}}\begin{itemize}
\item {} 
boost 1.73.0 from \sphinxhref{https://www.boost.org/}{boost}

\item {} 
libsocketcan for linux.
git clone \sphinxhref{https://gitlab.cern.ch/mludwig/CAN\_libsocketcan.git}{libsocketcan} \&\& cmake . \&\& sudo make install

\item {} 
anagate lib

\item {} 
systec driver

\item {} 
peak driver

\end{itemize}

you can also build a reduced dependency CanModule with boost and libsocketcan linked statically.


\chapter{Objective}
\label{\detokenize{objective:objective}}\label{\detokenize{objective::doc}}
\sphinxstylestrong{CanModule} is a software abstraction layer, written in C++, to simplify integration
of CAN bridges from different vendors into cmake (C++) projects needing CAN connectivity
for windows and linux. A CAN bridge is \sphinxhyphen{} usually \sphinxhyphen{} an external module which is connected
on one side to a computer or network and offers CAN ports on the other side where CAN buses
can be connected.

The original authors are the CERN Atlas\sphinxhyphen{}DCS team, support is now done by BE\sphinxhyphen{}ICS\sphinxhyphen{}FD.


\section{Supported OS}
\label{\detokenize{objective:supported-os}}
These operating systems are supported for all vendors
\begin{itemize}
\item {} 
CERN CC7

\item {} 
Windows 2016 Server and Windows 10

\end{itemize}

other OS versions might be available on special request, or easily be ported to.


\section{compatible vendors}
\label{\detokenize{objective:compatible-vendors}}
CAN bridges from vendors are compatible with CanModule and are tested
\begin{itemize}
\item {} 
\sphinxhref{http://www.anagate.de/en/products/can-ethernet-gateways.htm}{AnaGate}

\item {} 
\sphinxhref{https://www.systec-electronic.com/}{SysTec}

\item {} 
\sphinxhref{https://www.peak-system.com/}{Peak}

\end{itemize}

These vendors produce many types of CAN bridges, \sphinxstylestrong{CanModule supports presently the USB (Peak, Systec)
and ethernet (Anagate) bridges}. Flexible datarate bridges (PEAK FD) and other interface types
(PEAK .m2 or also PCI) might be added if needed.


\section{Integration into projects}
\label{\detokenize{objective:integration-into-projects}}
CanModule is distributed by source, coming with cmake toolchains for the implementations and OS:
clone from \sphinxhref{https://github.com/quasar-team/CanModule.git}{CanModuleGithub} and integrate it into a cmake build chain.

CanModule is a quasar module, but can also be used stand\sphinxhyphen{}alone.


\chapter{Standard API}
\label{\detokenize{standardApi:standard-api}}\label{\detokenize{standardApi::doc}}
The user API \sphinxstylestrong{hides all implementation/vendor specific details} across implementations (vendors X OSes).


\section{example snippet}
\label{\detokenize{standardApi:example-snippet}}
This is how to choose an implementation and open one port:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{string} \PYG{n}{implementationName} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sock}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}   \PYG{c+c1}{// here: systec or peak through socketCan, linux}
\PYG{n}{string} \PYG{n}{port} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sock:can0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}            \PYG{c+c1}{// here: CAN port 0 via socket CAN, linux}
\PYG{n}{string} \PYG{n}{parameters} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Unspecified}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}    \PYG{c+c1}{// here: use defaults. see documentation for each implementation/vendor. same as \PYGZdq{}\PYGZdq{}}
\PYG{n}{CanMessage} \PYG{n}{cm}\PYG{p}{;}
\PYG{n}{CanModule}\PYG{o}{:}\PYG{o}{:}\PYG{n}{CanLibLoader} \PYG{o}{*}\PYG{n}{libloader} \PYG{o}{=} \PYG{n}{CanModule}\PYG{o}{:}\PYG{o}{:}\PYG{n}{CanLibLoader}\PYG{o}{:}\PYG{o}{:}\PYG{n}{createInstance}\PYG{p}{(} \PYG{n}{implementationName} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{cca} \PYG{o}{=} \PYG{n}{libloader}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{openCanBus}\PYG{p}{(} \PYG{n}{port}\PYG{p}{,} \PYG{n}{parameters} \PYG{p}{)}\PYG{p}{;}

\PYG{n}{cca}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setReconnectBehavior}\PYG{p}{(} \PYG{n}{CanModule}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ReconnectAutoCondition}\PYG{o}{:}\PYG{o}{:}\PYG{n}{sendFail}\PYG{p}{,} \PYG{n}{CanModule}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ReconnectAction}\PYG{o}{:}\PYG{o}{:}\PYG{n}{singleBus} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{cca}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{canMessageCame}\PYG{p}{.}\PYG{n}{connect}\PYG{p}{(} \PYG{o}{\PYGZam{}}\PYG{n}{onMessageRcvd} \PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// connect a reception handler}
\PYG{n}{cca}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{canMessageError}\PYG{p}{.}\PYG{n}{connect}\PYG{p}{(} \PYG{o}{\PYGZam{}}\PYG{n}{errorHandler} \PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// connect an error handler}


\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{br} \PYG{o}{=} \PYG{n}{cca}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getPortBitrate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}       \PYG{c+c1}{// make sure we know the bitrate as it was set}

\PYG{n}{cca}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{sendMessage}\PYG{p}{(} \PYG{o}{\PYGZam{}}\PYG{n}{cm} \PYG{p}{)}\PYG{p}{;}

\PYG{n}{CanStatistics} \PYG{n}{stats}\PYG{p}{;}
\PYG{n}{cca}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getStatistics}\PYG{p}{(} \PYG{n}{stats} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}
      \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ timeSinceOpened= }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{stats}\PYG{p}{.}\PYG{n}{timeSinceOpened}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ ms}\PYG{l+s}{\PYGZdq{}}
      \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ timeSinceReceived= }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{stats}\PYG{p}{.}\PYG{n}{timeSinceReceived}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ ms}\PYG{l+s}{\PYGZdq{}}
      \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ timeSinceTransmitted= }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{stats}\PYG{p}{.}\PYG{n}{timeSinceTransmitted}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ ms}\PYG{l+s}{\PYGZdq{}}
      \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ stats portStatus= 0x}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{hex} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{stats}\PYG{p}{.}\PYG{n}{portStatus}\PYG{p}{(}\PYG{p}{)}
      \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ unified port status= 0x}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{hex} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{cca}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getPortStatus}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{dec} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}

\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n}{communicate}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}

\PYG{n}{libLoader}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{closeCanBus}\PYG{p}{(} \PYG{n}{cca} \PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Only two strings, “port” and “parameters”, have to defined to communicate with a CAN port for a module from a vendor.

\item {} 
a connection handler method must be registered to treat received messages (boost slot connected to boost signal)

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// connection.h}
\PYG{k}{class} \PYG{n+nc}{MYCLASS} \PYG{p}{\PYGZob{}}
   \PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}
   \PYG{k}{public}\PYG{o}{:}
      \PYG{k}{static} \PYG{k+kt}{void} \PYG{n}{onMessageRcvd}\PYG{p}{(}\PYG{k}{const} \PYG{n}{CanMsgStruct}\PYG{c+cm}{/*\PYGZam{}*/} \PYG{n}{message}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// connection.cpp}
\PYG{c+cm}{/* static */} \PYG{k+kt}{void} \PYG{n}{MYCLASS}\PYG{o}{:}\PYG{o}{:}\PYG{n}{onMessageRcvd}\PYG{p}{(}\PYG{k}{const} \PYG{n}{CanMsgStruct}\PYG{c+cm}{/*\PYGZam{}*/} \PYG{n}{message}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{MYCLASS} \PYG{o}{*}\PYG{n}{myObject} \PYG{o}{=} \PYG{n}{MYCLASS}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getMyObject}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}\PYG{p}{;}
   \PYG{n}{myObject}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{processReceivedMessage}\PYG{p}{(} \PYG{n}{message} \PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// errorHandler.cpp}
\PYG{c+cm}{/* static */} \PYG{k+kt}{void} \PYG{n}{MYCLASS}\PYG{o}{:}\PYG{o}{:}\PYG{n}{errorHandler}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{msg}\PYG{p}{,} \PYG{n}{timeval}\PYG{c+cm}{/*\PYGZam{}*/}\PYG{p}{)}\PYG{p}{\PYGZob{}}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{\PYGZus{}\PYGZus{}FILE\PYGZus{}\PYGZus{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{\PYGZus{}\PYGZus{}LINE\PYGZus{}\PYGZus{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{\PYGZus{}\PYGZus{}FUNCTION\PYGZus{}\PYGZus{}}
      \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{msg} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
both the library object \sphinxstylestrong{libloader} and the port objet(s) \sphinxstylestrong{cca} must exist during runtime, since the \sphinxstylestrong{libloader}
is needed at the end to close the \sphinxstylestrong{cca} .

\item {} 
you can take a look at {\color{red}\bfseries{}\textasciigrave{}CANX\textasciigrave{}\_} for a full multithreaded example using CanModule (CERN, gitlab).

\end{itemize}


\chapter{CAN ports}
\label{\detokenize{canports:can-ports}}\label{\detokenize{canports::doc}}

\section{port bit rate and statistics}
\label{\detokenize{canports:port-bit-rate-and-statistics}}\index{CanModule::CCanAccess (C++ class)@\spxentry{CanModule::CCanAccess}\spxextra{C++ class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{canports:_CPPv4N9CanModule10CCanAccessE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{canports:classCanModule_1_1CCanAccess}}\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{CanModule\sphinxcode{\sphinxupquote{::}}}}\sphinxbfcode{\sphinxupquote{CCanAccess}}}%
\pysigstopmultiline
Subclassed by {\hyperref[\detokenize{classestracing:classAnaCanScan}]{\sphinxcrossref{\DUrole{std,std-ref}{AnaCanScan}}}}, {\hyperref[\detokenize{classestracing:classCSockCanScan}]{\sphinxcrossref{\DUrole{std,std-ref}{CSockCanScan}}}}, MockCanAccess, {\hyperref[\detokenize{vendors/peak:classPKCanScan}]{\sphinxcrossref{\DUrole{std,std-ref}{PKCanScan}}}}, {\hyperref[\detokenize{classestracing:classSTCanScan}]{\sphinxcrossref{\DUrole{std,std-ref}{STCanScan}}}}
\subsubsection*{Public Functions}
\index{CanModule::CCanAccess::getPortBitrate (C++ function)@\spxentry{CanModule::CCanAccess::getPortBitrate}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{canports:_CPPv4N9CanModule10CCanAccess14getPortBitrateEv}}%
\pysigstartmultiline
\pysiglinewithargsret{\phantomsection\label{\detokenize{canports:classCanModule_1_1CCanAccess_1aa8cb67096349fefc6e03aeb33e45ef81}}uint32\_t \sphinxbfcode{\sphinxupquote{getPortBitrate}}}{}{ = 0}%
\pysigstopmultiline
returns the bitrate of that port {[}bits/sec{]} according to what CanModule buffers say. This is the setting used for setting up the hardware, after any default rules have been applied, but BEFORE any vendor specific encoding into obscure bitpatterns occurs. This happens at port opening and the bitrate can only be changed at that moment. So please call this method just after you have opened the port. But also since there is no hw interaction and it just returns a buffer, you may call it as often as you like. Default bitrate is always 125000bits/s if “Unspecified” 

\end{fulllineitems}


\end{fulllineitems}



\section{port unified status}
\label{\detokenize{canports:port-unified-status}}\begin{quote}

a 32\sphinxhyphen{}bit pattern, with
\begin{itemize}
\item {} 
0xF0.00.00.00 = code for implementation

\item {} 
0x0F.FF.FF.FF = native status from the vendor API (not all bits used)

\end{itemize}
\end{quote}
\index{CanModule::CCanAccess (C++ class)@\spxentry{CanModule::CCanAccess}\spxextra{C++ class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{canports:_CPPv4N9CanModule10CCanAccessE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{canports:classCanModule_1_1CCanAccess}}\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{CanModule\sphinxcode{\sphinxupquote{::}}}}\sphinxbfcode{\sphinxupquote{CCanAccess}}}%
\pysigstopmultiline
Subclassed by {\hyperref[\detokenize{classestracing:classAnaCanScan}]{\sphinxcrossref{\DUrole{std,std-ref}{AnaCanScan}}}}, {\hyperref[\detokenize{classestracing:classCSockCanScan}]{\sphinxcrossref{\DUrole{std,std-ref}{CSockCanScan}}}}, MockCanAccess, {\hyperref[\detokenize{vendors/peak:classPKCanScan}]{\sphinxcrossref{\DUrole{std,std-ref}{PKCanScan}}}}, {\hyperref[\detokenize{classestracing:classSTCanScan}]{\sphinxcrossref{\DUrole{std,std-ref}{STCanScan}}}}
\subsubsection*{Public Functions}
\index{CanModule::CCanAccess::getPortStatus (C++ function)@\spxentry{CanModule::CCanAccess::getPortStatus}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{canports:_CPPv4N9CanModule10CCanAccess13getPortStatusEv}}%
\pysigstartmultiline
\pysiglinewithargsret{\phantomsection\label{\detokenize{canports:classCanModule_1_1CCanAccess_1a33fe530d070cf35d096e967d543186a4}}uint32\_t \sphinxbfcode{\sphinxupquote{getPortStatus}}}{}{ = 0}%
\pysigstopmultiline
according to vendor and OS, acquire bus status, and return one uint32\_t bitpattern which has the same rules for all vendors. In fact the status for vendors is too different to be abstracted into a common bitpattern.

the \sphinxstylestrong{implementation} occupies the highest nibble, and it is a counter (see CANMODULE\_STATUS\_BP\_SOCK etc)\begin{itemize}
\item {} 
0x1\textless{}\textless{}28 = sock (linux)

\item {} 
0x2\textless{}\textless{}28 = anagate (linux, windows)

\item {} 
0x3\textless{}\textless{}28 = peak (windows)

\item {} 
0x4\textless{}\textless{}28 = systec (windows)

\item {} 
0x5\textless{}\textless{}28….0xf\textless{}\textless{}28 = unused, for future use

\end{itemize}


the **specific status** occupies bits b0..b27, and it is a (composed) implementation specific bitpattern

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{sock}}: (linux): {[} see can\_netlink.h enum can\_state {]}\begin{itemize}
\item {} 
b0: 0x1 = CAN\_STATE\_ERROR\_ACTIVE : RX/TX error count \textless{} 96

\item {} 
b1: 0x2 = CAN\_STATE\_ERROR\_WARNING : RX/TX error count \textless{} 128

\item {} 
b2: 0x4 = CAN\_STATE\_ERROR\_PASSIVE : RX/TX error count \textless{} 256

\item {} 
b3: 0x8 = CAN\_STATE\_BUS\_OFF : RX/TX error count \textgreater{}= 256

\item {} 
b4: 0x10 = CAN\_STATE\_STOPPED : Device is stopped

\item {} 
b5: 0x20 = CAN\_STATE\_SLEEPING : Device is sleeping

\item {} 
b6…b27 unused

\end{itemize}


\item {} 
\sphinxcode{\sphinxupquote{anagate}}: (linux, windows): {[} see CANDeviceConnectState {]} CANCanDeviceConnectState , translate from counter (0 does not exists, thank you anagate)\begin{itemize}
\item {} 
1 = DISCONNECTED :

\item {} 
2 = CONNECTING :

\item {} 
3 = CONNECTED

\item {} 
4 = DISCONNECTING

\item {} 
5 = NOT\_INITIALIZED

\item {} 
b3…b27: unused

\item {} 
I translate this into a simple bitpattern which is a counter : 000(does not occur), 001, 010, 011, 100, 101. Actually 011 means OK therefore. great.

\end{itemize}


\item {} 
\sphinxcode{\sphinxupquote{peak}}: (windows): see PCANBasic.h:113\begin{itemize}
\item {} 
\#define PCAN\_ERROR\_OK 0x00000U // No error

\item {} 
\#define PCAN\_ERROR\_XMTFULL 0x00001U // Transmit buffer in CAN controller is full

\item {} 
\#define PCAN\_ERROR\_OVERRUN 0x00002U // CAN controller was read too late

\item {} 
\#define PCAN\_ERROR\_BUSLIGHT 0x00004U // Bus error: an error counter reached the ‘light’ limit

\item {} 
\#define PCAN\_ERROR\_BUSHEAVY 0x00008U // Bus error: an error counter reached the ‘heavy’ limit

\item {} 
\#define PCAN\_ERROR\_BUSWARNING PCAN\_ERROR\_BUSHEAVY // Bus error: an error counter reached the ‘warning’ limit

\item {} 
\#define PCAN\_ERROR\_BUSPASSIVE 0x40000U // Bus error: the CAN controller is error passive

\item {} 
\#define PCAN\_ERROR\_BUSOFF 0x00010U // Bus error: the CAN controller is in bus\sphinxhyphen{}off state

\item {} 
\#define PCAN\_ERROR\_ANYBUSERR (PCAN\_ERROR\_BUSWARNING | PCAN\_ERROR\_BUSLIGHT | PCAN\_ERROR\_BUSHEAVY | PCAN\_ERROR\_BUSOFF | PCAN\_ERROR\_BUSPASSIVE) // Mask for all bus errors

\item {} 
\#define PCAN\_ERROR\_QRCVEMPTY 0x00020U // Receive queue is empty

\item {} 
\#define PCAN\_ERROR\_QOVERRUN 0x00040U // Receive queue was read too late

\item {} 
\#define PCAN\_ERROR\_QXMTFULL 0x00080U // Transmit queue is full

\item {} 
\#define PCAN\_ERROR\_REGTEST 0x00100U // Test of the CAN controller hardware registers failed (no hardware found)

\item {} 
\#define PCAN\_ERROR\_NODRIVER 0x00200U // Driver not loaded

\item {} 
\#define PCAN\_ERROR\_HWINUSE 0x00400U // Hardware already in use by a Net

\item {} 
\#define PCAN\_ERROR\_NETINUSE 0x00800U // A Client is already connected to the Net

\item {} 
\#define PCAN\_ERROR\_ILLHW 0x01400U // Hardware handle is invalid

\item {} 
\#define PCAN\_ERROR\_ILLNET 0x01800U // Net handle is invalid

\item {} 
\#define PCAN\_ERROR\_ILLCLIENT 0x01C00U // Client handle is invalid

\item {} 
\#define PCAN\_ERROR\_ILLHANDLE (PCAN\_ERROR\_ILLHW | PCAN\_ERROR\_ILLNET | PCAN\_ERROR\_ILLCLIENT) // Mask for all handle errors

\item {} 
\#define PCAN\_ERROR\_RESOURCE 0x02000U // Resource (FIFO, Client, timeout) cannot be created

\item {} 
\#define PCAN\_ERROR\_ILLPARAMTYPE 0x04000U // Invalid parameter

\item {} 
\#define PCAN\_ERROR\_ILLPARAMVAL 0x08000U // Invalid parameter value

\item {} 
\#define PCAN\_ERROR\_UNKNOWN 0x10000U // Unknown error

\item {} 
\#define PCAN\_ERROR\_ILLDATA 0x20000U // Invalid data, function, or action

\item {} 
\#define PCAN\_ERROR\_CAUTION 0x2000000U // An operation was successfully carried out, however, irregularities were registered

\item {} 
\#define PCAN\_ERROR\_INITIALIZE 0x4000000U // Channel is not initialized {[}Value was changed from 0x40000 to 0x4000000{]}

\item {} 
\#define PCAN\_ERROR\_ILLOPERATION 0x8000000U // Invalid operation {[}Value was changed from 0x80000 to 0x8000000{]}

\end{itemize}


\item {} 
\sphinxcode{\sphinxupquote{systec}}: (windows): {[} see UcanGetStatus table19 (for CAN) and table20 (for USB) {]}. This is a combination of socketcan bits and usb bits\begin{itemize}
\item {} 
b0: 0x1: tx overrun

\item {} 
b1: 0x2: rx overrun

\item {} 
b2: 0x4: error limit1 exceeded: warning limit

\item {} 
b3: 0x8: error limit2 exceeded: error passive

\item {} 
b4: 0x10: can controller is off

\item {} 
b5: unused

\item {} 
b6: 0x40: rx buffer overrun

\item {} 
b7: 0x80: tx buffer overrun

\item {} 
b8..b9: unused

\item {} 
b10: 0x400: transmit timeout, message dropped

\item {} 
b12..b11: unused

\item {} 
b13: 0x2000: module/usb got reset because of polling failure per second

\item {} 
b14: 0x4000: module/usb got reset because watchdog was not triggered

\item {} 
b15…b27: unused 

\end{itemize}


\end{itemize}

\end{description}


\end{fulllineitems}


\end{fulllineitems}



\section{syntax for port names}
\label{\detokenize{canports:syntax-for-port-names}}
CAN ports are specified by the user with an integer number 0..N.
Vendors and implementations tend to handle that differently, but CanModule tries to provide a
standard API across all vendors. The following strings, specified for CAN ports, will connect
to can port P:
\begin{itemize}
\item {} 
“P”

\item {} 
“canP”

\item {} 
“moduleP”

\item {} 
“whateverP”

\end{itemize}

but specifying
\begin{itemize}
\item {} 
“vcanP”

\item {} 
“vcanmoduleP”

\end{itemize}

will use vcan (virtual can) instead under linux for USB/socketcan bridges. P has to be an integer.
See vendor specific sections for the parameters and port identification as well, there are differences between
the implementations.
\begin{itemize}
\item {} 
The \sphinxstylestrong{access to a CAN port} is through:

\end{itemize}
\index{CanModule::CCanAccess (C++ class)@\spxentry{CanModule::CCanAccess}\spxextra{C++ class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{canports:_CPPv4N9CanModule10CCanAccessE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{canports:classCanModule_1_1CCanAccess}}\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{CCanAccess}}}%
\pysigstopmultiline
Subclassed by {\hyperref[\detokenize{classestracing:classAnaCanScan}]{\sphinxcrossref{\DUrole{std,std-ref}{AnaCanScan}}}}, {\hyperref[\detokenize{classestracing:classCSockCanScan}]{\sphinxcrossref{\DUrole{std,std-ref}{CSockCanScan}}}}, MockCanAccess, {\hyperref[\detokenize{vendors/peak:classPKCanScan}]{\sphinxcrossref{\DUrole{std,std-ref}{PKCanScan}}}}, {\hyperref[\detokenize{classestracing:classSTCanScan}]{\sphinxcrossref{\DUrole{std,std-ref}{STCanScan}}}}

\end{fulllineitems}



\chapter{Details on classes}
\label{\detokenize{classestracing:details-on-classes}}\label{\detokenize{classestracing::doc}}\begin{itemize}
\item {} 
An \sphinxstylestrong{implementation is chosen} and specific details are then taken care of by loading any further dependencies:

\end{itemize}
\index{CanModule::CanLibLoader (C++ class)@\spxentry{CanModule::CanLibLoader}\spxextra{C++ class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{classestracing:_CPPv4N9CanModule12CanLibLoaderE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{classestracing:classCanModule_1_1CanLibLoader}}\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{CanLibLoader}}}%
\pysigstopmultiline
Subclassed by {\hyperref[\detokenize{classestracing:classCanModule_1_1CanLibLoaderLin}]{\sphinxcrossref{\DUrole{std,std-ref}{CanModule::CanLibLoaderLin}}}}, {\hyperref[\detokenize{classestracing:classCanModule_1_1CanLibLoaderWin}]{\sphinxcrossref{\DUrole{std,std-ref}{CanModule::CanLibLoaderWin}}}}

\end{fulllineitems}

\index{CanModule::CanLibLoaderLin (C++ class)@\spxentry{CanModule::CanLibLoaderLin}\spxextra{C++ class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{classestracing:_CPPv4N9CanModule15CanLibLoaderLinE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{classestracing:classCanModule_1_1CanLibLoaderLin}}\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{CanLibLoaderLin}} : \sphinxbfcode{\sphinxupquote{public}} CanModule::{\hyperref[\detokenize{classestracing:_CPPv4N9CanModule12CanLibLoaderE}]{\sphinxcrossref{CanLibLoader}}}}%
\pysigstopmultiline
\end{fulllineitems}

\index{CanModule::CanLibLoaderWin (C++ class)@\spxentry{CanModule::CanLibLoaderWin}\spxextra{C++ class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{classestracing:_CPPv4N9CanModule15CanLibLoaderWinE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{classestracing:classCanModule_1_1CanLibLoaderWin}}\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{CanLibLoaderWin}} : \sphinxbfcode{\sphinxupquote{public}} CanModule::{\hyperref[\detokenize{classestracing:_CPPv4N9CanModule12CanLibLoaderE}]{\sphinxcrossref{CanLibLoader}}}}%
\pysigstopmultiline
\end{fulllineitems}

\begin{itemize}
\item {} 
Connection/access details to the \sphinxstylestrong{different implementations/vendors} are managed by sub\sphinxhyphen{}classing:

\end{itemize}
\index{CanModule::CCanAccess (C++ class)@\spxentry{CanModule::CCanAccess}\spxextra{C++ class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{classestracing:_CPPv4N9CanModule10CCanAccessE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{classestracing:classCanModule_1_1CCanAccess}}\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{CCanAccess}}}%
\pysigstopmultiline
Subclassed by {\hyperref[\detokenize{classestracing:classAnaCanScan}]{\sphinxcrossref{\DUrole{std,std-ref}{AnaCanScan}}}}, {\hyperref[\detokenize{classestracing:classCSockCanScan}]{\sphinxcrossref{\DUrole{std,std-ref}{CSockCanScan}}}}, MockCanAccess, {\hyperref[\detokenize{vendors/peak:classPKCanScan}]{\sphinxcrossref{\DUrole{std,std-ref}{PKCanScan}}}}, {\hyperref[\detokenize{classestracing:classSTCanScan}]{\sphinxcrossref{\DUrole{std,std-ref}{STCanScan}}}}

\end{fulllineitems}

\index{AnaCanScan (C++ class)@\spxentry{AnaCanScan}\spxextra{C++ class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{classestracing:_CPPv410AnaCanScan}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{classestracing:classAnaCanScan}}\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{AnaCanScan}} : \sphinxbfcode{\sphinxupquote{public}} CanModule::{\hyperref[\detokenize{canports:_CPPv4N9CanModule10CCanAccessE}]{\sphinxcrossref{CCanAccess}}}}%
\pysigstopmultiline~\subsubsection*{Public Functions}
\index{AnaCanScan::sendMessage (C++ function)@\spxentry{AnaCanScan::sendMessage}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{classestracing:_CPPv4N10AnaCanScan11sendMessageEshPhb}}%
\pysigstartmultiline
\pysiglinewithargsret{\phantomsection\label{\detokenize{classestracing:classAnaCanScan_1ad45666454318c891d7acd9fe16ae4c49}}bool \sphinxbfcode{\sphinxupquote{sendMessage}}}{short \sphinxstyleemphasis{cobID}, unsigned char \sphinxstyleemphasis{len}, unsigned char *\sphinxstyleemphasis{message}, bool \sphinxstyleemphasis{rtr} = false}{}%
\pysigstopmultiline
send a CAN message frame (8 byte) for anagate Method that sends a message through the can bus channel. If the method createBus was not called before this, sendMessage will fail, as there is no can bus channel to send a message trough. \begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
Was the sending process successful? 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{cobID}}: Identifier that will be used for the message. 

\item {} 
\sphinxcode{\sphinxupquote{len}}: Length of the message. If the message is bigger than 8 characters, it will be split into separate 8 characters messages. 

\item {} 
\sphinxcode{\sphinxupquote{message}}: Message to be sent trough the can bus. 

\item {} 
\sphinxcode{\sphinxupquote{rtr}}: is the message a remote transmission request? 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{AnaCanScan::getPortStatus (C++ function)@\spxentry{AnaCanScan::getPortStatus}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{classestracing:_CPPv4N10AnaCanScan13getPortStatusEv}}%
\pysigstartmultiline
\pysiglinewithargsret{\phantomsection\label{\detokenize{classestracing:classAnaCanScan_1a4c115df4a8755c0fd70030ae457af24c}}uint32\_t \sphinxbfcode{\sphinxupquote{getPortStatus}}}{}{}%
\pysigstopmultiline
CANCanDeviceConnectState , translate from counter 1 = DISCONNECTED : 2 = CONNECTING : 3 = CONNECTED 4 = DISCONNECTING 5 = NOT\_INITIALIZED b3…b27: unused

into simple bitpattern (counter) 0, 10, 11, 100, 101 

\end{fulllineitems}


\end{fulllineitems}

\index{CSockCanScan (C++ class)@\spxentry{CSockCanScan}\spxextra{C++ class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{classestracing:_CPPv412CSockCanScan}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{classestracing:classCSockCanScan}}\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{CSockCanScan}} : \sphinxbfcode{\sphinxupquote{public}} CanModule::{\hyperref[\detokenize{canports:_CPPv4N9CanModule10CCanAccessE}]{\sphinxcrossref{CCanAccess}}}}%
\pysigstopmultiline~\subsubsection*{Public Functions}
\index{CSockCanScan::sendMessage (C++ function)@\spxentry{CSockCanScan::sendMessage}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{classestracing:_CPPv4N12CSockCanScan11sendMessageEshPhb}}%
\pysigstartmultiline
\pysiglinewithargsret{\phantomsection\label{\detokenize{classestracing:classCSockCanScan_1a485ec8621a98cdacad8e27433e09d919}}bool \sphinxbfcode{\sphinxupquote{sendMessage}}}{short \sphinxstyleemphasis{cobID}, unsigned char \sphinxstyleemphasis{len}, unsigned char *\sphinxstyleemphasis{message}, bool \sphinxstyleemphasis{rtr} = false}{}%
\pysigstopmultiline
Method that sends a message trough the can bus channel. If the method createBUS was not called before this, sendMessage will fail, as there is no can bus channel to send a message through.

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
Was the initialisation process successful? 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{cobID}}: Identifier that will be used for the message. 

\item {} 
\sphinxcode{\sphinxupquote{len}}: Length of the message. If the message is bigger than 8 characters, it will be split into separate 8 characters messages. 

\item {} 
\sphinxcode{\sphinxupquote{message}}: Message to be sent trough the can bus. 

\item {} 
\sphinxcode{\sphinxupquote{rtr}}: is the message a remote transmission request? 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{CSockCanScan::getPortStatus (C++ function)@\spxentry{CSockCanScan::getPortStatus}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{classestracing:_CPPv4N12CSockCanScan13getPortStatusEv}}%
\pysigstartmultiline
\pysiglinewithargsret{\phantomsection\label{\detokenize{classestracing:classCSockCanScan_1ad1caa327a98bc30012d2c5010a98cb05}}uint32\_t \sphinxbfcode{\sphinxupquote{getPortStatus}}}{}{}%
\pysigstopmultiline
return socketcan port status as\sphinxhyphen{}is, from can\_netlink.h enum can\_state \{ CAN\_STATE\_ERROR\_ACTIVE = 0, RX/TX error count \textless{} 96 CAN\_STATE\_ERROR\_WARNING, RX/TX error count \textless{} 128 CAN\_STATE\_ERROR\_PASSIVE, RX/TX error count \textless{} 256 CAN\_STATE\_BUS\_OFF, RX/TX error count \textgreater{}= 256 CAN\_STATE\_STOPPED, Device is stopped CAN\_STATE\_SLEEPING, Device is sleeping CAN\_STATE\_MAX \}; 

\end{fulllineitems}


\end{fulllineitems}

\index{PKCanScan (C++ class)@\spxentry{PKCanScan}\spxextra{C++ class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{classestracing:_CPPv49PKCanScan}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{classestracing:classPKCanScan}}\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{PKCanScan}} : \sphinxbfcode{\sphinxupquote{public}} CanModule::{\hyperref[\detokenize{canports:_CPPv4N9CanModule10CCanAccessE}]{\sphinxcrossref{CCanAccess}}}}%
\pysigstopmultiline~\subsubsection*{Public Functions}
\index{PKCanScan::sendMessage (C++ function)@\spxentry{PKCanScan::sendMessage}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{classestracing:_CPPv4N9PKCanScan11sendMessageEshPhb}}%
\pysigstartmultiline
\pysiglinewithargsret{\phantomsection\label{\detokenize{classestracing:classPKCanScan_1a48a2e9ba00dae1b1fe01f7b095430503}}bool \sphinxbfcode{\sphinxupquote{sendMessage}}}{short \sphinxstyleemphasis{cobID}, unsigned char \sphinxstyleemphasis{len}, unsigned char *\sphinxstyleemphasis{message}, bool \sphinxstyleemphasis{rtr} = false}{}%
\pysigstopmultiline
method to send a CAN message to the peak module. we use the standard API “PCAN\sphinxhyphen{}Basic” for this for windows and we talk only over USB to fixed bitrate modules. The flexible bitrate (FD) modules can be implemented later as well: for this we need more parameters to pass and a switch between CAN\_Write and CAN\_WriteFD. 

\end{fulllineitems}

\index{PKCanScan::getPortStatus (C++ function)@\spxentry{PKCanScan::getPortStatus}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{classestracing:_CPPv4N9PKCanScan13getPortStatusEv}}%
\pysigstartmultiline
\pysiglinewithargsret{\phantomsection\label{\detokenize{classestracing:classPKCanScan_1aae31de6a82fcacc8ef3f581aff5305fc}}uint32\_t \sphinxbfcode{\sphinxupquote{getPortStatus}}}{}{}%
\pysigstopmultiline
PCANBasic.h:113 

\end{fulllineitems}


\end{fulllineitems}

\index{STCanScan (C++ class)@\spxentry{STCanScan}\spxextra{C++ class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{classestracing:_CPPv49STCanScan}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{classestracing:classSTCanScan}}\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{STCanScan}} : \sphinxbfcode{\sphinxupquote{public}} CanModule::{\hyperref[\detokenize{canports:_CPPv4N9CanModule10CCanAccessE}]{\sphinxcrossref{CCanAccess}}}}%
\pysigstopmultiline~\subsubsection*{Public Functions}
\index{STCanScan::sendMessage (C++ function)@\spxentry{STCanScan::sendMessage}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{classestracing:_CPPv4N9STCanScan11sendMessageEshPhb}}%
\pysigstartmultiline
\pysiglinewithargsret{\phantomsection\label{\detokenize{classestracing:classSTCanScan_1a45f0ec011022bf58a23e8370bac7f829}}bool \sphinxbfcode{\sphinxupquote{sendMessage}}}{short \sphinxstyleemphasis{cobID}, unsigned char \sphinxstyleemphasis{len}, unsigned char *\sphinxstyleemphasis{message}, bool \sphinxstyleemphasis{rtr} = false}{}%
\pysigstopmultiline
Method that sends a message trough the can bus channel. If the method createBUS was not called before this, sendMessage will fail, as there is no can bus channel to send a message through.

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
Was the sending process successful? 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{cobID}}: Identifier that will be used for the message. 

\item {} 
\sphinxcode{\sphinxupquote{len}}: Length of the message. If the message is bigger than 8 characters, it will be split into separate 8 characters messages. 

\item {} 
\sphinxcode{\sphinxupquote{message}}: Message to be sent trough the can bus. 

\item {} 
\sphinxcode{\sphinxupquote{rtr}}: is the message a remote transmission request? 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{STCanScan::getPortStatus (C++ function)@\spxentry{STCanScan::getPortStatus}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{classestracing:_CPPv4N9STCanScan13getPortStatusEv}}%
\pysigstartmultiline
\pysiglinewithargsret{\phantomsection\label{\detokenize{classestracing:classSTCanScan_1a27eabd471d3bb8154dfadb677c66e1d5}}uint32\_t \sphinxbfcode{\sphinxupquote{getPortStatus}}}{}{}%
\pysigstopmultiline
get CAN port and USB status, code it into an int \textgreater{} 200 (for windows@systec). use the API directly table19 says for CAN status: 0x0: no error 0x1: tx overrun 0x2: rx overrun 0x4: error limit1 exceeded: warning limit 0x8: error limit2 exceeded: error passive 0x10: can controller is off 0x40: rx buffer overrun 0x80: tx buffer overrun 0x400: transmit timeout, message dropped

table20 says for USB status: 0x2000: module/usb got reset because of polling failure per second 0x4000: module/usb got reset because watchdog was not triggered 

\end{fulllineitems}


\end{fulllineitems}



\section{tracing connections}
\label{\detokenize{classestracing:tracing-connections}}\begin{itemize}
\item {} 
keep trace of all connections to buses using a static API class without instances:

\end{itemize}
\index{CanModule::Diag (C++ class)@\spxentry{CanModule::Diag}\spxextra{C++ class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{classestracing:_CPPv4N9CanModule4DiagE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{classestracing:classCanModule_1_1Diag}}\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{CanModule\sphinxcode{\sphinxupquote{::}}}}\sphinxbfcode{\sphinxupquote{Diag}}}%
\pysigstopmultiline
diagnostic class to monitor what is going on inside CanModule, used as static api only\begin{itemize}
\item {} 
keeps track of library instances and pointers

\item {} 
tracks opened can buses for each lib instance 

\end{itemize}

\subsubsection*{Public Static Functions}
\index{CanModule::Diag::get\_connections (C++ function)@\spxentry{CanModule::Diag::get\_connections}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{classestracing:_CPPv4N9CanModule4Diag15get_connectionsEv}}%
\pysigstartmultiline
\pysiglinewithargsret{\phantomsection\label{\detokenize{classestracing:classCanModule_1_1Diag_1afcea76f7b51b8fa0996b7574abc03c46}}vector\textless{}{\hyperref[\detokenize{classestracing:_CPPv4N9CanModule4DiagE}]{\sphinxcrossref{Diag}}}::CONNECTION\_DIAG\_t\textgreater{} \sphinxbfcode{\sphinxupquote{get\_connections}}}{}{}%
\pysigstopmultiline
gives back a vector filled with connection details, mostly timestamp related the maps are only used as rvalues in a reentrant method: fine without mutex 

\end{fulllineitems}


\end{fulllineitems}



\chapter{SysTec}
\label{\detokenize{vendors/systec:systec}}\label{\detokenize{vendors/systec::doc}}
All modules from vendor {\hyperref[\detokenize{vendors/systec:systec}]{\sphinxcrossref{SysTec}}} are handled by class STCanScan (windows) or CSockCanScan (linux) which
manage the modules through their underlying vendor specific API and provide the standard generic CanModule API.
Here the underlying vendor specific classes and the specific parameters are documented.

SysTec modules USB\sphinxhyphen{}CAN bridges are supported: sysWORXX 1,2,8,16


\section{status}
\label{\detokenize{vendors/systec:status}}
status information is propagated through the unified status.
For windows:
\index{STCanScan (C++ class)@\spxentry{STCanScan}\spxextra{C++ class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vendors/systec:_CPPv49STCanScan}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{vendors/systec:classSTCanScan}}\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{STCanScan}} : \sphinxbfcode{\sphinxupquote{public}} CanModule::{\hyperref[\detokenize{canports:_CPPv4N9CanModule10CCanAccessE}]{\sphinxcrossref{CCanAccess}}}}%
\pysigstopmultiline~\subsubsection*{Public Functions}
\index{STCanScan::getPortStatus (C++ function)@\spxentry{STCanScan::getPortStatus}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vendors/systec:_CPPv4N9STCanScan13getPortStatusEv}}%
\pysigstartmultiline
\pysiglinewithargsret{\phantomsection\label{\detokenize{vendors/systec:classSTCanScan_1a27eabd471d3bb8154dfadb677c66e1d5}}uint32\_t \sphinxbfcode{\sphinxupquote{getPortStatus}}}{}{}%
\pysigstopmultiline
get CAN port and USB status, code it into an int \textgreater{} 200 (for windows@systec). use the API directly table19 says for CAN status: 0x0: no error 0x1: tx overrun 0x2: rx overrun 0x4: error limit1 exceeded: warning limit 0x8: error limit2 exceeded: error passive 0x10: can controller is off 0x40: rx buffer overrun 0x80: tx buffer overrun 0x400: transmit timeout, message dropped

table20 says for USB status: 0x2000: module/usb got reset because of polling failure per second 0x4000: module/usb got reset because watchdog was not triggered 

\end{fulllineitems}


\end{fulllineitems}


for linux:
.. doxygenclass:: CSockCanScan
\begin{quote}
\begin{quote}\begin{description}
\item[{project}] \leavevmode
CanModule

\item[{members}] \leavevmode
getPortStatus

\end{description}\end{quote}
\end{quote}


\section{errors}
\label{\detokenize{vendors/systec:errors}}
Errors and problems are available through two mechanisms:
\begin{itemize}
\item {} 
LogIt. This reports runtime errors detected by CanModule:
set the LogIt trace level to TRC and grep for “systec”, for component “CanModule”

\end{itemize}

\sphinxstylestrong{windows}
* vendor and hardware specific errors are available through connection of
\begin{quote}

an error handler (to a boost signal carrying the error message, see standard API).
\end{quote}
\index{STCanScan (C++ class)@\spxentry{STCanScan}\spxextra{C++ class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vendors/systec:_CPPv49STCanScan}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{vendors/systec:classSTCanScan}}\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{STCanScan}} : \sphinxbfcode{\sphinxupquote{public}} CanModule::{\hyperref[\detokenize{canports:_CPPv4N9CanModule10CCanAccessE}]{\sphinxcrossref{CCanAccess}}}}%
\pysigstopmultiline~\subsubsection*{Private Functions}
\index{STCanScan::STcanGetErrorText (C++ function)@\spxentry{STCanScan::STcanGetErrorText}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vendors/systec:_CPPv4N9STCanScan17STcanGetErrorTextEl}}%
\pysigstartmultiline
\pysiglinewithargsret{\phantomsection\label{\detokenize{vendors/systec:classSTCanScan_1a794110572725db6b7c153104ee1330b3}}std::string \sphinxbfcode{\sphinxupquote{STcanGetErrorText}}}{long \sphinxstyleemphasis{errCode}}{}%
\pysigstopmultiline
error text specific to STcan according to table24 I am just copying the whole descriptions from the doc, verbatim, wtf. you get some shakespeare from it. 

\end{fulllineitems}


\end{fulllineitems}


\sphinxstylestrong{linux}
* the error message from the ioctl call is returned, unfortunately it is rather unspecific.


\chapter{AnaGate}
\label{\detokenize{vendors/anagate:anagate}}\label{\detokenize{vendors/anagate::doc}}
All modules from vendor {\hyperref[\detokenize{vendors/anagate:anagate}]{\sphinxcrossref{AnaGate}}} are handled by class AnaCanScan which manages the modules through their underlying vendor specific API and provides
the standard generic CanModule API.

We support Anagate CAN\sphinxhyphen{}ethernet gateways: uno, duo, quattro, and the X2, X4 and X8.

Since these modules communicate to the host computer only via ethernet, at the fundamental level only classical
tcp/ip ethernet is needed. Nevertheless the specific contents of the IP frames are wrapped up in an Anagate API for convenience, which is linked
into the user code as a library. There are therefore no implementation differences between Linux and Windows.

The downside of Anagate CAN\sphinxhyphen{}ethernet modules is of course that the latency of the network has to be added to the bridge latency.


\section{status}
\label{\detokenize{vendors/anagate:status}}
status information is propagated through the unified status.
\index{AnaCanScan (C++ class)@\spxentry{AnaCanScan}\spxextra{C++ class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vendors/anagate:_CPPv410AnaCanScan}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{vendors/anagate:classAnaCanScan}}\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{AnaCanScan}} : \sphinxbfcode{\sphinxupquote{public}} CanModule::{\hyperref[\detokenize{canports:_CPPv4N9CanModule10CCanAccessE}]{\sphinxcrossref{CCanAccess}}}}%
\pysigstopmultiline~\subsubsection*{Public Functions}
\index{AnaCanScan::getPortStatus (C++ function)@\spxentry{AnaCanScan::getPortStatus}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vendors/anagate:_CPPv4N10AnaCanScan13getPortStatusEv}}%
\pysigstartmultiline
\pysiglinewithargsret{\phantomsection\label{\detokenize{vendors/anagate:classAnaCanScan_1a4c115df4a8755c0fd70030ae457af24c}}uint32\_t \sphinxbfcode{\sphinxupquote{getPortStatus}}}{}{}%
\pysigstopmultiline
CANCanDeviceConnectState , translate from counter 1 = DISCONNECTED : 2 = CONNECTING : 3 = CONNECTED 4 = DISCONNECTING 5 = NOT\_INITIALIZED b3…b27: unused

into simple bitpattern (counter) 0, 10, 11, 100, 101 

\end{fulllineitems}


\end{fulllineitems}



\section{errors}
\label{\detokenize{vendors/anagate:errors}}
Errors and problems are available through two mechanisms:
\begin{itemize}
\item {} 
LogIt. This reports runtime errors detected by CanModule:
set the LogIt trace level to TRC and grep for “anagate”, for component “CanModule”

\item {} 
vendor and hardware specific errors are available through connection of
an error handler (to a boost signal carrying the error message, see standard API).
The messages and error codes originate from the vendor api/implementation and are
reported as is without further processing. Messages are taken from the vendor’s API
documentation if available.

\end{itemize}
\index{AnaCanScan (C++ class)@\spxentry{AnaCanScan}\spxextra{C++ class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vendors/anagate:_CPPv410AnaCanScan}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{vendors/anagate:classAnaCanScan}}\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{AnaCanScan}} : \sphinxbfcode{\sphinxupquote{public}} CanModule::{\hyperref[\detokenize{canports:_CPPv4N9CanModule10CCanAccessE}]{\sphinxcrossref{CCanAccess}}}}%
\pysigstopmultiline~\subsubsection*{Private Functions}
\index{AnaCanScan::ana\_canGetErrorText (C++ function)@\spxentry{AnaCanScan::ana\_canGetErrorText}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vendors/anagate:_CPPv4N10AnaCanScan19ana_canGetErrorTextEl}}%
\pysigstartmultiline
\pysiglinewithargsret{\phantomsection\label{\detokenize{vendors/anagate:classAnaCanScan_1a1425dfc20e08b545fcdf49415ac15ec9}}std::string \sphinxbfcode{\sphinxupquote{ana\_canGetErrorText}}}{long \sphinxstyleemphasis{errorCode}}{}%
\pysigstopmultiline
give back the error message fro the code, from appendixA 

\end{fulllineitems}


\end{fulllineitems}



\chapter{Peak}
\label{\detokenize{vendors/peak:peak}}\label{\detokenize{vendors/peak::doc}}
All modules from vendor {\hyperref[\detokenize{vendors/peak:peak}]{\sphinxcrossref{Peak}}} are handled by class PKCanScan (windows) or CSockCanScan (linux) which
both manage the modules through their underlying vendor specific API according to the OS.
Both classes provide the standard generic CanModule API.

The modules from the families PCAN USB and USB Pro are supported. For linux, also the flexible
datarate (FD) module types are supported, but without FD functionality. This FD functionality
could be added in principle if requested.


\section{windows}
\label{\detokenize{vendors/peak:windows}}
The communication takes place through peak’s open\sphinxhyphen{}source PCAN\sphinxhyphen{}Basic windows library. Only “plug\sphinxhyphen{}and\sphinxhyphen{}play”
modules with USB interface and fixed datarate (non\sphinxhyphen{}FD) are supported by CanModule for now. PEAK’s
flexible datarate (FD) modules can be added later on (they need some different API\sphinxhyphen{}calls and more complex parameters), and also
other interfaces like PCI are possible for windows.The implementation is based on the PCAN\sphinxhyphen{}Basic driver.


\section{linux}
\label{\detokenize{vendors/peak:linux}}
The open\sphinxhyphen{}source socketcan interface is used on top of peak’s open source netdev driver. Both Peak’s
fixed and flexible datarate are working, although the fixed modules are recommended for bus compatibility.
Only modules with USB interface are supported.
The peak driver source is freely available and it can be configured to build several
types of drivers, where we use peak’s netdev driver only. See \sphinxhref{https://readthedocs.web.cern.ch/display/CANDev/CAN+development?src=sidebar}{PeakDriver} for details on this.
A PCAN\sphinxhyphen{}Basic driver is also available but the netdev driver is more performant and modern. The
PCAN\sphinxhyphen{}Basic driver is used nevertheless for windows, and it offers better compatibility for all module
families.

Unfortunately the peak linux driver does NOT provide deterministic port numbering through socketcan. On a
system with several PEAK bridges the port specification “sock:can0” is mapped to \sphinxstylestrong{any}
of the existing peak bridges (and the electronics can burn because you don’t know which
can\sphinxhyphen{}bus you are connected to !). In order to overcome this limitation for peak
(it really is a design error in their driver) an extended port identifier must be used: “sock:can0:device1234”.

CanModule then performs a udev system call and internally remaps the ports, so that “sock:can0:device1234”
will correspond to the first port of device 1234. The internal mapping is deterministic since the devices
can always be ordered ascending.
In order to use the deviceID (“1234”) it has to be set persistently for each module, using the windows
utility peakCan. Device ID numbers have to be unique in a system obviously. The assigning of port numbers
is then done in ascending order: the first batch of ports is from the device with the lowest device ID,
and so forth.
\index{udevanalyserforpeak\_ns::UdevAnalyserForPeak (C++ class)@\spxentry{udevanalyserforpeak\_ns::UdevAnalyserForPeak}\spxextra{C++ class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vendors/peak:_CPPv4N22udevanalyserforpeak_ns19UdevAnalyserForPeakE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{vendors/peak:classudevanalyserforpeak__ns_1_1UdevAnalyserForPeak}}\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{udevanalyserforpeak\_ns\sphinxcode{\sphinxupquote{::}}}}\sphinxbfcode{\sphinxupquote{UdevAnalyserForPeak}}}%
\pysigstopmultiline~\subsubsection*{Public Static Functions}
\index{udevanalyserforpeak\_ns::UdevAnalyserForPeak::getInstance (C++ function)@\spxentry{udevanalyserforpeak\_ns::UdevAnalyserForPeak::getInstance}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vendors/peak:_CPPv4N22udevanalyserforpeak_ns19UdevAnalyserForPeak11getInstanceEv}}%
\pysigstartmultiline
\pysiglinewithargsret{\phantomsection\label{\detokenize{vendors/peak:classudevanalyserforpeak__ns_1_1UdevAnalyserForPeak_1a0f9f020e963d202faff7a1a114713219}}{\hyperref[\detokenize{vendors/peak:_CPPv4N22udevanalyserforpeak_ns19UdevAnalyserForPeakE}]{\sphinxcrossref{UdevAnalyserForPeak}}} *\sphinxbfcode{\sphinxupquote{getInstance}}}{}{}%
\pysigstopmultiline
factory providing one singleton todo: use fancy threadsafe STATIC method 

\end{fulllineitems}

\index{udevanalyserforpeak\_ns::UdevAnalyserForPeak::peakExtendedIdentifierToSocketCanDevice (C++ function)@\spxentry{udevanalyserforpeak\_ns::UdevAnalyserForPeak::peakExtendedIdentifierToSocketCanDevice}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vendors/peak:_CPPv4N22udevanalyserforpeak_ns19UdevAnalyserForPeak39peakExtendedIdentifierToSocketCanDeviceENSt6stringE}}%
\pysigstartmultiline
\pysiglinewithargsret{\phantomsection\label{\detokenize{vendors/peak:classudevanalyserforpeak__ns_1_1UdevAnalyserForPeak_1a7edf6a8b32f9728aacf570a7704e560f}}std::string \sphinxbfcode{\sphinxupquote{peakExtendedIdentifierToSocketCanDevice}}}{std::string \sphinxstyleemphasis{portId}}{}%
\pysigstopmultiline
convert a PEAK extended portIdentifier to a socketcan device, i.e. “sock:can0:device123456” \sphinxhyphen{}\textgreater{} “can2”

\end{fulllineitems}

\index{udevanalyserforpeak\_ns::UdevAnalyserForPeak::PEAK\_device\_t (C++ struct)@\spxentry{udevanalyserforpeak\_ns::UdevAnalyserForPeak::PEAK\_device\_t}\spxextra{C++ struct}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vendors/peak:_CPPv4N22udevanalyserforpeak_ns19UdevAnalyserForPeak13PEAK_device_tE}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{vendors/peak:structudevanalyserforpeak__ns_1_1UdevAnalyserForPeak_1_1PEAK__device__t}}\sphinxbfcode{\sphinxupquote{struct }}\sphinxbfcode{\sphinxupquote{PEAK\_device\_t}}}%
\pysigstopmultiline
\end{fulllineitems}


\end{fulllineitems}



\subsection{status}
\label{\detokenize{vendors/peak:status}}
status information is propagated through the unified status.
For windows:
\index{PKCanScan (C++ class)@\spxentry{PKCanScan}\spxextra{C++ class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vendors/peak:_CPPv49PKCanScan}}%
\pysigstartmultiline
\pysigline{\phantomsection\label{\detokenize{vendors/peak:classPKCanScan}}\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{PKCanScan}} : \sphinxbfcode{\sphinxupquote{public}} CanModule::{\hyperref[\detokenize{canports:_CPPv4N9CanModule10CCanAccessE}]{\sphinxcrossref{CCanAccess}}}}%
\pysigstopmultiline~\subsubsection*{Public Functions}
\index{PKCanScan::getPortStatus (C++ function)@\spxentry{PKCanScan::getPortStatus}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vendors/peak:_CPPv4N9PKCanScan13getPortStatusEv}}%
\pysigstartmultiline
\pysiglinewithargsret{\phantomsection\label{\detokenize{vendors/peak:classPKCanScan_1aae31de6a82fcacc8ef3f581aff5305fc}}uint32\_t \sphinxbfcode{\sphinxupquote{getPortStatus}}}{}{}%
\pysigstopmultiline
PCANBasic.h:113 

\end{fulllineitems}


\end{fulllineitems}


for linux:
.. doxygenclass:: CSockCanScan
\begin{quote}
\begin{quote}\begin{description}
\item[{project}] \leavevmode
CanModule

\item[{members}] \leavevmode
getPortStatus

\end{description}\end{quote}
\end{quote}


\subsection{errors}
\label{\detokenize{vendors/peak:errors}}
Errors and problems are available through two mechanisms:
\begin{itemize}
\item {} 
LogIt. This reports runtime errors detected by CanModule:
set the LogIt trace level to TRC and grep for “peak”, for component “CanModule”

\end{itemize}

\sphinxstylestrong{windows}
* vendor and hardware specific errors are available through connection of
\begin{quote}

an error handler (to a boost signal carrying the error message, see standard API).
The messages and error codes originate from the vendor api/implementation and are
reported as is without further processing. Messages are taken from the vendor’s API
documentation if available. Peak relies on a vendor provided method: CAN\_GetErrorText.
\end{quote}

\sphinxstylestrong{linux}
* the error message from the ioctl call is returned, unfortunately it is rather unspecific.


\chapter{Reconnection OBSOLETE IS REWRITTEN CURRENTLY}
\label{\detokenize{reconnection:reconnection-obsolete-is-rewritten-currently}}\label{\detokenize{reconnection::doc}}

\section{anagate}
\label{\detokenize{reconnection:anagate}}
The anagate modules are identified by their IP address.

Sending messages are buffered for \textasciitilde{}20secs, and the reconnection
takes at least \textasciitilde{}20sec, so it takes \textasciitilde{}1 minute to reestablish communication. All received CAN frames
are lost, and not all sent frames are guaranteed, therefore some care has to be taken when the
connection is reestablished concerning the statuses of CAN slaves.

The anagate duo reconnects somewhat faster than the X4/X8 modules, because of firmware differences.
The whole reconnection can take up to 60 secs until all buffers are cleared, so please be patient.

WARNING: the Anagate modules tend to firmware\sphinxhyphen{}crash if too many CAN bus software close/open are
executed too quickly, making a power\sphinxhyphen{}cycle of the module necessary. A delay of 7 seconds
between a close and a (re\sphinxhyphen{})open per module is a good idea to avoid
“firmware\sphinxhyphen{}crashing” of the anagate module (CanModule does not impose such a delay).
This crash occurs independently from the connection timeout.

A bigger delay is recommended if it can be afforded: lab\sphinxhyphen{}tests show a 7sec delay still crashes
after 30 consecutive reconnects. These crashes can also be related to networking problems but
they are difficult to fix.


\section{peak}
\label{\detokenize{reconnection:peak}}

\subsection{linux/cc7}
\label{\detokenize{reconnection:linux-cc7}}
A power loss is recuperated correctly: the module is receiving power through the USB port,
if this connection is lost we need to reconnect. Reconnection works for both normal (fixed)
and flexible datarate (FD) modules under linux, as socketcan is used, and takes less than 30sec.


\subsection{windows}
\label{\detokenize{reconnection:windows}}
A power loss is recuperated correctly, but only normal datarate (fixed) are supported.
The single port close/open will typically work several times, and CanModule tries to
recuperate from a failed initialisation of the USB 10 times. Between successive attempts on a
given port a delay of several seconds is needed. This is not great, maybe further progress
can be made later.


\section{systec}
\label{\detokenize{reconnection:systec}}

\subsection{linux/cc7}
\label{\detokenize{reconnection:id1}}
A power loss or a connection loss will trigger a reconnection. For linux, where socketcan is used,
this works in the same way as for peak. Single port close/open is fully supported and works under
cc7 and also windows without limitations. If the sequence is too fast some messages will be lost, but the
module recuperates correctly in the following.


\subsection{windows}
\label{\detokenize{reconnection:id2}}
The whole module reconnection is NOT WORKING, and it is not clear if it can actually
be achieved within CanModule. It seems that a library reload is needed to make the module work again.
This feature is therefore DROPPED for now, since also no strong user request for “systec whole module reconnection
under windows” is presently stated. I tried, using the systec \sphinxhref{mailto:API@windows}{API@windows} as documented, but did not manage.

Single port close/open works correctly, some messages can be lost.


\chapter{Logging}
\label{\detokenize{logging:logging}}\label{\detokenize{logging::doc}}
CanModule uses \sphinxhref{https://github.com/quasar-team/LogIt}{LogIt} for reporting information during runtime. LogIt uses one component “CanModule”
\begin{itemize}
\item {} 
CanModule: general messages concerning CanModule itself

\item {} 
CanModule Anagate: messages related to AnaGate modules contain a string “anagate”

\item {} 
CanModule Systec: messages related to SysTec modules contain a string “systec”

\item {} 
CanModule Peak: messages related to Peak modules contain a string “peak”

\end{itemize}

for managing logging levels. The logging level of each component, if the component is used, can be set individually
at any time once initialized. Vendor specific messages can be filtered out by using the specific strings.
For windows the strings are as listed above, for linux the string “sock” is used for Systec and Peak modules.

You can of course add your own components for specific logging, like MYCOMP in the code below.

\sphinxstylestrong{The calling program (“main”) uses CanModule and LogIt like this}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}CanBusAccess.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}LogIt.h\PYGZgt{}}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LogComponentHandle} \PYG{n}{myHandle} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LogComponentHandle} \PYG{n}{canModuleHandle} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LOG\PYGZus{}LEVEL} \PYG{n}{loglevel} \PYG{o}{=} \PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{INF}\PYG{p}{;}    \PYG{c+c1}{// recommended default for production is WRN}
\PYG{k+kt}{bool} \PYG{n}{ret} \PYG{o}{=} \PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{initializeLogging}\PYG{p}{(} \PYG{n}{loglevel} \PYG{p}{)}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(} \PYG{n}{ret} \PYG{p}{)}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{LogIt initialized OK}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{k}{else}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{LogIt problem at initialisation}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setNonComponentLogLevel}\PYG{p}{(} \PYG{n}{loglevel} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Log level set to }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{loglevel} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{n}{LogItInstance} \PYG{o}{*}\PYG{n}{logIt} \PYG{o}{=} \PYG{n}{LogItInstance}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getInstance}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{c+cm}{/**}
\PYG{c+cm}{ * LogIt component MYCOMP for main}
\PYG{c+cm}{ */}
\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{registerLoggingComponent}\PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MYCOMP}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{loglevel} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{logIt}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getComponentHandle}\PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MYCOMP}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{myHandle} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setComponentLogLevel}\PYG{p}{(} \PYG{n}{myHandle}\PYG{p}{,} \PYG{n}{loglevel} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{LOG}\PYG{p}{(}\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{INF}\PYG{p}{,} \PYG{n}{myHandle}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{argv}\PYG{p}{[} \PYG{l+m+mi}{0} \PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ logging for component MYCOMP}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{c+c1}{// hourray, we should see this message because we are at INF}

\PYG{c+cm}{/**}
\PYG{c+cm}{ * LogIt component CanModule}
\PYG{c+cm}{ */}
\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{registerLoggingComponent}\PYG{p}{(} \PYG{n}{CanModule}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LogItComponentName}\PYG{p}{,} \PYG{n}{loglevel} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{logIt}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getComponentHandle}\PYG{p}{(}\PYG{n}{CanModule}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LogItComponentName}\PYG{p}{,} \PYG{n}{canModuleHandle} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setComponentLogLevel}\PYG{p}{(} \PYG{n}{canModuleHandle}\PYG{p}{,} \PYG{n}{loglevel} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{LOG}\PYG{p}{(}\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{INF}\PYG{p}{,} \PYG{n}{canModuleHandle}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ logging for component }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{CanModule}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LogItComponentName}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxstylestrong{then, some work is done i.e. like that:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// do sth useful with CanModule, i.e. talk to a port}
\PYG{n}{string} \PYG{n}{libName} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{st}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}           \PYG{c+c1}{// here: systec, windows}
\PYG{n}{string} \PYG{n}{port} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{st:can0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}         \PYG{c+c1}{// here: CAN port 0, windows}
\PYG{n}{string} \PYG{n}{parameters} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Undefined}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;} \PYG{c+c1}{// here: use defaults}
\PYG{n}{CanMessage} \PYG{n}{cm}\PYG{p}{;}
\PYG{n}{CanModule}\PYG{o}{:}\PYG{o}{:}\PYG{n}{CanLibLoader} \PYG{o}{*}\PYG{n}{libloader} \PYG{o}{=} \PYG{n}{CanModule}\PYG{o}{:}\PYG{o}{:}\PYG{n}{CanLibLoader}\PYG{o}{:}\PYG{o}{:}\PYG{n}{createInstance}\PYG{p}{(} \PYG{n}{libName} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{cca} \PYG{o}{=} \PYG{n}{libloader}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{openCanBus}\PYG{p}{(} \PYG{n}{port}\PYG{p}{,} \PYG{n}{parameters} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{cca}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{sendMessage}\PYG{p}{(} \PYG{o}{\PYGZam{}}\PYG{n}{cm} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{cca}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{canMessageCame}\PYG{p}{.}\PYG{n}{connect}\PYG{p}{(} \PYG{o}{\PYGZam{}}\PYG{n}{onMessageRcvd} \PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// connect a reception handler, see standardApi for details}
\end{sphinxVerbatim}

\sphinxstylestrong{and at any time the logging levels of the components can be changed. This is typically done by a user interaction
on a running server instance.}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/**}
\PYG{c+cm}{ * manipulate LogIt levels per component for testing, during runtime. Set loglevel to TRC (max verbosity)}
\PYG{c+cm}{ */}
\PYG{n}{loglevel} \PYG{o}{=} \PYG{n}{LOG}\PYG{o}{:}\PYG{o}{:}\PYG{n}{TRC}\PYG{p}{;}
\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LogComponentHandle} \PYG{n}{handle}\PYG{p}{;}
\PYG{n}{logIt}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getComponentHandle}\PYG{p}{(}\PYG{n}{CanModule}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LogItComponentName}\PYG{p}{,} \PYG{n}{handle} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setComponentLogLevel}\PYG{p}{(} \PYG{n}{handle}\PYG{p}{,} \PYG{n}{loglevel} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{LOG}\PYG{p}{(}\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{INF}\PYG{p}{,} \PYG{n}{handle}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ logging for component }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{CanModule}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LogItComponentName}\PYG{p}{;}
\end{sphinxVerbatim}


\chapter{Building}
\label{\detokenize{building:building}}\label{\detokenize{building::doc}}
We use \sphinxhref{https://cmake.org/}{cmake} 3.0 or higher for multi\sphinxhyphen{}OS building.
The dependencies are:
\begin{itemize}
\item {} 
\sphinxhref{http://xerces.apache.org/xerces-c/}{xerces}\sphinxhyphen{}c

\item {} 
\sphinxhref{https://www.boost.org/}{boost} (1.64.0 or later preferred, but any version \textgreater{}=1.59.0 should work)

\item {} 
\sphinxhref{https://gitlab.cern.ch/mludwig/CAN\_libsocketcan}{socketcan} libs (CC7, ubuntu) (not to be confused with the CanModule sockcan.so lib!).
They can also be found in various places for open software.

\item {} 
dependencies for CanModule: LogIt (sources to github pulled in by cmake)

\item {} 
vendor libs (to be installed on your build/target machine)

\item {} \begin{description}
\item[{if general vendor builds are off you will build ONLY mockup. Using the toolchain:}] \leavevmode\begin{itemize}
\item {} 
SET( CANMODULE\_BUILD\_VENDORS “OFF”) or UNSET( CANMODULE\_BUILD\_VENDORS ) or \textless{}nothing\textgreater{}

\item {} 
default is therefore “OFF” if you do nothing

\end{itemize}

\end{description}

\item {} 
if you need the general vendor builds, and usually that is the case, then you need to
switch them on explicitly in the toolchain:
\begin{itemize}
\item {} 
SET( CANMODULE\_BUILD\_VENDORS “ON”)

\end{itemize}

\item {} \begin{description}
\item[{you can switch off selected vendor builds which you do not need using the toolchain:}] \leavevmode\begin{itemize}
\item {} 
SET(CANMODULE\_BUILD\_SYSTEC “OFF”)

\item {} 
SET(CANMODULE\_BUILD\_ANAGATE “OFF”)

\item {} 
SET(CANMODULE\_BUILD\_PEAK “OFF”)

\item {} 
by default, all selected vendors are built

\end{itemize}

\end{description}

\end{itemize}

\sphinxstylestrong{These dependencies should conveniently be injected into cmake using a toolchain file:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CMakeLists.txt:
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
(...other stuff)
\PYGZsh{}
\PYGZsh{} Load build toolchain file and internal checks before we start building
\PYGZsh{}
if( DEFINED CMAKE\PYGZus{}TOOLCHAIN\PYGZus{}FILE )
   message( STATUS \PYGZdq{}[\PYGZdl{}\PYGZob{}CMAKE\PYGZus{}CURRENT\PYGZus{}LIST\PYGZus{}FILE\PYGZcb{}:\PYGZdl{}\PYGZob{}CMAKE\PYGZus{}CURRENT\PYGZus{}LIST\PYGZus{}LINE\PYGZcb{}]: CMAKE\PYGZus{}TOOLCHAIN\PYGZus{}FILE is defined \PYGZhy{}\PYGZhy{} including [\PYGZdl{}\PYGZob{}CMAKE\PYGZus{}TOOLCHAIN\PYGZus{}FILE\PYGZcb{}]\PYGZdq{})
   include( \PYGZdl{}\PYGZob{}CMAKE\PYGZus{}TOOLCHAIN\PYGZus{}FILE\PYGZcb{} )
endif()
(...other stuff)
\end{sphinxVerbatim}

\sphinxstylestrong{The toolchain file would look like this (i.e. windows):}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toolchain}\PYG{o}{.}\PYG{n}{cmake}\PYG{p}{:}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{c+c1}{\PYGZsh{} toolchain for CANX\PYGZhy{}tester for CI jenkins, w10e}
\PYG{c+c1}{\PYGZsh{} mludwig at cern dot ch}
\PYG{c+c1}{\PYGZsh{} cmake \PYGZhy{}DCMAKE\PYGZus{}TOOLCHAIN\PYGZus{}FILE=jenkins\PYGZus{}CanModule\PYGZus{}w10e.cmake .}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} boost}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} bin download from sl}
\PYG{n}{SET} \PYG{p}{(} \PYG{n}{BOOST\PYGZus{}PATH\PYGZus{}LIBS} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{M:/3rdPartySoftware/boost\PYGZus{}1\PYGZus{}59\PYGZus{}0\PYGZhy{}msvc\PYGZhy{}14/lib64}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{)}
\PYG{n}{SET} \PYG{p}{(} \PYG{n}{BOOST\PYGZus{}HEADERS} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{M:/3rdPartySoftware/boost\PYGZus{}1\PYGZus{}59\PYGZus{}0\PYGZhy{}msvc\PYGZhy{}14}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{)}
\PYG{n}{SET} \PYG{p}{(} \PYG{n}{BOOST\PYGZus{}LIBS} \PYG{o}{\PYGZhy{}}\PYG{n}{lboost\PYGZus{}log} \PYG{o}{\PYGZhy{}}\PYG{n}{lboost\PYGZus{}log\PYGZus{}setup} \PYG{o}{\PYGZhy{}}\PYG{n}{lboost\PYGZus{}filesystem} \PYG{o}{\PYGZhy{}}\PYG{n}{lboost\PYGZus{}system} \PYG{o}{\PYGZhy{}}\PYG{n}{lboost\PYGZus{}chrono} \PYG{o}{\PYGZhy{}}\PYG{n}{lboost\PYGZus{}date\PYGZus{}time} \PYG{o}{\PYGZhy{}}\PYG{n}{lboost\PYGZus{}thread}  \PYG{p}{)}
\PYG{n}{message}\PYG{p}{(} \PYG{n}{STATUS} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{[\PYGZdl{}}\PYG{l+s+si}{\PYGZob{}CMAKE\PYGZus{}CURRENT\PYGZus{}LIST\PYGZus{}FILE\PYGZcb{}}\PYG{l+s+s2}{:\PYGZdl{}}\PYG{l+s+si}{\PYGZob{}CMAKE\PYGZus{}CURRENT\PYGZus{}LIST\PYGZus{}LINE\PYGZcb{}}\PYG{l+s+s2}{] toolchain defines [BOOST\PYGZus{}PATH\PYGZus{}LIBS:\PYGZdl{}}\PYG{l+s+si}{\PYGZob{}BOOST\PYGZus{}PATH\PYGZus{}LIBS\PYGZcb{}}\PYG{l+s+s2}{]}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{)}
\PYG{n}{message}\PYG{p}{(} \PYG{n}{STATUS} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{[\PYGZdl{}}\PYG{l+s+si}{\PYGZob{}CMAKE\PYGZus{}CURRENT\PYGZus{}LIST\PYGZus{}FILE\PYGZcb{}}\PYG{l+s+s2}{:\PYGZdl{}}\PYG{l+s+si}{\PYGZob{}CMAKE\PYGZus{}CURRENT\PYGZus{}LIST\PYGZus{}LINE\PYGZcb{}}\PYG{l+s+s2}{] toolchain defines [BOOST\PYGZus{}HEADERS:\PYGZdl{}}\PYG{l+s+si}{\PYGZob{}BOOST\PYGZus{}HEADERS\PYGZcb{}}\PYG{l+s+s2}{]}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{)}
\PYG{n}{message}\PYG{p}{(} \PYG{n}{STATUS} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{[\PYGZdl{}}\PYG{l+s+si}{\PYGZob{}CMAKE\PYGZus{}CURRENT\PYGZus{}LIST\PYGZus{}FILE\PYGZcb{}}\PYG{l+s+s2}{:\PYGZdl{}}\PYG{l+s+si}{\PYGZob{}CMAKE\PYGZus{}CURRENT\PYGZus{}LIST\PYGZus{}LINE\PYGZcb{}}\PYG{l+s+s2}{] toolchain defines [BOOST\PYGZus{}LIBS:\PYGZdl{}}\PYG{l+s+si}{\PYGZob{}BOOST\PYGZus{}LIBS\PYGZcb{}}\PYG{l+s+s2}{]}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} LogIt, used by CANX directly as well}
\PYG{c+c1}{\PYGZsh{}}
\PYG{n}{SET} \PYG{p}{(} \PYG{n}{LOGIT\PYGZus{}HEADERS}   \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}ENV}\PYG{l+s+si}{\PYGZob{}JENKINSWS\PYGZcb{}}\PYG{l+s+s2}{/CanModule/LogIt/include}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{)}
\PYG{n}{SET} \PYG{p}{(} \PYG{n}{LOGIT\PYGZus{}PATH\PYGZus{}LIBS} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}ENV}\PYG{l+s+si}{\PYGZob{}JENKINSWS\PYGZcb{}}\PYG{l+s+s2}{/CanModule/LogIt/lib}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{)}
\PYG{n}{SET} \PYG{p}{(} \PYG{n}{LOGIT\PYGZus{}LIBS} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}lLogIt}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} xerces\PYGZhy{}c}
\PYG{c+c1}{\PYGZsh{}}
\PYG{n}{SET} \PYG{p}{(} \PYG{n}{XERCES\PYGZus{}PATH\PYGZus{}LIBS} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{M:/3rdPartySoftware/xerces\PYGZhy{}c\PYGZhy{}3.2.0\PYGZus{}64bit/src/Debug}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{)}
\PYG{n}{SET} \PYG{p}{(} \PYG{n}{XERCES\PYGZus{}HEADERS} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{M:/3rdPartySoftware/xerces\PYGZhy{}c\PYGZhy{}3.2.0\PYGZus{}64bit/src}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{)}
\PYG{n}{SET} \PYG{p}{(} \PYG{n}{XERCES\PYGZus{}LIBS} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{xerces\PYGZhy{}c\PYGZus{}3D.lib}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} CanModule build behaviour:}
\PYG{c+c1}{\PYGZsh{} CANMODULE\PYGZus{}BUILD\PYGZus{}VENDORS OFF or not specified: only build mockup, do not build any vendor libs (default phony)}
\PYG{c+c1}{\PYGZsh{} CANMODULE\PYGZus{}BUILD\PYGZus{}VENDORS ON, nothing else: build mockup and all vendor libs (default all on)}
\PYG{c+c1}{\PYGZsh{} CANMODULE\PYGZus{}BUILD\PYGZus{}VENDORS ON, CANMODULE\PYGZus{}BUILD\PYGZus{}SYSTEC OFF: build mockup and all vendor libs except systec (drop systec)}
\PYG{c+c1}{\PYGZsh{} CANMODULE\PYGZus{}BUILD\PYGZus{}VENDORS ON, CANMODULE\PYGZus{}BUILD\PYGZus{}ANAGATE OFF: build mockup and all vendor libs except anagate (drop anagate)}
\PYG{c+c1}{\PYGZsh{} CANMODULE\PYGZus{}BUILD\PYGZus{}VENDORS ON, CANMODULE\PYGZus{}BUILD\PYGZus{}PEAK OFF: build mockup and all vendor libs except peak (drop peak)}
\PYG{n}{SET}\PYG{p}{(}\PYG{n}{CANMODULE\PYGZus{}BUILD\PYGZus{}VENDORS} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ON}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} disable a vendor}
\PYG{c+c1}{\PYGZsh{}SET(CANMODULE\PYGZus{}BUILD\PYGZus{}SYSTEC \PYGZdq{}OFF\PYGZdq{})}
\PYG{c+c1}{\PYGZsh{}SET(CANMODULE\PYGZus{}BUILD\PYGZus{}ANAGATE \PYGZdq{}OFF\PYGZdq{})}
\PYG{n}{SET}\PYG{p}{(}\PYG{n}{CANMODULE\PYGZus{}BUILD\PYGZus{}PEAK} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{OFF}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} systec}
\PYG{c+c1}{\PYGZsh{} version 6.02 for windows 10 7may2018}
\PYG{n}{SET}\PYG{p}{(} \PYG{n}{SYSTEC\PYGZus{}LIB\PYGZus{}FILE} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{M:/3rdPartySoftware/SYSTEC\PYGZhy{}electronic/USB\PYGZhy{}CANmodul Utility Disk/Examples/Lib/USBCAN64.lib}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{SET}\PYG{p}{(} \PYG{n}{SYSTEC\PYGZus{}HEADERS} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{M:/3rdPartySoftware/SYSTEC\PYGZhy{}electronic/USB\PYGZhy{}CANmodul Utility Disk/Examples/Include}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{SET}\PYG{p}{(} \PYG{n}{SYSTEC\PYGZus{}LIB\PYGZus{}PATH} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{M:/3rdPartySoftware/SYSTEC\PYGZhy{}electronic/USB\PYGZhy{}CANmodul Utility Disk/Examples/lib}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} anagate}
\PYG{c+c1}{\PYGZsh{} version vc8 as it seems}
\PYG{n}{SET}\PYG{p}{(} \PYG{n}{ANAGATE\PYGZus{}LIB\PYGZus{}FILE} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{AnaGateCanDll64.lib}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{SET}\PYG{p}{(} \PYG{n}{ANAGATE\PYGZus{}HEADERS} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{M:/3rdPartySoftware/AnaGateCAN/win64/vc8/include}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{)}
\PYG{n}{SET}\PYG{p}{(} \PYG{n}{ANAGATE\PYGZus{}LIB\PYGZus{}PATH} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{M:/3rdPartySoftware/AnaGateCAN/win64/vc8/Release}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} peak}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} version PCAN Basic 4.3.2}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}SET( PEAK\PYGZus{}LIB\PYGZus{}FILE \PYGZdq{}PCANBasic.lib\PYGZdq{})}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}SET( PEAK\PYGZus{}HEADERS \PYGZdq{}M:/3rdPartySoftware/PCAN\PYGZhy{}Basic API/Include\PYGZdq{} )}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}SET( PEAK\PYGZus{}LIB\PYGZus{}PATH \PYGZdq{}M:/3rdPartySoftware/PCAN\PYGZhy{}Basic API/x64/VC\PYGZus{}LIB\PYGZdq{} )}
\end{sphinxVerbatim}

\sphinxstylestrong{The toolchain gets then injected by running cmake:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cmake} \PYG{o}{\PYGZhy{}}\PYG{n}{DCMAKE\PYGZus{}TOOLCHAIN\PYGZus{}FILE}\PYG{o}{=}\PYG{n}{toolchain}\PYG{o}{.}\PYG{n}{cmake}
\end{sphinxVerbatim}


\section{shared and static linking}
\label{\detokenize{building:shared-and-static-linking}}
CanModule uses all shared libraries, and also loads shared libraries during runtime for each connection
object and vendor. Nevertheless some shared libraries with reduced dependencies can be built in
some cases for linux: they have suffix {\color{red}\bfseries{}*}\sphinxhyphen{}static.so .
If the vendor APIs come in the form of relocateable static libraries/archives (\sphinxhyphen{}fPIC), then they
can sometimes be integrated as static into the CanModule specific vendor shared lib.

\sphinxstylestrong{Linux (CC7, ubuntu):}
if the environment variable CANMODULE\_AS\_STATIC\_AS\_POSSIBLE=1 is set during building the {\color{red}\bfseries{}*}\sphinxhyphen{}static
libs are produced with boost and other specific dependencies integrated as possible:
\begin{itemize}
\item {} 
ancan\sphinxhyphen{}static.so

\item {} 
sockcan\sphinxhyphen{}static.so

\item {} 
CanModule\sphinxhyphen{}static.so

\end{itemize}

During execution, CanModule(\sphinxhyphen{}static.so or .so) looks for the standard shared libs, but sockewtcan and boost
are linked into static.
If you want to use the “reduced dependencies” versions then the env var CANMODULE\_AS\_STATIC\_AS\_POSSIBLE=1
has to be set \sphinxstylestrong{during runtime} as well.
\begin{itemize}
\item {} 
boost\_1\_74\_0 (or such) has to be built to provide both shared and static libs:

\end{itemize}

cd ./boost/boost\_1\_7XX\_0
./bootstrap.sh
./b2 \sphinxhyphen{}j 7 link=static,shared threading=multi define=BOOST\_DISABLE\_WIN32 cxxflags=”\sphinxhyphen{}fPIC”

\sphinxstylestrong{Windows}

No reduced dependencies libs are available at this point.


\subsection{QA and documentation}
\label{\detokenize{building:qa-and-documentation}}
Local gitlab runners are used for the ics\sphinxhyphen{}fd\sphinxhyphen{}qa and documentation integration into the CI/CD. Therefore the \sphinxhref{https://github.com/quasar-team/CanModule.git}{githubCanModule}
repo is mirrored into \sphinxhref{https://gitlab.cern.ch/mludwig/canmodule-mirror.git}{gitlabCanModule} and the .gitlab\sphinxhyphen{}ci.yml is executed on gitlab for the two stages only:
\begin{itemize}
\item {} 
ics\sphinxhyphen{}fd\sphinxhyphen{}qa

\item {} 
documentation.

\end{itemize}

No libraries or binaries are built, since anyway CanModule is cross\sphinxhyphen{}platform and cannot be built entirely on gitlab
runners. A jenkins instance at \sphinxhref{https://ics-fd-cpp-master.web.cern.ch/view/CAN}{jenkins} is used instead.

The QA results are available at \sphinxhref{https://cvl.sonarqube.cern.ch}{sonarqube} under ics\sphinxhyphen{}fd\sphinxhyphen{}qa\sphinxhyphen{}CanModule\sphinxhyphen{}mirror


\chapter{Running}
\label{\detokenize{running:running}}\label{\detokenize{running::doc}}
The proper kernel modules, drivers and libraries for the vendors used through CanModule
have to be present during runtime obviously. You will need the \sphinxhref{https://gitlab.cern.ch/mludwig/canmodulevendorlibs}{CanModuleVendorLibs} .


\section{general dependencies}
\label{\detokenize{running:general-dependencies}}\begin{itemize}
\item {} 
CanModule.dll/.so

\item {} 
LogIt (cloned from github during cmake)

\item {} 
boost 1.73.0 or similar (depending on your build)

\item {} 
xerces 3.2 (xerces\sphinxhyphen{}c\_3\_2D.dll)

\end{itemize}


\section{Anagate}
\label{\detokenize{running:anagate}}\begin{itemize}
\item {} 
libancan.dll/.so  (standard API)

\item {} 
linux: libAPIRelease64.so, libCANDLLRelease64.so, libAnaGateExtRelease.so, libAnaGateRelease.so

\item {} 
windows: ANAGATECAN64.dll

\end{itemize}


\section{Systec}
\label{\detokenize{running:systec}}\begin{itemize}
\item {} 
linux: libsockcan.so (standard API), driver kernel module systec\_can.ko and dependent modules, libsocketcan.so

\item {} 
windows: libstcan.dll (standard API), USBCAN64.dll

\end{itemize}


\section{Peak}
\label{\detokenize{running:peak}}\begin{itemize}
\item {} 
linux: libsockcan.so (standard API), driver kernel module pcan.ko and dependent modules, libsocketcan.so

\item {} 
windows: libpkcan.dll (standard API), PKCANBASIC.dll

\end{itemize}


\chapter{Support}
\label{\detokenize{support:support}}\label{\detokenize{support::doc}}
Support for CanModule is given CERN wide.

\sphinxstylestrong{Problems, Issues and Requests} should be created as CERN \sphinxhref{https://its.cern.ch/jira/secure/Dashboard.jspa}{Jira} Tickets:
\begin{itemize}
\item {} 
Project= OPC UA in JCOP (OPCUA)

\item {} 
Components= CanModule

\item {} 
Assignee= Michael Ludwig

\end{itemize}

Please provide traces of your situation and information about your project context. We will sort it out together.

Many CAN related problems have been solved in the past by
\begin{itemize}
\item {} 
correcting the bus termination (should be terminated in most cases)

\item {} 
correcting the bus bitrate to match the slaves (125000bits/sec is default)

\item {} 
driver problems, vendor libs not found

\item {} 
small configuration errors

\end{itemize}

And yes, there can be bugs as well.

More \sphinxstylestrong{personal} ways to get help or report problems:
\begin{itemize}
\item {} 
You can send me an \sphinxhref{mailto:michael.ludwig@cern.ch?subject=CanModule\_issue\_found\&body=HelloMichael,}{Email} or call me 163095 or visit me for a coffee.

\item {} 
Please also take a look at \sphinxhref{https://its.cern.ch/jira/browse/OPCUA-1362?jql=assignee\%20\%3D\%20currentUser()\%20AND\%20component\%20\%3D\%20CanModule\%20AND\%20project\%20\%3D\%20OPCUA}{JiraSearch} for already existing issues.

\end{itemize}


\chapter{alphabetical index}
\label{\detokenize{index:alphabetical-index}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}