<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.17">
  <compounddef id="classCSockCanScan" kind="class" language="C++" prot="public">
    <compoundname>CSockCanScan</compoundname>
    <basecompoundref refid="classCanModule_1_1CCanAccess" prot="public" virt="non-virtual">CanModule::CCanAccess</basecompoundref>
    <includes refid="SockCanScan_8h" local="no">SockCanScan.h</includes>
      <sectiondef kind="public-static-attrib">
      <memberdef kind="variable" id="classCSockCanScan_1a596ffa46b85d51c580757cab52baead9" prot="public" static="yes" mutable="no">
        <type>std::map&lt; string, string &gt;</type>
        <definition>std::map&lt; string, string &gt; CSockCanScan::m_busMap</definition>
        <argsstring></argsstring>
        <name>m_busMap</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Â© Copyright CERN, 2015. All rights not expressly granted are reserved.</para>
<para><ref refid="SockCanScan_8cpp" kindref="compound">SockCanScan.cpp</ref></para>
<para>Created on: Jul 21, 2011 Based on work by vfilimon Rework and logging done by Piotr Nikiel <ulink url="mailto:piotr@nikiel.info">piotr@nikiel.info</ulink> mludwig at cern dot ch</para>
<para>This file is part of Quasar.</para>
<para>Quasar is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public Licence as published by the Free Software Foundation, either version 3 of the Licence.</para>
<para>Quasar is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public Licence for more details.</para>
<para>You should have received a copy of the GNU Lesser General Public License along with Quasar. If not, see <ulink url="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</ulink>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CanInterfaceImplementations/sockcan/SockCanScan.h" line="98" column="17" bodyfile="CanInterfaceImplementations/sockcan/SockCanScan.h" bodystart="98" bodyend="-1"/>
        <referencedby refid="classCSockCanScan_1a879da2908384a8f154120bdd0c60c5aa" compoundref="SockCanScan_8cpp" startline="897" endline="958">createBus</referencedby>
        <referencedby refid="classCSockCanScan_1a7be2c075520b1cbf4baa4eb7d728fd2d" compoundref="SockCanScan_8cpp" startline="1057" endline="1078">stopBus</referencedby>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="classCSockCanScan_1aab77a9dc136d4c01ce31021929412ddb" prot="private" static="no" mutable="no">
        <type>atomic_bool</type>
        <definition>volatile atomic_bool CSockCanScan::m_CanScanThreadRunEnableFlag</definition>
        <argsstring></argsstring>
        <name>m_CanScanThreadRunEnableFlag</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CanInterfaceImplementations/sockcan/SockCanScan.h" line="116" column="22" bodyfile="CanInterfaceImplementations/sockcan/SockCanScan.h" bodystart="116" bodyend="-1"/>
        <referencedby refid="classCSockCanScan_1a879da2908384a8f154120bdd0c60c5aa" compoundref="SockCanScan_8cpp" startline="897" endline="958">createBus</referencedby>
        <referencedby refid="classCSockCanScan_1a485ec8621a98cdacad8e27433e09d919" compoundref="SockCanScan_8cpp" startline="691" endline="821">sendMessage</referencedby>
        <referencedby refid="classCSockCanScan_1a7be2c075520b1cbf4baa4eb7d728fd2d" compoundref="SockCanScan_8cpp" startline="1057" endline="1078">stopBus</referencedby>
      </memberdef>
      <memberdef kind="variable" id="classCSockCanScan_1aff132a17957a6e0c93ee76be0c2cdc88" prot="private" static="no" mutable="no">
        <type>atomic_int</type>
        <definition>atomic_int CSockCanScan::m_sock</definition>
        <argsstring></argsstring>
        <name>m_sock</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CanInterfaceImplementations/sockcan/SockCanScan.h" line="118" column="12" bodyfile="CanInterfaceImplementations/sockcan/SockCanScan.h" bodystart="118" bodyend="-1"/>
        <referencedby refid="classCSockCanScan_1a808488b6793afea6cc8466c3a12a088c" compoundref="SockCanScan_8cpp" startline="369" endline="486">CanReconnectionThread</referencedby>
        <referencedby refid="classCSockCanScan_1a4b5f7591bfd27b8770bfb9ac9e406f66" compoundref="SockCanScan_8cpp" startline="1037" endline="1044">clearErrorMessage</referencedby>
        <referencedby refid="classCSockCanScan_1a879da2908384a8f154120bdd0c60c5aa" compoundref="SockCanScan_8cpp" startline="897" endline="958">createBus</referencedby>
        <referencedby refid="classCSockCanScan_1a203a51239f8efc013d4b9df36f271317" compoundref="SockCanScan_8cpp" startline="535" endline="611">openCanPort</referencedby>
        <referencedby refid="classCSockCanScan_1a512733f202345e5940460f84539c979a" compoundref="SockCanScan_8cpp" startline="1046" endline="1052">sendErrorMessage</referencedby>
        <referencedby refid="classCSockCanScan_1a485ec8621a98cdacad8e27433e09d919" compoundref="SockCanScan_8cpp" startline="691" endline="821">sendMessage</referencedby>
        <referencedby refid="classCSockCanScan_1a4999204ff7166ee992a89b30a118af06" compoundref="SockCanScan_8cpp" startline="831" endline="870">sendRemoteRequest</referencedby>
      </memberdef>
      <memberdef kind="variable" id="classCSockCanScan_1a01a0096926dc8236ae11077deb5e02a2" prot="private" static="no" mutable="no">
        <type>int</type>
        <definition>int CSockCanScan::m_errorCode</definition>
        <argsstring></argsstring>
        <name>m_errorCode</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CanInterfaceImplementations/sockcan/SockCanScan.h" line="120" column="5" bodyfile="CanInterfaceImplementations/sockcan/SockCanScan.h" bodystart="120" bodyend="-1"/>
        <referencedby refid="classCSockCanScan_1a203a51239f8efc013d4b9df36f271317" compoundref="SockCanScan_8cpp" startline="535" endline="611">openCanPort</referencedby>
        <referencedby refid="classCSockCanScan_1a623057580187ecb241adf143c64d711c" compoundref="SockCanScan_8cpp" startline="1089" endline="1098">updateInitialError</referencedby>
      </memberdef>
      <memberdef kind="variable" id="classCSockCanScan_1afe0c7cc23de0ac2d758a07bec4c2e2c8" prot="private" static="no" mutable="no">
        <type><ref refid="classCanModule_1_1CanStatistics" kindref="compound">CanStatistics</ref></type>
        <definition>CanStatistics CSockCanScan::m_statistics</definition>
        <argsstring></argsstring>
        <name>m_statistics</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CanInterfaceImplementations/sockcan/SockCanScan.h" line="122" column="15" bodyfile="CanInterfaceImplementations/sockcan/SockCanScan.h" bodystart="122" bodyend="-1"/>
        <referencedby refid="classCSockCanScan_1abfb8f5e3726f9675a63f48648afae178" compoundref="SockCanScan_8cpp" startline="67" endline="78">CSockCanScan</referencedby>
        <referencedby refid="classCSockCanScan_1a38110f02c2d12fa9b620ba5ff438a960" compoundref="SockCanScan_8cpp" startline="1080" endline="1087">getStatistics</referencedby>
        <referencedby refid="classCSockCanScan_1a203a51239f8efc013d4b9df36f271317" compoundref="SockCanScan_8cpp" startline="535" endline="611">openCanPort</referencedby>
        <referencedby refid="classCSockCanScan_1a4999204ff7166ee992a89b30a118af06" compoundref="SockCanScan_8cpp" startline="831" endline="870">sendRemoteRequest</referencedby>
        <referencedby refid="classCSockCanScan_1aaed83a57ee1b70fff48a1a5ca9655fe6" compoundref="SockCanScan_8cpp" startline="633" endline="674">updateBusStatus</referencedby>
      </memberdef>
      <memberdef kind="variable" id="classCSockCanScan_1a344d3a2b2d61a0adbc364e980af7c740" prot="private" static="no" mutable="no">
        <type>std::thread *</type>
        <definition>std::thread* CSockCanScan::m_hCanScanThread</definition>
        <argsstring></argsstring>
        <name>m_hCanScanThread</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CanInterfaceImplementations/sockcan/SockCanScan.h" line="123" column="13" bodyfile="CanInterfaceImplementations/sockcan/SockCanScan.h" bodystart="123" bodyend="-1"/>
        <referencedby refid="classCSockCanScan_1a879da2908384a8f154120bdd0c60c5aa" compoundref="SockCanScan_8cpp" startline="897" endline="958">createBus</referencedby>
        <referencedby refid="classCSockCanScan_1a7be2c075520b1cbf4baa4eb7d728fd2d" compoundref="SockCanScan_8cpp" startline="1057" endline="1078">stopBus</referencedby>
      </memberdef>
      <memberdef kind="variable" id="classCSockCanScan_1a1810bdcb6beda833752d4ddb83efde7f" prot="private" static="no" mutable="no">
        <type>std::string</type>
        <definition>std::string CSockCanScan::m_channelName</definition>
        <argsstring></argsstring>
        <name>m_channelName</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CanInterfaceImplementations/sockcan/SockCanScan.h" line="124" column="13" bodyfile="CanInterfaceImplementations/sockcan/SockCanScan.h" bodystart="124" bodyend="-1"/>
        <referencedby refid="classCSockCanScan_1a8bb8fcdb24b2b917258d027e6a468bae" compoundref="SockCanScan_8cpp" startline="494" endline="529">configureCanBoard</referencedby>
        <referencedby refid="classCSockCanScan_1a203a51239f8efc013d4b9df36f271317" compoundref="SockCanScan_8cpp" startline="535" endline="611">openCanPort</referencedby>
        <referencedby refid="classCSockCanScan_1aaed83a57ee1b70fff48a1a5ca9655fe6" compoundref="SockCanScan_8cpp" startline="633" endline="674">updateBusStatus</referencedby>
      </memberdef>
      <memberdef kind="variable" id="classCSockCanScan_1a47b82a55c47a74e0918378baf82dd45a" prot="private" static="no" mutable="no">
        <type>std::string</type>
        <definition>std::string CSockCanScan::m_busName</definition>
        <argsstring></argsstring>
        <name>m_busName</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CanInterfaceImplementations/sockcan/SockCanScan.h" line="125" column="13" bodyfile="CanInterfaceImplementations/sockcan/SockCanScan.h" bodystart="125" bodyend="-1"/>
        <referencedby refid="classCSockCanScan_1a879da2908384a8f154120bdd0c60c5aa" compoundref="SockCanScan_8cpp" startline="897" endline="958">createBus</referencedby>
        <referencedby refid="classCSockCanScan_1a7be2c075520b1cbf4baa4eb7d728fd2d" compoundref="SockCanScan_8cpp" startline="1057" endline="1078">stopBus</referencedby>
      </memberdef>
      <memberdef kind="variable" id="classCSockCanScan_1aa3406fed8265f9b21ae0b5de89bc3ce2" prot="private" static="no" mutable="no">
        <type>Log::LogComponentHandle</type>
        <definition>Log::LogComponentHandle CSockCanScan::m_logItHandleSock</definition>
        <argsstring></argsstring>
        <name>m_logItHandleSock</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CanInterfaceImplementations/sockcan/SockCanScan.h" line="126" column="25" bodyfile="CanInterfaceImplementations/sockcan/SockCanScan.h" bodystart="126" bodyend="-1"/>
        <referencedby refid="classCSockCanScan_1a8bb8fcdb24b2b917258d027e6a468bae" compoundref="SockCanScan_8cpp" startline="494" endline="529">configureCanBoard</referencedby>
        <referencedby refid="classCSockCanScan_1a879da2908384a8f154120bdd0c60c5aa" compoundref="SockCanScan_8cpp" startline="897" endline="958">createBus</referencedby>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classCSockCanScan_1abfb8f5e3726f9675a63f48648afae178" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>CSockCanScan::CSockCanScan</definition>
        <argsstring>()</argsstring>
        <name>CSockCanScan</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CanInterfaceImplementations/sockcan/SockCanScan.h" line="50" column="1" bodyfile="CanInterfaceImplementations/sockcan/SockCanScan.cpp" bodystart="67" bodyend="78"/>
        <references refid="classCanModule_1_1CanStatistics_1a85e6c87ce5285884a0272088178bb8f6" compoundref="CanStatistics_8cpp" startline="44" endline="51">CanModule::CanStatistics::beginNewRun</references>
        <references refid="classCanModule_1_1CCanAccess_1a921748fa6f0da92c7afef60f41007a3e" compoundref="CCanAccess_8h" startline="521">CanModule::CCanAccess::m_failedSendCountdown</references>
        <references refid="classCanModule_1_1CCanAccess_1a7853071979a549dc701dc06124bf1366" compoundref="CCanAccess_8h" startline="522">CanModule::CCanAccess::m_maxFailedSendCount</references>
        <references refid="classCSockCanScan_1afe0c7cc23de0ac2d758a07bec4c2e2c8" compoundref="SockCanScan_8h" startline="122">m_statistics</references>
        <references refid="classCanModule_1_1CanStatistics_1af3f15dedf80e67f1309946632d87198d" compoundref="CanStatistics_8h" startline="107" endline="113">CanModule::CanStatistics::setTimeSinceOpened</references>
      </memberdef>
      <memberdef kind="function" id="classCSockCanScan_1a7442798d8f943f85ca710f6f829c9efd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>CSockCanScan::CSockCanScan</definition>
        <argsstring>(CSockCanScan const &amp;other)=delete</argsstring>
        <name>CSockCanScan</name>
        <param>
          <type><ref refid="classCSockCanScan" kindref="compound">CSockCanScan</ref> const &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CanInterfaceImplementations/sockcan/SockCanScan.h" line="51" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCSockCanScan_1afb0a16ec4e702d79d5fe5dfcabfefbdb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCSockCanScan" kindref="compound">CSockCanScan</ref> &amp;</type>
        <definition>CSockCanScan&amp; CSockCanScan::operator=</definition>
        <argsstring>(CSockCanScan const &amp;other)=delete</argsstring>
        <name>operator=</name>
        <param>
          <type><ref refid="classCSockCanScan" kindref="compound">CSockCanScan</ref> const &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CanInterfaceImplementations/sockcan/SockCanScan.h" line="52" column="14"/>
      </memberdef>
      <memberdef kind="function" id="classCSockCanScan_1a243f91e993fcc96ddd5308c1425a130c" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type></type>
        <definition>CSockCanScan::~CSockCanScan</definition>
        <argsstring>()</argsstring>
        <name>~CSockCanScan</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CanInterfaceImplementations/sockcan/SockCanScan.h" line="53" column="9" bodyfile="CanInterfaceImplementations/sockcan/SockCanScan.cpp" bodystart="488" bodyend="492"/>
        <references refid="SockCanScan_8cpp_1a9dfd6d593fee1bb51ed35186b0bbb328" compoundref="SockCanScan_8cpp" startline="55">MLOGSOCK</references>
        <references refid="classCSockCanScan_1a7be2c075520b1cbf4baa4eb7d728fd2d" compoundref="SockCanScan_8cpp" startline="1057" endline="1078">stopBus</references>
      </memberdef>
      <memberdef kind="function" id="classCSockCanScan_1a4999204ff7166ee992a89b30a118af06" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool CSockCanScan::sendRemoteRequest</definition>
        <argsstring>(short cobID)</argsstring>
        <name>sendRemoteRequest</name>
        <reimplements refid="classCanModule_1_1CCanAccess_1acfefbc9be2696b1388cf6df2bba00aa1">sendRemoteRequest</reimplements>
        <param>
          <type>short</type>
          <declname>cobID</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Method that sends a remote request trough the can bus channel. If the method createBUS was not called before this, sendMessage will fail, as there is no can bus channel to send the request trough. Similar to sendMessage, but it sends an special message reserved for requests. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>cobID</parametername>
</parameternamelist>
<parameterdescription>
<para>Identifier that will be used for the request. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>: Was the initialisation process successful?</para>
</simplesect>
that is not tested or used until now, and I am not sure it works </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CanInterfaceImplementations/sockcan/SockCanScan.h" line="55" column="14" bodyfile="CanInterfaceImplementations/sockcan/SockCanScan.cpp" bodystart="831" bodyend="870"/>
        <references refid="namespaceCanModule_1a6cae4be8d395b496f5f602a5f9714ae1" compoundref="CanModuleUtils_8cpp" startline="32" endline="42">CanModule::CanModuleerrnoToString</references>
        <references refid="classCSockCanScan_1aff132a17957a6e0c93ee76be0c2cdc88" compoundref="SockCanScan_8h" startline="118">m_sock</references>
        <references refid="classCSockCanScan_1afe0c7cc23de0ac2d758a07bec4c2e2c8" compoundref="SockCanScan_8h" startline="122">m_statistics</references>
        <references refid="SockCanScan_8cpp_1a9dfd6d593fee1bb51ed35186b0bbb328" compoundref="SockCanScan_8cpp" startline="55">MLOGSOCK</references>
        <references refid="classCanModule_1_1CanStatistics_1a99de404f1b24cee80edfaad7ad1f9499" compoundref="CanStatistics_8h" startline="115" endline="121">CanModule::CanStatistics::setTimeSinceReceived</references>
      </memberdef>
      <memberdef kind="function" id="classCSockCanScan_1a879da2908384a8f154120bdd0c60c5aa" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>int</type>
        <definition>int CSockCanScan::createBus</definition>
        <argsstring>(const string name, string parameters)</argsstring>
        <name>createBus</name>
        <reimplements refid="classCanModule_1_1CCanAccess_1a0eeee5c3d48f1102012d1483cbe6e64b">createBus</reimplements>
        <param>
          <type>const string</type>
          <declname>name</declname>
        </param>
        <param>
          <type>string</type>
          <declname>parameters</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Method that initializes a can bus channel. The following methods called upon the same object will be using this initialized channel.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>= 2 parameters separated by &quot;:&quot;, like &quot;n0:n1&quot;<itemizedlist>
<listitem><para>n0 = &quot;sock&quot; for sockets linux, used by systec and peak</para>
</listitem><listitem><para>n1 = CAN port number on the module, can be prefixed with &quot;can&quot;</para>
</listitem><listitem><para>ex.: &quot;sock:can1&quot; speaks to port 1 on systec or peak module</para>
</listitem><listitem><para>ex.: &quot;sock:1&quot; works as well</para>
</listitem></itemizedlist>
</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>parameters</parametername>
</parameternamelist>
<parameterdescription>
<para>one parameter: &quot;p0&quot;, positive integer<itemizedlist>
<listitem><para>&quot;Unspecified&quot; (or empty): using defaults = &quot;125000&quot; // params missing</para>
</listitem><listitem><para>p0: bitrate: 50000, 100000, 125000, 250000, 500000, 1000000 bit/s, other values might be allowed by the module</para>
</listitem></itemizedlist>
</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<itemizedlist>
<listitem><para>i.e. &quot;250000&quot;</para>
</listitem></itemizedlist>
</para>
<para><simplesect kind="return"><para>Was the initialization process successful?</para>
</simplesect>
dont create a main thread for the same bus twice: if it exists already, just configure the board again this protects agains having multiple threads if a given port ports is opened several times: protects against erro/unusual runtime. If the connection is closed, it&apos;s main thread is stopped and joined, and the port is erased from the connection map. when the same port is opened again later on, a (new) main thread is created, and the connection is again added to the map. </para>
        </detaileddescription>
        <inbodydescription>
<para>start a reconnection thread</para>
        </inbodydescription>
        <location file="CanInterfaceImplementations/sockcan/SockCanScan.h" line="56" column="13" bodyfile="CanInterfaceImplementations/sockcan/SockCanScan.cpp" bodystart="897" bodyend="958"/>
        <references refid="classCSockCanScan_1a808488b6793afea6cc8466c3a12a088c" compoundref="SockCanScan_8cpp" startline="369" endline="486">CanReconnectionThread</references>
        <references refid="classCSockCanScan_1a2a97f7fca98e6d599bdb42da64796ad8" compoundref="SockCanScan_8cpp" startline="103" endline="354">CanScanControlThread</references>
        <references refid="classCSockCanScan_1a8bb8fcdb24b2b917258d027e6a468bae" compoundref="SockCanScan_8cpp" startline="494" endline="529">configureCanBoard</references>
        <references refid="namespaceCanModule_1a78730a18f59663871883885f3914a2aa" compoundref="CCanAccess_8h" startline="59">CanModule::LogItComponentName</references>
        <references refid="classCSockCanScan_1a596ffa46b85d51c580757cab52baead9" compoundref="SockCanScan_8h" startline="98">m_busMap</references>
        <references refid="classCSockCanScan_1a47b82a55c47a74e0918378baf82dd45a" compoundref="SockCanScan_8h" startline="125">m_busName</references>
        <references refid="classCSockCanScan_1aab77a9dc136d4c01ce31021929412ddb" compoundref="SockCanScan_8h" startline="116">m_CanScanThreadRunEnableFlag</references>
        <references refid="classCanModule_1_1CCanAccess_1a41af60558bdb3b738f39560755864333" compoundref="CCanAccess_8h" startline="523">CanModule::CCanAccess::m_hCanReconnectionThread</references>
        <references refid="classCSockCanScan_1a344d3a2b2d61a0adbc364e980af7c740" compoundref="SockCanScan_8h" startline="123">m_hCanScanThread</references>
        <references refid="classCSockCanScan_1aa3406fed8265f9b21ae0b5de89bc3ce2" compoundref="SockCanScan_8h" startline="126">m_logItHandleSock</references>
        <references refid="classCSockCanScan_1aff132a17957a6e0c93ee76be0c2cdc88" compoundref="SockCanScan_8h" startline="118">m_sock</references>
        <references refid="SockCanScan_8cpp_1a9dfd6d593fee1bb51ed35186b0bbb328" compoundref="SockCanScan_8cpp" startline="55">MLOGSOCK</references>
        <references refid="SockCanScan_8cpp_1aa80325536abdfd912084dd4f35e83adb" compoundref="SockCanScan_8cpp" startline="53">sockReconnectMutex</references>
      </memberdef>
      <memberdef kind="function" id="classCSockCanScan_1a485ec8621a98cdacad8e27433e09d919" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool CSockCanScan::sendMessage</definition>
        <argsstring>(short cobID, unsigned char len, unsigned char *message, bool rtr=false)</argsstring>
        <name>sendMessage</name>
        <reimplements refid="classCanModule_1_1CCanAccess_1aee42ab7fb9e50c02a1812202f7863d8c">sendMessage</reimplements>
        <param>
          <type>short</type>
          <declname>cobID</declname>
        </param>
        <param>
          <type>unsigned char</type>
          <declname>len</declname>
        </param>
        <param>
          <type>unsigned char *</type>
          <declname>message</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>rtr</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Method that sends a message trough the can bus channel. If the method createBUS was not called before this, sendMessage will fail, as there is no can bus channel to send a message through.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>cobID</parametername>
</parameternamelist>
<parameterdescription>
<para>Identifier that will be used for the message. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>len</parametername>
</parameternamelist>
<parameterdescription>
<para>Length of the message. If the message is bigger than 8 characters, it will be split into separate 8 characters messages. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>message</parametername>
</parameternamelist>
<parameterdescription>
<para>Message to be sent trough the can bus. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rtr</parametername>
</parameternamelist>
<parameterdescription>
<para>is the message a remote transmission request? </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Was the initialisation process successful?</para>
</simplesect>
OPCUA-2604: sendMessage must be non blocking. The reconnection behavior therefore must be managed in a separate thread.</para>
<para>returns: true for success, otherwise false </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CanInterfaceImplementations/sockcan/SockCanScan.h" line="57" column="14" bodyfile="CanInterfaceImplementations/sockcan/SockCanScan.cpp" bodystart="691" bodyend="821"/>
        <references refid="classCSockCanScan_1ace6f7aa52fe582af6de098895fc91b83" compoundref="SockCanScan_8h" startline="89" endline="97">emptyCanFrame</references>
        <references refid="classCSockCanScan_1aab77a9dc136d4c01ce31021929412ddb" compoundref="SockCanScan_8h" startline="116">m_CanScanThreadRunEnableFlag</references>
        <references refid="classCSockCanScan_1aff132a17957a6e0c93ee76be0c2cdc88" compoundref="SockCanScan_8h" startline="118">m_sock</references>
        <references refid="SockCanScan_8cpp_1a9dfd6d593fee1bb51ed35186b0bbb328" compoundref="SockCanScan_8cpp" startline="55">MLOGSOCK</references>
      </memberdef>
      <memberdef kind="function" id="classCSockCanScan_1a38110f02c2d12fa9b620ba5ff438a960" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void CSockCanScan::getStatistics</definition>
        <argsstring>(CanStatistics &amp;result)</argsstring>
        <name>getStatistics</name>
        <reimplements refid="classCanModule_1_1CCanAccess_1ad3182c83b4c5d7e6aef982c36e731507">getStatistics</reimplements>
        <param>
          <type><ref refid="classCanModule_1_1CanStatistics" kindref="compound">CanStatistics</ref> &amp;</type>
          <declname>result</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CanInterfaceImplementations/sockcan/SockCanScan.h" line="58" column="14" bodyfile="CanInterfaceImplementations/sockcan/SockCanScan.cpp" bodystart="1080" bodyend="1087"/>
        <references refid="classCanModule_1_1CanStatistics_1a85e6c87ce5285884a0272088178bb8f6" compoundref="CanStatistics_8cpp" startline="44" endline="51">CanModule::CanStatistics::beginNewRun</references>
        <references refid="classCanModule_1_1CanStatistics_1a8ec66bd11141579779f143362b70640e" compoundref="CanStatistics_8cpp" startline="74" endline="91">CanModule::CanStatistics::computeDerived</references>
        <references refid="classCanModule_1_1CanStatistics_1a3e65a8d28a3eeed8b05cdb69e419c445" compoundref="CanStatistics_8cpp" startline="70" endline="72">CanModule::CanStatistics::encodeCanModuleStatus</references>
        <references refid="classCanModule_1_1CCanAccess_1a484a4f9dc352fe31b4baff0365095705" compoundref="CCanAccess_8h" startline="515">CanModule::CCanAccess::m_CanParameters</references>
        <references refid="structCanModule_1_1CanParameters_1a53ce17e16c2a818ffbc05904d9e56e11" compoundref="CCanAccess_8h" startline="126">CanModule::CanParameters::m_lBaudRate</references>
        <references refid="classCSockCanScan_1afe0c7cc23de0ac2d758a07bec4c2e2c8" compoundref="SockCanScan_8h" startline="122">m_statistics</references>
      </memberdef>
      <memberdef kind="function" id="classCSockCanScan_1ad1caa327a98bc30012d2c5010a98cb05" prot="public" static="no" const="no" explicit="no" inline="yes" virt="virtual">
        <type>uint32_t</type>
        <definition>virtual uint32_t CSockCanScan::getPortStatus</definition>
        <argsstring>()</argsstring>
        <name>getPortStatus</name>
        <reimplements refid="classCanModule_1_1CCanAccess_1a33fe530d070cf35d096e967d543186a4">getPortStatus</reimplements>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>return socketcan port status as-is, from can_netlink.h enum can_state { CAN_STATE_ERROR_ACTIVE = 0, RX/TX error count &lt; 96 CAN_STATE_ERROR_WARNING, RX/TX error count &lt; 128 CAN_STATE_ERROR_PASSIVE, RX/TX error count &lt; 256 CAN_STATE_BUS_OFF, RX/TX error count &gt;= 256 CAN_STATE_STOPPED, Device is stopped CAN_STATE_SLEEPING, Device is sleeping CAN_STATE_MAX }; </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CanInterfaceImplementations/sockcan/SockCanScan.h" line="73" column="18" bodyfile="CanInterfaceImplementations/sockcan/SockCanScan.h" bodystart="73" bodyend="77"/>
        <references refid="CCanAccess_8h_1a6d0995692dcb6d1be30395a18d7683ba" compoundref="CCanAccess_8h" startline="71">CANMODULE_STATUS_BP_SOCK</references>
        <references refid="classCanModule_1_1CanStatistics_1a98dfe419c521921afc6cf48e502f8e9d" compoundref="CanStatistics_8h" startline="140" endline="140">CanModule::CanStatistics::portStatus</references>
      </memberdef>
      <memberdef kind="function" id="classCSockCanScan_1ad3404f38a5681bae4c0bbb6054a8ebaf" prot="public" static="no" const="no" explicit="no" inline="yes" virt="virtual">
        <type>uint32_t</type>
        <definition>virtual uint32_t CSockCanScan::getPortBitrate</definition>
        <argsstring>()</argsstring>
        <name>getPortBitrate</name>
        <reimplements refid="classCanModule_1_1CCanAccess_1aa8cb67096349fefc6e03aeb33e45ef81">getPortBitrate</reimplements>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>returns the bitrate of that port [bits/sec] according to what <ref refid="namespaceCanModule" kindref="compound">CanModule</ref> buffers say. This is the setting used for setting up the hardware, after any default rules have been applied, but BEFORE any vendor specific encoding into obscure bitpatterns occurs. This happens at port opening and the bitrate can only be changed at that moment. So please call this method just after you have opened the port. But also since there is no hw interaction and it just returns a buffer, you may call it as often as you like. Default bitrate is always 125000bits/s if &quot;Unspecified&quot; </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CanInterfaceImplementations/sockcan/SockCanScan.h" line="79" column="18" bodyfile="CanInterfaceImplementations/sockcan/SockCanScan.h" bodystart="79" bodyend="79"/>
      </memberdef>
      <memberdef kind="function" id="classCSockCanScan_1a5120fe6852dd4942e89fc23c3e09b20d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int CSockCanScan::getHandler</definition>
        <argsstring>()</argsstring>
        <name>getHandler</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns socket handler </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CanInterfaceImplementations/sockcan/SockCanScan.h" line="84" column="5" bodyfile="CanInterfaceImplementations/sockcan/SockCanScan.h" bodystart="84" bodyend="84"/>
      </memberdef>
      <memberdef kind="function" id="classCSockCanScan_1a81829633cb836d4a229b4267be2768d2" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>Log::LogComponentHandle</type>
        <definition>Log::LogComponentHandle CSockCanScan::logItHandle</definition>
        <argsstring>()</argsstring>
        <name>logItHandle</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CanInterfaceImplementations/sockcan/SockCanScan.h" line="99" column="25" bodyfile="CanInterfaceImplementations/sockcan/SockCanScan.h" bodystart="99" bodyend="99"/>
      </memberdef>
      <memberdef kind="function" id="classCSockCanScan_1ab806e1738ba9778c038150f51968839d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="virtual">
        <type>void</type>
        <definition>virtual void CSockCanScan::setReconnectBehavior</definition>
        <argsstring>(CanModule::ReconnectAutoCondition cond, CanModule::ReconnectAction action)</argsstring>
        <name>setReconnectBehavior</name>
        <reimplements refid="classCanModule_1_1CCanAccess_1ae1088edaf5444ff42ee094ae46240cc5">setReconnectBehavior</reimplements>
        <param>
          <type><ref refid="namespaceCanModule_1a2f4fee79cc7ba53467c2538fe6b9adbb" kindref="member">CanModule::ReconnectAutoCondition</ref></type>
          <declname>cond</declname>
        </param>
        <param>
          <type><ref refid="namespaceCanModule_1a2062089fa4fa87c8354295f2a8fe31a5" kindref="member">CanModule::ReconnectAction</ref></type>
          <declname>action</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>configuring the reconnection behavior: a condition triggers an action. The implementation is implementation-specific because not all vendor APIs permit the same behavior: not all combinations are available for all vendors/implementations. The implemented reconnection behavior is standardized nevertheless: &quot;you get what you see&quot;. Foe each CanBus you have to choose one condition and one action. Condition detection and action execution are then automatic inside <ref refid="namespaceCanModule" kindref="compound">CanModule</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername><ref refid="namespaceCanModule_1a2f4fee79cc7ba53467c2538fe6b9adbb" kindref="member">CanModule::ReconnectAutoCondition</ref></parametername>
</parameternamelist>
<parameterdescription>
<para>cond<itemizedlist>
<listitem><para>sendFail (default): a reconnection is triggered automatically if a send on the canBus fails. The number of failed sends can be set (default is 10). The failed sending must be strictly consecutive, if there is a succeeded sending, the internal counting restarts.</para>
</listitem><listitem><para>timeoutOnReception: the last time of a successful reception on a given channel can be monitored. If the last reception is older than 120 sec a reset is triggered automatically. This last successful reception time is calculated each time a send is invoked. The timeout is specified in seconds, default is 120sec.</para>
</listitem><listitem><para>never: this condition is always false and therefore no automatic reconnection action will be triggered. You can still call the explicit method reconnect( &lt;action&gt; ) but it is up to the client (server) to decide when.</para>
</listitem></itemizedlist>
</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername><ref refid="namespaceCanModule_1a2062089fa4fa87c8354295f2a8fe31a5" kindref="member">CanModule::ReconnectAction</ref></parametername>
</parameternamelist>
<parameterdescription>
<para>action<itemizedlist>
<listitem><para>singleBus (default): a single connection (canbus, channel) is reset and reception handler is reconnected.</para>
</listitem><listitem><para>wholeBridge if available, the whole bridge is reset, affecting all physical channels on that bridge. Only available for anagate. If a bridge is shared between multiple tasks, all channels across tasks are reset, affecting all tasks connected to that bridge. Evidently, a given channel must only be used by at most one task. </para>
</listitem></itemizedlist>
</para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CanInterfaceImplementations/sockcan/SockCanScan.h" line="101" column="14" bodyfile="CanInterfaceImplementations/sockcan/SockCanScan.h" bodystart="101" bodyend="104"/>
      </memberdef>
      <memberdef kind="function" id="classCSockCanScan_1afad122d886579de793f2b7b49e5c6d5f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="virtual">
        <type>void</type>
        <definition>virtual void CSockCanScan::setReconnectReceptionTimeout</definition>
        <argsstring>(unsigned int timeout)</argsstring>
        <name>setReconnectReceptionTimeout</name>
        <reimplements refid="classCanModule_1_1CCanAccess_1a3c902569c0712d165fc7e385e683dc95">setReconnectReceptionTimeout</reimplements>
        <param>
          <type>unsigned int</type>
          <declname>timeout</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>set the timout interval for message reception, for the reconnection behaviour. Units is seconds, default is 120. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CanInterfaceImplementations/sockcan/SockCanScan.h" line="105" column="14" bodyfile="CanInterfaceImplementations/sockcan/SockCanScan.h" bodystart="105" bodyend="105"/>
      </memberdef>
      <memberdef kind="function" id="classCSockCanScan_1aceab51e91b2c698211e5d563e4449c91" prot="public" static="no" const="no" explicit="no" inline="yes" virt="virtual">
        <type>void</type>
        <definition>virtual void CSockCanScan::setReconnectFailedSendCount</definition>
        <argsstring>(unsigned int c)</argsstring>
        <name>setReconnectFailedSendCount</name>
        <reimplements refid="classCanModule_1_1CCanAccess_1a665620fe5924cf87db0589a353d3d148">setReconnectFailedSendCount</reimplements>
        <param>
          <type>unsigned int</type>
          <declname>c</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>set the counter for failed consecutive sending attempts, for reconnection. default is 10. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CanInterfaceImplementations/sockcan/SockCanScan.h" line="106" column="14" bodyfile="CanInterfaceImplementations/sockcan/SockCanScan.h" bodystart="106" bodyend="109"/>
      </memberdef>
      <memberdef kind="function" id="classCSockCanScan_1aa8cb4c89fe3a13bb787c4085f1e994e3" prot="public" static="no" const="no" explicit="no" inline="yes" virt="virtual">
        <type><ref refid="namespaceCanModule_1a2f4fee79cc7ba53467c2538fe6b9adbb" kindref="member">CanModule::ReconnectAutoCondition</ref></type>
        <definition>virtual CanModule::ReconnectAutoCondition CSockCanScan::getReconnectCondition</definition>
        <argsstring>()</argsstring>
        <name>getReconnectCondition</name>
        <reimplements refid="classCanModule_1_1CCanAccess_1a003566cbcdf4ce8195853bd8049a8800">getReconnectCondition</reimplements>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>read back the r.condition </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CanInterfaceImplementations/sockcan/SockCanScan.h" line="110" column="43" bodyfile="CanInterfaceImplementations/sockcan/SockCanScan.h" bodystart="110" bodyend="110"/>
        <referencedby refid="classCSockCanScan_1a808488b6793afea6cc8466c3a12a088c" compoundref="SockCanScan_8cpp" startline="369" endline="486">CanReconnectionThread</referencedby>
      </memberdef>
      <memberdef kind="function" id="classCSockCanScan_1a03594b2fff9c61f37a5f68df2cfec05c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="virtual">
        <type><ref refid="namespaceCanModule_1a2062089fa4fa87c8354295f2a8fe31a5" kindref="member">CanModule::ReconnectAction</ref></type>
        <definition>virtual CanModule::ReconnectAction CSockCanScan::getReconnectAction</definition>
        <argsstring>()</argsstring>
        <name>getReconnectAction</name>
        <reimplements refid="classCanModule_1_1CCanAccess_1aaf2312ff9074ce7a4ec2e7d0a5b6fa16">getReconnectAction</reimplements>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>read back the r.action </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CanInterfaceImplementations/sockcan/SockCanScan.h" line="111" column="36" bodyfile="CanInterfaceImplementations/sockcan/SockCanScan.h" bodystart="111" bodyend="111"/>
        <referencedby refid="classCSockCanScan_1a808488b6793afea6cc8466c3a12a088c" compoundref="SockCanScan_8cpp" startline="369" endline="486">CanReconnectionThread</referencedby>
      </memberdef>
      <memberdef kind="function" id="classCSockCanScan_1a7be2c075520b1cbf4baa4eb7d728fd2d" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void CSockCanScan::stopBus</definition>
        <argsstring>()</argsstring>
        <name>stopBus</name>
        <reimplements refid="classCanModule_1_1CCanAccess_1a3fabe88b8e21638afd5d9886bb9c4aeb">stopBus</reimplements>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>notify the main thread to finish and delete the bus from the map of connections </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CanInterfaceImplementations/sockcan/SockCanScan.h" line="113" column="14" bodyfile="CanInterfaceImplementations/sockcan/SockCanScan.cpp" bodystart="1057" bodyend="1078"/>
        <references refid="classCSockCanScan_1a596ffa46b85d51c580757cab52baead9" compoundref="SockCanScan_8h" startline="98">m_busMap</references>
        <references refid="classCSockCanScan_1a47b82a55c47a74e0918378baf82dd45a" compoundref="SockCanScan_8h" startline="125">m_busName</references>
        <references refid="classCSockCanScan_1aab77a9dc136d4c01ce31021929412ddb" compoundref="SockCanScan_8h" startline="116">m_CanScanThreadRunEnableFlag</references>
        <references refid="classCSockCanScan_1a344d3a2b2d61a0adbc364e980af7c740" compoundref="SockCanScan_8h" startline="123">m_hCanScanThread</references>
        <references refid="SockCanScan_8cpp_1a9dfd6d593fee1bb51ed35186b0bbb328" compoundref="SockCanScan_8cpp" startline="55">MLOGSOCK</references>
        <references refid="SockCanScan_8cpp_1aa80325536abdfd912084dd4f35e83adb" compoundref="SockCanScan_8cpp" startline="53">sockReconnectMutex</references>
        <referencedby refid="classCSockCanScan_1a243f91e993fcc96ddd5308c1425a130c" compoundref="SockCanScan_8cpp" startline="488" endline="492">~CSockCanScan</referencedby>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-static-func">
      <memberdef kind="function" id="classCSockCanScan_1ace6f7aa52fe582af6de098895fc91b83" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>can_frame</type>
        <definition>static can_frame CSockCanScan::emptyCanFrame</definition>
        <argsstring>(void)</argsstring>
        <name>emptyCanFrame</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>produce and empty can frame </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CanInterfaceImplementations/sockcan/SockCanScan.h" line="89" column="18" bodyfile="CanInterfaceImplementations/sockcan/SockCanScan.h" bodystart="89" bodyend="97"/>
        <referencedby refid="classCSockCanScan_1a485ec8621a98cdacad8e27433e09d919" compoundref="SockCanScan_8cpp" startline="691" endline="821">sendMessage</referencedby>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-func">
      <memberdef kind="function" id="classCSockCanScan_1a623057580187ecb241adf143c64d711c" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void CSockCanScan::updateInitialError</definition>
        <argsstring>()</argsstring>
        <name>updateInitialError</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>stop the supervisor thread using the flag and close the socket. Report an error when opening a can port </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CanInterfaceImplementations/sockcan/SockCanScan.h" line="136" column="6" bodyfile="CanInterfaceImplementations/sockcan/SockCanScan.cpp" bodystart="1089" bodyend="1098"/>
        <references refid="classCanModule_1_1CCanAccess_1a33fbd693f04b4f4e21cee20856c44866" compoundref="CCanAccess_8h" startline="330">CanModule::CCanAccess::canMessageError</references>
        <references refid="classCSockCanScan_1a4b5f7591bfd27b8770bfb9ac9e406f66" compoundref="SockCanScan_8cpp" startline="1037" endline="1044">clearErrorMessage</references>
        <references refid="classCSockCanScan_1a01a0096926dc8236ae11077deb5e02a2" compoundref="SockCanScan_8h" startline="120">m_errorCode</references>
        <referencedby refid="classCSockCanScan_1a203a51239f8efc013d4b9df36f271317" compoundref="SockCanScan_8cpp" startline="535" endline="611">openCanPort</referencedby>
      </memberdef>
      <memberdef kind="function" id="classCSockCanScan_1a512733f202345e5940460f84539c979a" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void CSockCanScan::sendErrorMessage</definition>
        <argsstring>(const char *)</argsstring>
        <name>sendErrorMessage</name>
        <param>
          <type>const char *</type>
          <defname>mess</defname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CanInterfaceImplementations/sockcan/SockCanScan.h" line="143" column="6" bodyfile="CanInterfaceImplementations/sockcan/SockCanScan.cpp" bodystart="1046" bodyend="1052"/>
        <references refid="classCanModule_1_1CCanAccess_1a33fbd693f04b4f4e21cee20856c44866" compoundref="CCanAccess_8h" startline="330">CanModule::CCanAccess::canMessageError</references>
        <references refid="classCSockCanScan_1aff132a17957a6e0c93ee76be0c2cdc88" compoundref="SockCanScan_8h" startline="118">m_sock</references>
        <references refid="SockCanScan_8cpp_1a9dfd6d593fee1bb51ed35186b0bbb328" compoundref="SockCanScan_8cpp" startline="55">MLOGSOCK</references>
      </memberdef>
      <memberdef kind="function" id="classCSockCanScan_1a4b5f7591bfd27b8770bfb9ac9e406f66" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void CSockCanScan::clearErrorMessage</definition>
        <argsstring>()</argsstring>
        <name>clearErrorMessage</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CanInterfaceImplementations/sockcan/SockCanScan.h" line="144" column="6" bodyfile="CanInterfaceImplementations/sockcan/SockCanScan.cpp" bodystart="1037" bodyend="1044"/>
        <references refid="classCanModule_1_1CCanAccess_1a33fbd693f04b4f4e21cee20856c44866" compoundref="CCanAccess_8h" startline="330">CanModule::CCanAccess::canMessageError</references>
        <references refid="classCSockCanScan_1aff132a17957a6e0c93ee76be0c2cdc88" compoundref="SockCanScan_8h" startline="118">m_sock</references>
        <references refid="SockCanScan_8cpp_1a9dfd6d593fee1bb51ed35186b0bbb328" compoundref="SockCanScan_8cpp" startline="55">MLOGSOCK</references>
        <referencedby refid="classCSockCanScan_1a623057580187ecb241adf143c64d711c" compoundref="SockCanScan_8cpp" startline="1089" endline="1098">updateInitialError</referencedby>
      </memberdef>
      <memberdef kind="function" id="classCSockCanScan_1a8bb8fcdb24b2b917258d027e6a468bae" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int CSockCanScan::configureCanBoard</definition>
        <argsstring>(const string name, const string parameters)</argsstring>
        <name>configureCanBoard</name>
        <param>
          <type>const string</type>
          <declname>name</declname>
        </param>
        <param>
          <type>const string</type>
          <declname>parameters</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
<para>for PEAK bridges, we have a problem: the local ports are not mapped to the global socketcan ports in a deterministic way. OPCUA-1735. So, lets make a udev call here, analyze the result and manipulate the port number so that it becomes a global port number.</para>
<para>In order to distinguish between systec (where it works) and peak bridges we use an extended name: systec: name=&quot;sock:can0&quot; peak: name=&quot;sock:can0:device17440&quot;</para>
<para>now, we manipulate the lname to reflect the absolute port which we found out. We do the rewiring at initialisation, like this we don&apos;t care anymore during runtime.</para>
        </inbodydescription>
        <location file="CanInterfaceImplementations/sockcan/SockCanScan.h" line="145" column="5" bodyfile="CanInterfaceImplementations/sockcan/SockCanScan.cpp" bodystart="494" bodyend="529"/>
        <references refid="classCSockCanScan_1a1810bdcb6beda833752d4ddb83efde7f" compoundref="SockCanScan_8h" startline="124">m_channelName</references>
        <references refid="classCSockCanScan_1aa3406fed8265f9b21ae0b5de89bc3ce2" compoundref="SockCanScan_8h" startline="126">m_logItHandleSock</references>
        <references refid="SockCanScan_8cpp_1a9dfd6d593fee1bb51ed35186b0bbb328" compoundref="SockCanScan_8cpp" startline="55">MLOGSOCK</references>
        <references refid="classCSockCanScan_1a203a51239f8efc013d4b9df36f271317" compoundref="SockCanScan_8cpp" startline="535" endline="611">openCanPort</references>
        <references refid="classCanModule_1_1CCanAccess_1af26c9d102638fb96e5e1305f807d148f" compoundref="CCanAccess_8h" startline="365" endline="427">CanModule::CCanAccess::parseNameAndParameters</references>
        <references refid="classudevanalyserforpeak__ns_1_1UdevAnalyserForPeak_1a7edf6a8b32f9728aacf570a7704e560f" compoundref="UdevAnalyserForPeak_8cpp" startline="67" endline="116">udevanalyserforpeak_ns::UdevAnalyserForPeak::peakExtendedIdentifierToSocketCanDevice</references>
        <references refid="classudevanalyserforpeak__ns_1_1UdevAnalyserForPeak_1a982db3210deb3a9483508f473af4262c" compoundref="UdevAnalyserForPeak_8cpp" startline="118" endline="129">udevanalyserforpeak_ns::UdevAnalyserForPeak::showMap</references>
        <referencedby refid="classCSockCanScan_1a879da2908384a8f154120bdd0c60c5aa" compoundref="SockCanScan_8cpp" startline="897" endline="958">createBus</referencedby>
      </memberdef>
      <memberdef kind="function" id="classCSockCanScan_1aaed83a57ee1b70fff48a1a5ca9655fe6" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void CSockCanScan::updateBusStatus</definition>
        <argsstring>()</argsstring>
        <name>updateBusStatus</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>update the CAN bus status IFLA from socketcan and make up a <ref refid="namespaceCanModule" kindref="compound">CanModule</ref> status bitpattern out from this. Each vendor has to implement this with the same bit meanings.</para>
<para>Errors are a subset of status.</para>
<para>std::string <ref refid="classCSockCanScan_1a177453d85f24c6b12b84468ac812cf5c" kindref="member">CSockCanScan::errorFrameToString(const struct can_frame &amp;canFrame)</ref> fabricates a string, we need a bitpattern</para>
<para>int can_get_restart_ms(const char *name, __u32 *restart_ms); int can_get_bittiming(const char *name, struct can_bittiming *bt); int can_get_ctrlmode(const char *name, struct can_ctrlmode *cm); int can_get_state(const char *name, int *state); int can_get_clock(const char *name, struct can_clock *clock); int can_get_bittiming_const(const char *name, struct can_bittiming_const *btc); int can_get_berr_counter(const char *name, struct can_berr_counter *bc); int can_get_device_stats(const char *name, struct can_device_stats *cds); </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CanInterfaceImplementations/sockcan/SockCanScan.h" line="146" column="6" bodyfile="CanInterfaceImplementations/sockcan/SockCanScan.cpp" bodystart="633" bodyend="674"/>
        <references refid="classCSockCanScan_1a1810bdcb6beda833752d4ddb83efde7f" compoundref="SockCanScan_8h" startline="124">m_channelName</references>
        <references refid="classCSockCanScan_1afe0c7cc23de0ac2d758a07bec4c2e2c8" compoundref="SockCanScan_8h" startline="122">m_statistics</references>
        <references refid="classCanModule_1_1CanStatistics_1a2caa2a77674b36ce4bcf6d4e9423e36f" compoundref="CanStatistics_8h" startline="141" endline="141">CanModule::CanStatistics::setPortStatus</references>
      </memberdef>
      <memberdef kind="function" id="classCSockCanScan_1a203a51239f8efc013d4b9df36f271317" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int CSockCanScan::openCanPort</definition>
        <argsstring>()</argsstring>
        <name>openCanPort</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Obtains a SocketCAN socket and opens it. The name of the port and parameters should have been specified by preceding call to configureCanboard()</para>
<para><simplesect kind="return"><para>less than zero in case of error, otherwise success</para>
</simplesect>
stop, set bitrate, start a CAN port, open a socket for it, set the socket to CAN, bind it and check any errors </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CanInterfaceImplementations/sockcan/SockCanScan.h" line="153" column="5" bodyfile="CanInterfaceImplementations/sockcan/SockCanScan.cpp" bodystart="535" bodyend="611"/>
        <references refid="namespaceCanModule_1a6cae4be8d395b496f5f602a5f9714ae1" compoundref="CanModuleUtils_8cpp" startline="32" endline="42">CanModule::CanModuleerrnoToString</references>
        <references refid="classCanModule_1_1CCanAccess_1a484a4f9dc352fe31b4baff0365095705" compoundref="CCanAccess_8h" startline="515">CanModule::CCanAccess::m_CanParameters</references>
        <references refid="classCSockCanScan_1a1810bdcb6beda833752d4ddb83efde7f" compoundref="SockCanScan_8h" startline="124">m_channelName</references>
        <references refid="structCanModule_1_1CanParameters_1a8668831351aaaa0446c75c58073bf357" compoundref="CCanAccess_8h" startline="135">CanModule::CanParameters::m_dontReconfigure</references>
        <references refid="classCSockCanScan_1a01a0096926dc8236ae11077deb5e02a2" compoundref="SockCanScan_8h" startline="120">m_errorCode</references>
        <references refid="structCanModule_1_1CanParameters_1a53ce17e16c2a818ffbc05904d9e56e11" compoundref="CCanAccess_8h" startline="126">CanModule::CanParameters::m_lBaudRate</references>
        <references refid="classCSockCanScan_1aff132a17957a6e0c93ee76be0c2cdc88" compoundref="SockCanScan_8h" startline="118">m_sock</references>
        <references refid="classCSockCanScan_1afe0c7cc23de0ac2d758a07bec4c2e2c8" compoundref="SockCanScan_8h" startline="122">m_statistics</references>
        <references refid="CCanAccess_8h_1ad506d1f216984abc94d5a65f33053626" compoundref="CCanAccess_8h" startline="60">MLOG</references>
        <references refid="SockCanScan_8cpp_1a9dfd6d593fee1bb51ed35186b0bbb328" compoundref="SockCanScan_8cpp" startline="55">MLOGSOCK</references>
        <references refid="classCanModule_1_1CanStatistics_1af3f15dedf80e67f1309946632d87198d" compoundref="CanStatistics_8h" startline="107" endline="113">CanModule::CanStatistics::setTimeSinceOpened</references>
        <references refid="classCSockCanScan_1a623057580187ecb241adf143c64d711c" compoundref="SockCanScan_8cpp" startline="1089" endline="1098">updateInitialError</references>
        <referencedby refid="classCSockCanScan_1a808488b6793afea6cc8466c3a12a088c" compoundref="SockCanScan_8cpp" startline="369" endline="486">CanReconnectionThread</referencedby>
        <referencedby refid="classCSockCanScan_1a8bb8fcdb24b2b917258d027e6a468bae" compoundref="SockCanScan_8cpp" startline="494" endline="529">configureCanBoard</referencedby>
      </memberdef>
      <memberdef kind="function" id="classCSockCanScan_1a2a97f7fca98e6d599bdb42da64796ad8" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void CSockCanScan::CanScanControlThread</definition>
        <argsstring>()</argsstring>
        <name>CanScanControlThread</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The main control thread function for the CAN update scan manager: a private non-static method, which is called on the object (this) following std::thread C++11 ways.</para>
<para>reading from socket, and supervising thread for monitoring the sockets/CAN buses. It takes an object reference (cast) and listens with a select call on that socket/object. The select runs with 1Hz, and if there is nothing to receive it should timeout. </para>
        </detaileddescription>
        <inbodydescription>
<para>the select failed. that is very bad, system problem, but let&apos;s continue nevertheless. There is not much we can do</para>
<para>select returned, either on the timeout or with something on that socket/object. Assumption: at this moment sock holds meaningful value. Now select result &gt;=0 so it was either nothing received (timeout) or something received</para>
<para>The preceding call took either &apos;timeout&apos; time, or there is frame received <ndash/> perfect time to attempt to clean error frame.</para>
<para>select reports that it has got something, so no timeout in this case</para>
<para>try to re-open the socket. only reopen the socket if we still need it. If we need to shutdown the thread, leave it closed and terminate main loop.</para>
<para>if we have an open socket again, and we can read numberOfReadBytes &gt;=0 we should be fine again and continue the thread execution normally</para>
<para>we have a CAN message, error free, lets digest it</para>
<para>OPCUA-2607. Lets just stop filtering them out. This is only done here anyway, all other vendor implementations don&apos;t care.</para>
<para>reformat and buffer the message from the socket. this actually should exclude more bits</para>
<para>the select got nothing to read, this was just a timeout, all is fine. Unless the reconnect timeout has something to do.</para>
<para>the reconnect behavior happens in an extra thread so that the sendMessage becomes non blocking. This is the reception of the message part, and strictly speaking we could do the reconnection due to reception message timeout also here. For cleanliness, lets use that extra reconnection thread nevertheless here.</para>
<para>that reconnection thread is always up and it depends on three private variables: the socket, the ReconnectAutoCondition and the ReconnectAction. It is done in a pretty stupid way so that is is fast, for all vendors: you just trigger it whenever and it checks itself what to do.</para>
        </inbodydescription>
        <location file="CanInterfaceImplementations/sockcan/SockCanScan.h" line="160" column="6" bodyfile="CanInterfaceImplementations/sockcan/SockCanScan.cpp" bodystart="103" bodyend="354"/>
        <references refid="SockCanScan_8cpp_1a9dfd6d593fee1bb51ed35186b0bbb328" compoundref="SockCanScan_8cpp" startline="55">MLOGSOCK</references>
        <referencedby refid="classCSockCanScan_1a879da2908384a8f154120bdd0c60c5aa" compoundref="SockCanScan_8cpp" startline="897" endline="958">createBus</referencedby>
      </memberdef>
      <memberdef kind="function" id="classCSockCanScan_1a808488b6793afea6cc8466c3a12a088c" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void CSockCanScan::CanReconnectionThread</definition>
        <argsstring>()</argsstring>
        <name>CanReconnectionThread</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>reconnection behavior thread, always up</para>
<para>Reconnection thread managing the reconnection behavior, per port. The behavior settings can not change during runtime. This thread is initialized after the main thread is up, and then listens on its cond.var as a trigger. Triggers occur in two contexts: sending and receiving problems. If there is a sending problem which lasts for a while (usually) the reconnection thread will be also triggered for each failed sending: the thread will be &quot;hammered&quot; by triggers. ince the reconnection takes some time, many triggers will be lost. That is in fact a desired behavior.</para>
<para>The parameters are all atomics for increased thread-safety, even though the documentation about the predicate is unclear on that point. Since atomics just provide a &quot;sequential memory layout&quot; for the variables to prevent race conditions they are good to use for this but the code still has to be threadsafe and reentrant... ;-) Doesn&apos;t eat anything anyway on that small scale with scalars only.</para>
<para><ulink url="https://en.cppreference.com/w/cpp/thread/condition_variable/wait">https://en.cppreference.com/w/cpp/thread/condition_variable/wait</ulink> </para>
        </detaileddescription>
        <inbodydescription>
<para>lets check the timeoutOnReception reconnect condition. If it is true, all we can do is to close/open the socket again since the underlying hardware is hidden by socketcan abstraction. Like his we do not have to pollute the &quot;sendMessage&quot; like for anagate, and that is cleaner.</para>
<para>we get triggered all the time, essentially with reception timeouts, but also sometimes with a send fail. we need to manage the conditions since the triggering is identical, no parameters are transmitted, the predicate is just a boolean to keep it simple.</para>
<para>... or the reception timed out: we did not receive anything on the bus for a certain time (not: count). That is a somewhat dangerous condition but it can be extremely useful if you know what you do.</para>
<para>socketcan abstracts away the notion of a &quot;module&quot;, and that is the point. Various plugin-orders should lead to the same device mapping nevertheless. But then we can&apos;t refer to a module and reset all of it&apos;s channels easily in linux. Unless we make a big effort and keep track of which port is on which module, for peak: more udev calls, for systec: we need to read the module serial number or similar. Maybe there is an elegant way out, but I think it is not worth it. Use a PDU if you want to reset your systec16. For peak the notion of &quot;module&quot; is already difficult through socketcan (udev calls needed to identify the modules) and peak bridges get their power over USB. So in fact testing peak means &quot;rebooting&quot; unless you want to unplug the USB. Therefore &quot;allBusesOnBridge&quot; as reconnect action is not available for sock.</para>
<para><ref refid="namespaceCanModule_1a2062089fa4fa87c8354295f2a8fe31a5a319ee2c9d887d55f6bc1941518a5ae76" kindref="member">CanModule::ReconnectAction::allBusesOnBridge</ref> is not implemented for sock</para>
        </inbodydescription>
        <location file="CanInterfaceImplementations/sockcan/SockCanScan.h" line="165" column="6" bodyfile="CanInterfaceImplementations/sockcan/SockCanScan.cpp" bodystart="369" bodyend="486"/>
        <references refid="classCanModule_1_1CCanAccess_1ac3f5126ae36d642217425e21696d19ca" compoundref="CCanAccess_8h" startline="227" endline="227">CanModule::CCanAccess::getBusName</references>
        <references refid="classCSockCanScan_1a03594b2fff9c61f37a5f68df2cfec05c" compoundref="SockCanScan_8h" startline="111" endline="111">getReconnectAction</references>
        <references refid="classCSockCanScan_1aa8cb4c89fe3a13bb787c4085f1e994e3" compoundref="SockCanScan_8h" startline="110" endline="110">getReconnectCondition</references>
        <references refid="classCanModule_1_1CCanAccess_1a79c236a0e2b3e3b183b1c85aab3f5b71" compoundref="CCanAccess_8h" startline="555" endline="565">CanModule::CCanAccess::hasTimeoutOnReception</references>
        <references refid="classCanModule_1_1CCanAccess_1a921748fa6f0da92c7afef60f41007a3e" compoundref="CCanAccess_8h" startline="521">CanModule::CCanAccess::m_failedSendCountdown</references>
        <references refid="classCanModule_1_1CCanAccess_1a6baf24c56eb715adf55a569d08b12c25" compoundref="CCanAccess_8h" startline="519">CanModule::CCanAccess::m_reconnectAction</references>
        <references refid="classCanModule_1_1CCanAccess_1abfd40edc34a777a5ff4503a6e8a239d6" compoundref="CCanAccess_8h" startline="518">CanModule::CCanAccess::m_reconnectCondition</references>
        <references refid="classCSockCanScan_1aff132a17957a6e0c93ee76be0c2cdc88" compoundref="SockCanScan_8h" startline="118">m_sock</references>
        <references refid="SockCanScan_8cpp_1a9dfd6d593fee1bb51ed35186b0bbb328" compoundref="SockCanScan_8cpp" startline="55">MLOGSOCK</references>
        <references refid="namespaceCanModule_1a2f4fee79cc7ba53467c2538fe6b9adbbac7561db7a418dd39b2201dfe110ab4a4">CanModule::never</references>
        <references refid="classCSockCanScan_1a203a51239f8efc013d4b9df36f271317" compoundref="SockCanScan_8cpp" startline="535" endline="611">openCanPort</references>
        <references refid="classCanModule_1_1CCanAccess_1aa12f64e9e31bd491f39fc3169b1e5025" compoundref="CCanAccess_8h" startline="544" endline="550">CanModule::CCanAccess::reconnectActionString</references>
        <references refid="classCanModule_1_1CCanAccess_1a9da88ce122d5de04a0235a4682a13dc0" compoundref="CCanAccess_8h" startline="532" endline="539">CanModule::CCanAccess::reconnectConditionString</references>
        <references refid="classCanModule_1_1CCanAccess_1aad13b5ad34547cbe6cad4e8369557bed" compoundref="CCanAccess_8h" startline="447" endline="450">CanModule::CCanAccess::resetSendFailedCountdown</references>
        <references refid="classCanModule_1_1CCanAccess_1a067f50699c1ed4b6ee6732eb0078ed0a" compoundref="CCanAccess_8h" startline="570" endline="576">CanModule::CCanAccess::resetTimeoutOnReception</references>
        <references refid="namespaceCanModule_1a2f4fee79cc7ba53467c2538fe6b9adbbae323a25a871808f9a0df9a72ce954585">CanModule::sendFail</references>
        <references refid="namespaceCanModule_1a2062089fa4fa87c8354295f2a8fe31a5a5f768fefafa6db21eee26885afb6163d">CanModule::singleBus</references>
        <references refid="namespaceCanModule_1a2f4fee79cc7ba53467c2538fe6b9adbbaba350cf15e5a1471109f17351afb401a">CanModule::timeoutOnReception</references>
        <references refid="classCanModule_1_1CCanAccess_1ad8afab7f9acc769c53574edec695065b" compoundref="CCanAccess_8h" startline="437" endline="441">CanModule::CCanAccess::waitForReconnectionThreadTrigger</references>
        <referencedby refid="classCSockCanScan_1a879da2908384a8f154120bdd0c60c5aa" compoundref="SockCanScan_8cpp" startline="897" endline="958">createBus</referencedby>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-static-func">
      <memberdef kind="function" id="classCSockCanScan_1a177453d85f24c6b12b84468ac812cf5c" prot="private" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string CSockCanScan::errorFrameToString</definition>
        <argsstring>(const struct can_frame &amp;f)</argsstring>
        <name>errorFrameToString</name>
        <param>
          <type>const struct can_frame &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Transforms an error frame into an error message (string format) </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CanInterfaceImplementations/sockcan/SockCanScan.h" line="141" column="20" bodyfile="CanInterfaceImplementations/sockcan/SockCanScan.cpp" bodystart="963" bodyend="1035"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <inheritancegraph>
      <node id="1">
        <label>CSockCanScan</label>
        <link refid="classCSockCanScan"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
      </node>
      <node id="2">
        <label>CanModule::CCanAccess</label>
        <link refid="classCanModule_1_1CCanAccess"/>
      </node>
    </inheritancegraph>
    <collaborationgraph>
      <node id="3">
        <label>CanModule::CanParameters</label>
        <link refid="structCanModule_1_1CanParameters"/>
      </node>
      <node id="4">
        <label>CanModule::CanStatistics</label>
        <link refid="classCanModule_1_1CanStatistics"/>
        <childnode refid="5" relation="usage">
          <edgelabel>m_internals</edgelabel>
        </childnode>
      </node>
      <node id="1">
        <label>CSockCanScan</label>
        <link refid="classCSockCanScan"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
        <childnode refid="4" relation="usage">
          <edgelabel>m_statistics</edgelabel>
        </childnode>
      </node>
      <node id="5">
        <label>CanModule::CanStatistics::Internals</label>
        <link refid="classCanModule_1_1CanStatistics_1_1Internals"/>
      </node>
      <node id="2">
        <label>CanModule::CCanAccess</label>
        <link refid="classCanModule_1_1CCanAccess"/>
        <childnode refid="3" relation="usage">
          <edgelabel>m_CanParameters</edgelabel>
        </childnode>
      </node>
    </collaborationgraph>
    <location file="CanInterfaceImplementations/sockcan/SockCanScan.h" line="47" column="1" bodyfile="CanInterfaceImplementations/sockcan/SockCanScan.h" bodystart="46" bodyend="167"/>
    <listofallmembers>
      <member refid="classCanModule_1_1CCanAccess_1aa8e0e974863874b0e7bbcdb57084c241" prot="public" virt="non-virtual"><scope>CSockCanScan</scope><name>canMessageCame</name></member>
      <member refid="classCanModule_1_1CCanAccess_1a33fbd693f04b4f4e21cee20856c44866" prot="public" virt="non-virtual"><scope>CSockCanScan</scope><name>canMessageError</name></member>
      <member refid="classCSockCanScan_1a808488b6793afea6cc8466c3a12a088c" prot="private" virt="non-virtual"><scope>CSockCanScan</scope><name>CanReconnectionThread</name></member>
      <member refid="classCSockCanScan_1a2a97f7fca98e6d599bdb42da64796ad8" prot="private" virt="non-virtual"><scope>CSockCanScan</scope><name>CanScanControlThread</name></member>
      <member refid="classCanModule_1_1CCanAccess_1a7c9b87d205b0ec265c972a3303cecda2" prot="public" virt="non-virtual"><scope>CSockCanScan</scope><name>CCanAccess</name></member>
      <member refid="classCSockCanScan_1a4b5f7591bfd27b8770bfb9ac9e406f66" prot="private" virt="non-virtual"><scope>CSockCanScan</scope><name>clearErrorMessage</name></member>
      <member refid="classCSockCanScan_1a8bb8fcdb24b2b917258d027e6a468bae" prot="private" virt="non-virtual"><scope>CSockCanScan</scope><name>configureCanBoard</name></member>
      <member refid="classCSockCanScan_1a879da2908384a8f154120bdd0c60c5aa" prot="public" virt="virtual"><scope>CSockCanScan</scope><name>createBus</name></member>
      <member refid="classCSockCanScan_1abfb8f5e3726f9675a63f48648afae178" prot="public" virt="non-virtual"><scope>CSockCanScan</scope><name>CSockCanScan</name></member>
      <member refid="classCSockCanScan_1a7442798d8f943f85ca710f6f829c9efd" prot="public" virt="non-virtual"><scope>CSockCanScan</scope><name>CSockCanScan</name></member>
      <member refid="classCanModule_1_1CCanAccess_1a24494114ec0dc237b63fb321ba4d084e" prot="public" virt="non-virtual"><scope>CSockCanScan</scope><name>decreaseSendFailedCountdown</name></member>
      <member refid="classCSockCanScan_1ace6f7aa52fe582af6de098895fc91b83" prot="public" virt="non-virtual"><scope>CSockCanScan</scope><name>emptyCanFrame</name></member>
      <member refid="classCSockCanScan_1a177453d85f24c6b12b84468ac812cf5c" prot="private" virt="non-virtual"><scope>CSockCanScan</scope><name>errorFrameToString</name></member>
      <member refid="classCanModule_1_1CCanAccess_1ac3f5126ae36d642217425e21696d19ca" prot="public" virt="non-virtual"><scope>CSockCanScan</scope><name>getBusName</name></member>
      <member refid="classCSockCanScan_1a5120fe6852dd4942e89fc23c3e09b20d" prot="public" virt="non-virtual"><scope>CSockCanScan</scope><name>getHandler</name></member>
      <member refid="classCanModule_1_1CCanAccess_1a8210a8161f1987973584b6dda5dc6d7d" prot="public" virt="non-virtual"><scope>CSockCanScan</scope><name>getLogItInstance</name></member>
      <member refid="classCSockCanScan_1ad3404f38a5681bae4c0bbb6054a8ebaf" prot="public" virt="virtual"><scope>CSockCanScan</scope><name>getPortBitrate</name></member>
      <member refid="classCSockCanScan_1ad1caa327a98bc30012d2c5010a98cb05" prot="public" virt="virtual"><scope>CSockCanScan</scope><name>getPortStatus</name></member>
      <member refid="classCSockCanScan_1a03594b2fff9c61f37a5f68df2cfec05c" prot="public" virt="virtual"><scope>CSockCanScan</scope><name>getReconnectAction</name></member>
      <member refid="classCSockCanScan_1aa8cb4c89fe3a13bb787c4085f1e994e3" prot="public" virt="virtual"><scope>CSockCanScan</scope><name>getReconnectCondition</name></member>
      <member refid="classCSockCanScan_1a38110f02c2d12fa9b620ba5ff438a960" prot="public" virt="virtual"><scope>CSockCanScan</scope><name>getStatistics</name></member>
      <member refid="classCanModule_1_1CCanAccess_1a79c236a0e2b3e3b183b1c85aab3f5b71" prot="protected" virt="non-virtual"><scope>CSockCanScan</scope><name>hasTimeoutOnReception</name></member>
      <member refid="classCanModule_1_1CCanAccess_1ab5a430fc27073d92c69659bda261b74d" prot="public" virt="non-virtual"><scope>CSockCanScan</scope><name>initialiseLogging</name></member>
      <member refid="classCSockCanScan_1a81829633cb836d4a229b4267be2768d2" prot="public" virt="non-virtual"><scope>CSockCanScan</scope><name>logItHandle</name></member>
      <member refid="classCSockCanScan_1a596ffa46b85d51c580757cab52baead9" prot="public" virt="non-virtual"><scope>CSockCanScan</scope><name>m_busMap</name></member>
      <member refid="classCSockCanScan_1a47b82a55c47a74e0918378baf82dd45a" prot="private" virt="non-virtual"><scope>CSockCanScan</scope><name>m_busName</name></member>
      <member refid="classCanModule_1_1CCanAccess_1a484a4f9dc352fe31b4baff0365095705" prot="protected" virt="non-virtual"><scope>CSockCanScan</scope><name>m_CanParameters</name></member>
      <member refid="classCSockCanScan_1aab77a9dc136d4c01ce31021929412ddb" prot="private" virt="non-virtual"><scope>CSockCanScan</scope><name>m_CanScanThreadRunEnableFlag</name></member>
      <member refid="classCSockCanScan_1a1810bdcb6beda833752d4ddb83efde7f" prot="private" virt="non-virtual"><scope>CSockCanScan</scope><name>m_channelName</name></member>
      <member refid="classCanModule_1_1CCanAccess_1a6a9790a2842b40ced0ff98e1e171acbc" prot="private" virt="non-virtual"><scope>CSockCanScan</scope><name>m_dreceived</name></member>
      <member refid="classCSockCanScan_1a01a0096926dc8236ae11077deb5e02a2" prot="private" virt="non-virtual"><scope>CSockCanScan</scope><name>m_errorCode</name></member>
      <member refid="classCanModule_1_1CCanAccess_1a921748fa6f0da92c7afef60f41007a3e" prot="protected" virt="non-virtual"><scope>CSockCanScan</scope><name>m_failedSendCountdown</name></member>
      <member refid="classCanModule_1_1CCanAccess_1a41af60558bdb3b738f39560755864333" prot="protected" virt="non-virtual"><scope>CSockCanScan</scope><name>m_hCanReconnectionThread</name></member>
      <member refid="classCSockCanScan_1a344d3a2b2d61a0adbc364e980af7c740" prot="private" virt="non-virtual"><scope>CSockCanScan</scope><name>m_hCanScanThread</name></member>
      <member refid="classCanModule_1_1CCanAccess_1a782b2e9b52ebb49a14307e1f37440490" prot="private" virt="non-virtual"><scope>CSockCanScan</scope><name>m_lh</name></member>
      <member refid="classCSockCanScan_1aa3406fed8265f9b21ae0b5de89bc3ce2" prot="private" virt="non-virtual"><scope>CSockCanScan</scope><name>m_logItHandleSock</name></member>
      <member refid="classCanModule_1_1CCanAccess_1a2bb6325281679f955ab32fc18367a7b3" prot="private" virt="non-virtual"><scope>CSockCanScan</scope><name>m_logItRemoteInstance</name></member>
      <member refid="classCanModule_1_1CCanAccess_1a7853071979a549dc701dc06124bf1366" prot="protected" virt="non-virtual"><scope>CSockCanScan</scope><name>m_maxFailedSendCount</name></member>
      <member refid="classCanModule_1_1CCanAccess_1a6baf24c56eb715adf55a569d08b12c25" prot="protected" virt="non-virtual"><scope>CSockCanScan</scope><name>m_reconnectAction</name></member>
      <member refid="classCanModule_1_1CCanAccess_1abfd40edc34a777a5ff4503a6e8a239d6" prot="protected" virt="non-virtual"><scope>CSockCanScan</scope><name>m_reconnectCondition</name></member>
      <member refid="classCanModule_1_1CCanAccess_1a9edb8bed739db66c1a6a8b3489ce79a2" prot="protected" virt="non-virtual"><scope>CSockCanScan</scope><name>m_reconnection_cv</name></member>
      <member refid="classCanModule_1_1CCanAccess_1a08cc164e3baaf95fedeb50198a7fa799" prot="protected" virt="non-virtual"><scope>CSockCanScan</scope><name>m_reconnection_mtx</name></member>
      <member refid="classCanModule_1_1CCanAccess_1ab8dd2b137cebaa0764c406db6061bbc7" prot="protected" virt="non-virtual"><scope>CSockCanScan</scope><name>m_reconnectTrigger</name></member>
      <member refid="classCanModule_1_1CCanAccess_1a0eff18d10b7ee5d6f86b03898f38f7ca" prot="protected" virt="non-virtual"><scope>CSockCanScan</scope><name>m_sBusName</name></member>
      <member refid="classCSockCanScan_1aff132a17957a6e0c93ee76be0c2cdc88" prot="private" virt="non-virtual"><scope>CSockCanScan</scope><name>m_sock</name></member>
      <member refid="classCSockCanScan_1afe0c7cc23de0ac2d758a07bec4c2e2c8" prot="private" virt="non-virtual"><scope>CSockCanScan</scope><name>m_statistics</name></member>
      <member refid="classCanModule_1_1CCanAccess_1a4ddc9691fd9d42bcc7cb14ceae24da82" prot="protected" virt="non-virtual"><scope>CSockCanScan</scope><name>m_timeoutOnReception</name></member>
      <member refid="classCanModule_1_1CCanAccess_1a7bb4a17c5b05e5b01f59d9d9a0728f8a" prot="private" virt="non-virtual"><scope>CSockCanScan</scope><name>m_tz</name></member>
      <member refid="classCSockCanScan_1a203a51239f8efc013d4b9df36f271317" prot="private" virt="non-virtual"><scope>CSockCanScan</scope><name>openCanPort</name></member>
      <member refid="classCSockCanScan_1afb0a16ec4e702d79d5fe5dfcabfefbdb" prot="public" virt="non-virtual"><scope>CSockCanScan</scope><name>operator=</name></member>
      <member refid="classCanModule_1_1CCanAccess_1af26c9d102638fb96e5e1305f807d148f" prot="public" virt="non-virtual"><scope>CSockCanScan</scope><name>parseNameAndParameters</name></member>
      <member refid="classCanModule_1_1CCanAccess_1aa12f64e9e31bd491f39fc3169b1e5025" prot="protected" virt="non-virtual"><scope>CSockCanScan</scope><name>reconnectActionString</name></member>
      <member refid="classCanModule_1_1CCanAccess_1a9da88ce122d5de04a0235a4682a13dc0" prot="protected" virt="non-virtual"><scope>CSockCanScan</scope><name>reconnectConditionString</name></member>
      <member refid="classCanModule_1_1CCanAccess_1aad13b5ad34547cbe6cad4e8369557bed" prot="public" virt="non-virtual"><scope>CSockCanScan</scope><name>resetSendFailedCountdown</name></member>
      <member refid="classCanModule_1_1CCanAccess_1afefee3a90966dd8a01ca471022a7a9cd" prot="protected" virt="non-virtual"><scope>CSockCanScan</scope><name>resetTimeNow</name></member>
      <member refid="classCanModule_1_1CCanAccess_1a067f50699c1ed4b6ee6732eb0078ed0a" prot="protected" virt="non-virtual"><scope>CSockCanScan</scope><name>resetTimeoutOnReception</name></member>
      <member refid="classCSockCanScan_1a512733f202345e5940460f84539c979a" prot="private" virt="non-virtual"><scope>CSockCanScan</scope><name>sendErrorMessage</name></member>
      <member refid="classCSockCanScan_1a485ec8621a98cdacad8e27433e09d919" prot="public" virt="virtual"><scope>CSockCanScan</scope><name>sendMessage</name></member>
      <member refid="classCanModule_1_1CCanAccess_1ad0360c49d00ec0ee92cfdd73c2e43935" prot="public" virt="virtual" ambiguityscope="CanModule::CCanAccess::"><scope>CSockCanScan</scope><name>sendMessage</name></member>
      <member refid="classCSockCanScan_1a4999204ff7166ee992a89b30a118af06" prot="public" virt="virtual"><scope>CSockCanScan</scope><name>sendRemoteRequest</name></member>
      <member refid="classCSockCanScan_1ab806e1738ba9778c038150f51968839d" prot="public" virt="virtual"><scope>CSockCanScan</scope><name>setReconnectBehavior</name></member>
      <member refid="classCSockCanScan_1aceab51e91b2c698211e5d563e4449c91" prot="public" virt="virtual"><scope>CSockCanScan</scope><name>setReconnectFailedSendCount</name></member>
      <member refid="classCSockCanScan_1afad122d886579de793f2b7b49e5c6d5f" prot="public" virt="virtual"><scope>CSockCanScan</scope><name>setReconnectReceptionTimeout</name></member>
      <member refid="classCSockCanScan_1a7be2c075520b1cbf4baa4eb7d728fd2d" prot="public" virt="virtual"><scope>CSockCanScan</scope><name>stopBus</name></member>
      <member refid="classCanModule_1_1CCanAccess_1a16e43f90cd984b9ea72028c0f8dfe784" prot="public" virt="non-virtual"><scope>CSockCanScan</scope><name>triggerReconnectionThread</name></member>
      <member refid="classCSockCanScan_1aaed83a57ee1b70fff48a1a5ca9655fe6" prot="private" virt="non-virtual"><scope>CSockCanScan</scope><name>updateBusStatus</name></member>
      <member refid="classCSockCanScan_1a623057580187ecb241adf143c64d711c" prot="private" virt="non-virtual"><scope>CSockCanScan</scope><name>updateInitialError</name></member>
      <member refid="classCanModule_1_1CCanAccess_1ad8afab7f9acc769c53574edec695065b" prot="public" virt="non-virtual"><scope>CSockCanScan</scope><name>waitForReconnectionThreadTrigger</name></member>
      <member refid="classCanModule_1_1CCanAccess_1ac96f1cce6beda4309cdfb6651d3ce547" prot="public" virt="virtual"><scope>CSockCanScan</scope><name>~CCanAccess</name></member>
      <member refid="classCSockCanScan_1a243f91e993fcc96ddd5308c1425a130c" prot="public" virt="virtual"><scope>CSockCanScan</scope><name>~CSockCanScan</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
