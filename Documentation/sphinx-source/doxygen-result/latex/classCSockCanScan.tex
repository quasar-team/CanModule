\hypertarget{classCSockCanScan}{}\doxysection{C\+Sock\+Can\+Scan Class Reference}
\label{classCSockCanScan}\index{CSockCanScan@{CSockCanScan}}


{\ttfamily \#include $<$Sock\+Can\+Scan.\+h$>$}



Inheritance diagram for C\+Sock\+Can\+Scan\+:
% FIG 0


Collaboration diagram for C\+Sock\+Can\+Scan\+:
% FIG 1
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classCSockCanScan_abfb8f5e3726f9675a63f48648afae178}{C\+Sock\+Can\+Scan}} ()
\item 
\mbox{\hyperlink{classCSockCanScan_a7442798d8f943f85ca710f6f829c9efd}{C\+Sock\+Can\+Scan}} (\mbox{\hyperlink{classCSockCanScan}{C\+Sock\+Can\+Scan}} const \&other)=delete
\item 
\mbox{\hyperlink{classCSockCanScan}{C\+Sock\+Can\+Scan}} \& \mbox{\hyperlink{classCSockCanScan_afb0a16ec4e702d79d5fe5dfcabfefbdb}{operator=}} (\mbox{\hyperlink{classCSockCanScan}{C\+Sock\+Can\+Scan}} const \&other)=delete
\item 
virtual \mbox{\hyperlink{classCSockCanScan_a243f91e993fcc96ddd5308c1425a130c}{$\sim$\+C\+Sock\+Can\+Scan}} ()
\item 
virtual bool \mbox{\hyperlink{classCSockCanScan_a4999204ff7166ee992a89b30a118af06}{send\+Remote\+Request}} (short cob\+ID)
\item 
virtual int \mbox{\hyperlink{classCSockCanScan_a0f5e7229e4be33b45698c2a21577fc6b}{create\+Bus}} (const std\+::string name, std\+::string parameters)
\item 
virtual bool \mbox{\hyperlink{classCSockCanScan_a485ec8621a98cdacad8e27433e09d919}{send\+Message}} (short cob\+ID, unsigned char len, unsigned char $\ast$message, bool rtr=false)
\item 
virtual void \mbox{\hyperlink{classCSockCanScan_a38110f02c2d12fa9b620ba5ff438a960}{get\+Statistics}} (\mbox{\hyperlink{classCanModule_1_1CanStatistics}{Can\+Statistics}} \&result)
\item 
virtual uint32\+\_\+t \mbox{\hyperlink{classCSockCanScan_ad1caa327a98bc30012d2c5010a98cb05}{get\+Port\+Status}} ()
\item 
virtual uint32\+\_\+t \mbox{\hyperlink{classCSockCanScan_ad3404f38a5681bae4c0bbb6054a8ebaf}{get\+Port\+Bitrate}} ()
\item 
int \mbox{\hyperlink{classCSockCanScan_a5120fe6852dd4942e89fc23c3e09b20d}{get\+Handler}} ()
\item 
Log\+::\+Log\+Component\+Handle \mbox{\hyperlink{classCSockCanScan_a81829633cb836d4a229b4267be2768d2}{log\+It\+Handle}} ()
\item 
virtual void \mbox{\hyperlink{classCSockCanScan_ab806e1738ba9778c038150f51968839d}{set\+Reconnect\+Behavior}} (\mbox{\hyperlink{namespaceCanModule_a2f4fee79cc7ba53467c2538fe6b9adbb}{Can\+Module\+::\+Reconnect\+Auto\+Condition}} cond, \mbox{\hyperlink{namespaceCanModule_a2062089fa4fa87c8354295f2a8fe31a5}{Can\+Module\+::\+Reconnect\+Action}} action)
\item 
virtual void \mbox{\hyperlink{classCSockCanScan_afad122d886579de793f2b7b49e5c6d5f}{set\+Reconnect\+Reception\+Timeout}} (unsigned int timeout)
\item 
virtual void \mbox{\hyperlink{classCSockCanScan_aceab51e91b2c698211e5d563e4449c91}{set\+Reconnect\+Failed\+Send\+Count}} (unsigned int c)
\item 
virtual \mbox{\hyperlink{namespaceCanModule_a2f4fee79cc7ba53467c2538fe6b9adbb}{Can\+Module\+::\+Reconnect\+Auto\+Condition}} \mbox{\hyperlink{classCSockCanScan_aa8cb4c89fe3a13bb787c4085f1e994e3}{get\+Reconnect\+Condition}} ()
\item 
virtual \mbox{\hyperlink{namespaceCanModule_a2062089fa4fa87c8354295f2a8fe31a5}{Can\+Module\+::\+Reconnect\+Action}} \mbox{\hyperlink{classCSockCanScan_a03594b2fff9c61f37a5f68df2cfec05c}{get\+Reconnect\+Action}} ()
\item 
virtual void \mbox{\hyperlink{classCSockCanScan_a7be2c075520b1cbf4baa4eb7d728fd2d}{stop\+Bus}} ()
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static can\+\_\+frame \mbox{\hyperlink{classCSockCanScan_ace6f7aa52fe582af6de098895fc91b83}{empty\+Can\+Frame}} (void)
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
static std\+::map$<$ std\+::string, std\+::string $>$ \mbox{\hyperlink{classCSockCanScan_a7e4535b8435c633513fa1f9bd5a11ab7}{m\+\_\+bus\+Map}}
\end{DoxyCompactItemize}
\doxysubsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{classCSockCanScan_a623057580187ecb241adf143c64d711c}{update\+Initial\+Error}} ()
\item 
void \mbox{\hyperlink{classCSockCanScan_a4b5f7591bfd27b8770bfb9ac9e406f66}{clear\+Error\+Message}} ()
\item 
int \mbox{\hyperlink{classCSockCanScan_abb779972a106cc4f74d1bfa8ea4e47cb}{configure\+Can\+Board}} (const std\+::string name, const std\+::string parameters)
\item 
int \mbox{\hyperlink{classCSockCanScan_a203a51239f8efc013d4b9df36f271317}{open\+Can\+Port}} ()
\item 
void \mbox{\hyperlink{classCSockCanScan_a2a97f7fca98e6d599bdb42da64796ad8}{Can\+Scan\+Control\+Thread}} ()
\item 
void \mbox{\hyperlink{classCSockCanScan_a808488b6793afea6cc8466c3a12a088c}{Can\+Reconnection\+Thread}} ()
\end{DoxyCompactItemize}
\doxysubsection*{Static Private Member Functions}
\begin{DoxyCompactItemize}
\item 
static std\+::string \mbox{\hyperlink{classCSockCanScan_a177453d85f24c6b12b84468ac812cf5c}{error\+Frame\+To\+String}} (const struct can\+\_\+frame \&f)
\end{DoxyCompactItemize}
\doxysubsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
volatile std\+::atomic\+\_\+bool \mbox{\hyperlink{classCSockCanScan_ad77d913e61599d041a1237cfc169ef4d}{m\+\_\+\+Can\+Scan\+Thread\+Run\+Enable\+Flag}}
\item 
std\+::atomic\+\_\+int \mbox{\hyperlink{classCSockCanScan_a7a476903f25b097ff4f5fc6031b55ffc}{m\+\_\+sock}}
\item 
int \mbox{\hyperlink{classCSockCanScan_a01a0096926dc8236ae11077deb5e02a2}{m\+\_\+error\+Code}}
\item 
\mbox{\hyperlink{classCanModule_1_1CanStatistics}{Can\+Statistics}} \mbox{\hyperlink{classCSockCanScan_afe0c7cc23de0ac2d758a07bec4c2e2c8}{m\+\_\+statistics}}
\item 
std\+::thread $\ast$ \mbox{\hyperlink{classCSockCanScan_a344d3a2b2d61a0adbc364e980af7c740}{m\+\_\+h\+Can\+Scan\+Thread}}
\item 
std\+::string \mbox{\hyperlink{classCSockCanScan_a1810bdcb6beda833752d4ddb83efde7f}{m\+\_\+channel\+Name}}
\item 
std\+::string \mbox{\hyperlink{classCSockCanScan_a47b82a55c47a74e0918378baf82dd45a}{m\+\_\+bus\+Name}}
\item 
Log\+::\+Log\+Component\+Handle \mbox{\hyperlink{classCSockCanScan_aa3406fed8265f9b21ae0b5de89bc3ce2}{m\+\_\+log\+It\+Handle\+Sock}}
\end{DoxyCompactItemize}
\doxysubsection*{Additional Inherited Members}


\doxysubsection{Detailed Description}


Definition at line 46 of file Sock\+Can\+Scan.\+h.



\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classCSockCanScan_abfb8f5e3726f9675a63f48648afae178}\label{classCSockCanScan_abfb8f5e3726f9675a63f48648afae178}} 
\index{CSockCanScan@{CSockCanScan}!CSockCanScan@{CSockCanScan}}
\index{CSockCanScan@{CSockCanScan}!CSockCanScan@{CSockCanScan}}
\doxysubsubsection{\texorpdfstring{CSockCanScan()}{CSockCanScan()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily C\+Sock\+Can\+Scan\+::\+C\+Sock\+Can\+Scan (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Definition at line 67 of file Sock\+Can\+Scan.\+cpp.



References Can\+Module\+::\+Can\+Statistics\+::begin\+New\+Run(), Can\+Module\+::\+C\+Can\+Access\+::m\+\_\+failed\+Send\+Countdown, Can\+Module\+::\+C\+Can\+Access\+::m\+\_\+max\+Failed\+Send\+Count, m\+\_\+statistics, and Can\+Module\+::\+Can\+Statistics\+::set\+Time\+Since\+Opened().

Here is the call graph for this function\+:
% FIG 2
\mbox{\Hypertarget{classCSockCanScan_a7442798d8f943f85ca710f6f829c9efd}\label{classCSockCanScan_a7442798d8f943f85ca710f6f829c9efd}} 
\index{CSockCanScan@{CSockCanScan}!CSockCanScan@{CSockCanScan}}
\index{CSockCanScan@{CSockCanScan}!CSockCanScan@{CSockCanScan}}
\doxysubsubsection{\texorpdfstring{CSockCanScan()}{CSockCanScan()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily C\+Sock\+Can\+Scan\+::\+C\+Sock\+Can\+Scan (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classCSockCanScan}{C\+Sock\+Can\+Scan}} const \&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [delete]}}

\mbox{\Hypertarget{classCSockCanScan_a243f91e993fcc96ddd5308c1425a130c}\label{classCSockCanScan_a243f91e993fcc96ddd5308c1425a130c}} 
\index{CSockCanScan@{CSockCanScan}!````~CSockCanScan@{$\sim$CSockCanScan}}
\index{````~CSockCanScan@{$\sim$CSockCanScan}!CSockCanScan@{CSockCanScan}}
\doxysubsubsection{\texorpdfstring{$\sim$CSockCanScan()}{~CSockCanScan()}}
{\footnotesize\ttfamily C\+Sock\+Can\+Scan\+::$\sim$\+C\+Sock\+Can\+Scan (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Definition at line 462 of file Sock\+Can\+Scan.\+cpp.



References M\+L\+O\+G\+S\+O\+CK, and stop\+Bus().

Here is the call graph for this function\+:
% FIG 3


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classCSockCanScan_a808488b6793afea6cc8466c3a12a088c}\label{classCSockCanScan_a808488b6793afea6cc8466c3a12a088c}} 
\index{CSockCanScan@{CSockCanScan}!CanReconnectionThread@{CanReconnectionThread}}
\index{CanReconnectionThread@{CanReconnectionThread}!CSockCanScan@{CSockCanScan}}
\doxysubsubsection{\texorpdfstring{CanReconnectionThread()}{CanReconnectionThread()}}
{\footnotesize\ttfamily void C\+Sock\+Can\+Scan\+::\+Can\+Reconnection\+Thread (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}

Reconnection thread managing the reconnection behavior, per port. The behavior settings can not change during runtime. This thread is initialized after the main thread is up, and then listens on its cond.\+var as a trigger. Triggers occur in two contexts\+: sending and receiving problems. If there is a sending problem which lasts for a while (usually) the reconnection thread will be also triggered for each failed sending\+: the thread will be \char`\"{}hammered\char`\"{} by triggers. ince the reconnection takes some time, many triggers will be lost. That is in fact a desired behavior.

The parameters are all atomics for increased thread-\/safety, even though the documentation about the predicate is unclear on that point. Since atomics just provide a \char`\"{}sequential memory layout\char`\"{} for the variables to prevent race conditions they are good to use for this but the code still has to be threadsafe and reentrant... ;-\/) Doesn\textquotesingle{}t eat anything anyway on that small scale with scalars only.

\href{https://en.cppreference.com/w/cpp/thread/condition_variable/wait}{\texttt{ https\+://en.\+cppreference.\+com/w/cpp/thread/condition\+\_\+variable/wait}} lets check the timeout\+On\+Reception reconnect condition. If it is true, all we can do is to close/open the socket again since the underlying hardware is hidden by socketcan abstraction. Like his we do not have to pollute the \char`\"{}send\+Message\char`\"{} like for anagate, and that is cleaner.

just manage the conditions, and continue/skip if there is nothing to do

socketcan abstracts away the notion of a \char`\"{}module\char`\"{}, and that is the point. Various plugin-\/orders should lead to the same device mapping nevertheless. But then we can\textquotesingle{}t refer to a module and reset all of it\textquotesingle{}s channels easily in linux. Unless we make a big effort and keep track of which port is on which module, for peak\+: more udev calls, for systec\+: we need to read the module serial number or similar. Maybe there is an elegant way out, but I think it is not worth it. Use a P\+DU if you want to reset your systec16. For peak the notion of \char`\"{}module\char`\"{} is already difficult through socketcan (udev calls needed to identify the modules) and peak bridges get their power over U\+SB. So in fact testing peak means \char`\"{}rebooting\char`\"{} unless you want to unplug the U\+SB. Therefore \char`\"{}all\+Buses\+On\+Bridge\char`\"{} as reconnect action is not available for sock.

\mbox{\hyperlink{namespaceCanModule_a2062089fa4fa87c8354295f2a8fe31a5a319ee2c9d887d55f6bc1941518a5ae76}{Can\+Module\+::\+Reconnect\+Action\+::all\+Buses\+On\+Bridge}} is not implemented for sock

Definition at line 360 of file Sock\+Can\+Scan.\+cpp.



References get\+Reconnect\+Action(), get\+Reconnect\+Condition(), Can\+Module\+::\+C\+Can\+Access\+::has\+Timeout\+On\+Reception(), Can\+Module\+::\+C\+Can\+Access\+::m\+\_\+failed\+Send\+Countdown, Can\+Module\+::\+C\+Can\+Access\+::m\+\_\+reconnect\+Action, Can\+Module\+::\+C\+Can\+Access\+::m\+\_\+reconnect\+Condition, m\+\_\+sock, M\+L\+O\+G\+S\+O\+CK, Can\+Module\+::never, open\+Can\+Port(), Can\+Module\+::\+C\+Can\+Access\+::reconnect\+Action\+String(), Can\+Module\+::\+C\+Can\+Access\+::reconnect\+Condition\+String(), Can\+Module\+::\+C\+Can\+Access\+::reset\+Send\+Failed\+Countdown(), Can\+Module\+::\+C\+Can\+Access\+::reset\+Timeout\+On\+Reception(), Can\+Module\+::send\+Fail, Can\+Module\+::single\+Bus, Can\+Module\+::timeout\+On\+Reception, and Can\+Module\+::\+C\+Can\+Access\+::wait\+For\+Reconnection\+Thread\+Trigger().



Referenced by create\+Bus().

Here is the call graph for this function\+:
% FIG 4
\mbox{\Hypertarget{classCSockCanScan_a2a97f7fca98e6d599bdb42da64796ad8}\label{classCSockCanScan_a2a97f7fca98e6d599bdb42da64796ad8}} 
\index{CSockCanScan@{CSockCanScan}!CanScanControlThread@{CanScanControlThread}}
\index{CanScanControlThread@{CanScanControlThread}!CSockCanScan@{CSockCanScan}}
\doxysubsubsection{\texorpdfstring{CanScanControlThread()}{CanScanControlThread()}}
{\footnotesize\ttfamily void C\+Sock\+Can\+Scan\+::\+Can\+Scan\+Control\+Thread (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}

The main control thread function for the C\+AN update scan manager\+: a private non-\/static method, which is called on the object (this) following std\+::thread C++11 ways.

reading from socket, and supervising thread for monitoring the sockets/\+C\+AN buses. It takes an object reference (cast) and listens with a select call on that socket/object. The select runs with 1Hz, and if there is nothing to receive it should timeout. the select failed. that is very bad, system problem, but let\textquotesingle{}s continue nevertheless. There is not much we can do

select returned, either on the timeout or with something on that socket/object. Assumption\+: at this moment sock holds meaningful value. Now select result $>$=0 so it was either nothing received (timeout) or something received

The preceding call took either \textquotesingle{}timeout\textquotesingle{} time, or there is frame received -- perfect time to attempt to clean error frame.

select reports that it has got something, so no timeout in this case

try to re-\/open the socket. only reopen the socket if we still need it. If we need to shutdown the thread, leave it closed and terminate main loop.

if we have an open socket again, and we can read number\+Of\+Read\+Bytes $>$=0 we should be fine again and continue the thread execution normally

we have a C\+AN message, error free, lets digest it

reformat and buffer the message from the socket. this actually should exclude more bits

the select got nothing to read, this was just a timeout, all is fine. Unless the reconnect timeout has something to do.

the reconnect behavior happens in an extra thread so that the send\+Message becomes non blocking. This is the reception of the message part, and strictly speaking we could do the reconnection due to reception message timeout also here.

That is N\+OT the same as the \char`\"{}select\char`\"{} timeout, of course.

For cleanliness, lets use that extra reconnection thread nevertheless here.

Definition at line 108 of file Sock\+Can\+Scan.\+cpp.



References M\+L\+O\+G\+S\+O\+CK.



Referenced by create\+Bus().

\mbox{\Hypertarget{classCSockCanScan_a4b5f7591bfd27b8770bfb9ac9e406f66}\label{classCSockCanScan_a4b5f7591bfd27b8770bfb9ac9e406f66}} 
\index{CSockCanScan@{CSockCanScan}!clearErrorMessage@{clearErrorMessage}}
\index{clearErrorMessage@{clearErrorMessage}!CSockCanScan@{CSockCanScan}}
\doxysubsubsection{\texorpdfstring{clearErrorMessage()}{clearErrorMessage()}}
{\footnotesize\ttfamily void C\+Sock\+Can\+Scan\+::clear\+Error\+Message (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 886 of file Sock\+Can\+Scan.\+cpp.



References Can\+Module\+::\+C\+Can\+Access\+::can\+Message\+Error, Can\+Module\+::convert\+Timepoint\+To\+Timeval(), Can\+Module\+::\+C\+Can\+Access\+::get\+Bus\+Name(), m\+\_\+sock, and M\+L\+O\+G\+S\+O\+CK.



Referenced by update\+Initial\+Error().

Here is the call graph for this function\+:
% FIG 5
\mbox{\Hypertarget{classCSockCanScan_abb779972a106cc4f74d1bfa8ea4e47cb}\label{classCSockCanScan_abb779972a106cc4f74d1bfa8ea4e47cb}} 
\index{CSockCanScan@{CSockCanScan}!configureCanBoard@{configureCanBoard}}
\index{configureCanBoard@{configureCanBoard}!CSockCanScan@{CSockCanScan}}
\doxysubsubsection{\texorpdfstring{configureCanBoard()}{configureCanBoard()}}
{\footnotesize\ttfamily int C\+Sock\+Can\+Scan\+::configure\+Can\+Board (\begin{DoxyParamCaption}\item[{const std\+::string}]{name,  }\item[{const std\+::string}]{parameters }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}

for P\+E\+AK bridges, we have a problem\+: the local ports are not mapped to the global socketcan ports in a deterministic way. O\+P\+C\+U\+A-\/1735. So, lets make a udev call here, analyze the result and manipulate the port number so that it becomes a global port number.

In order to distinguish between systec (where it works) and peak bridges we use an extended name\+: systec\+: name=\char`\"{}sock\+:can0\char`\"{} peak\+: name=\char`\"{}sock\+:can0\+:device17440\char`\"{}

now, we manipulate the lname to reflect the absolute port which we found out. We do the rewiring at initialisation, like this we don\textquotesingle{}t care anymore during runtime.

Definition at line 468 of file Sock\+Can\+Scan.\+cpp.



References m\+\_\+channel\+Name, m\+\_\+log\+It\+Handle\+Sock, M\+L\+O\+G\+S\+O\+CK, open\+Can\+Port(), Can\+Module\+::\+C\+Can\+Access\+::parse\+Name\+And\+Parameters(), udevanalyserforpeak\+\_\+ns\+::\+Udev\+Analyser\+For\+Peak\+::peak\+Extended\+Identifier\+To\+Socket\+Can\+Device(), and udevanalyserforpeak\+\_\+ns\+::\+Udev\+Analyser\+For\+Peak\+::show\+Map().



Referenced by create\+Bus().

Here is the call graph for this function\+:
% FIG 6
\mbox{\Hypertarget{classCSockCanScan_a0f5e7229e4be33b45698c2a21577fc6b}\label{classCSockCanScan_a0f5e7229e4be33b45698c2a21577fc6b}} 
\index{CSockCanScan@{CSockCanScan}!createBus@{createBus}}
\index{createBus@{createBus}!CSockCanScan@{CSockCanScan}}
\doxysubsubsection{\texorpdfstring{createBus()}{createBus()}}
{\footnotesize\ttfamily int C\+Sock\+Can\+Scan\+::create\+Bus (\begin{DoxyParamCaption}\item[{const std\+::string}]{name,  }\item[{std\+::string}]{parameters }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

Method that initializes a can bus channel. The following methods called upon the same object will be using this initialized channel.


\begin{DoxyParams}{Parameters}
{\em name} & = 2 parameters separated by \char`\"{}\+:\char`\"{}, like \char`\"{}n0\+:n1\char`\"{}
\begin{DoxyItemize}
\item n0 = \char`\"{}sock\char`\"{} for sockets linux, used by systec and peak
\item n1 = C\+AN port number on the module, can be prefixed with \char`\"{}can\char`\"{}
\item ex.\+: \char`\"{}sock\+:can1\char`\"{} speaks to port 1 on systec or peak module
\item ex.\+: \char`\"{}sock\+:1\char`\"{} works as well
\end{DoxyItemize}\\
\hline
{\em parameters} & one parameter\+: \char`\"{}p0\char`\"{}, positive integer
\begin{DoxyItemize}
\item \char`\"{}\+Unspecified\char`\"{} (or empty)\+: using defaults = \char`\"{}125000\char`\"{} // params missing
\item p0\+: bitrate\+: 50000, 100000, 125000, 250000, 500000, 1000000 bit/s, other values might be allowed by the module
\end{DoxyItemize}\\
\hline
\end{DoxyParams}

\begin{DoxyItemize}
\item i.\+e. \char`\"{}250000\char`\"{}
\end{DoxyItemize}

\begin{DoxyReturn}{Returns}
Was the initialization process successful?
\end{DoxyReturn}
dont create a main thread for the same bus twice\+: if it exists already, just configure the board again this protects agains having multiple threads if a given port ports is opened several times\+: protects against erro/unusual runtime. If the connection is closed, it\textquotesingle{}s main thread is stopped and joined, and the port is erased from the connection map. when the same port is opened again later on, a (new) main thread is created, and the connection is again added to the map. start a reconnection thread

Implements \mbox{\hyperlink{classCanModule_1_1CCanAccess_a2ef435a5fb9896dbb70bc0e149fa0549}{Can\+Module\+::\+C\+Can\+Access}}.



Definition at line 745 of file Sock\+Can\+Scan.\+cpp.



References Can\+Reconnection\+Thread(), Can\+Scan\+Control\+Thread(), configure\+Can\+Board(), Can\+Module\+::\+Log\+It\+Component\+Name, m\+\_\+bus\+Map, m\+\_\+bus\+Name, m\+\_\+\+Can\+Scan\+Thread\+Run\+Enable\+Flag, Can\+Module\+::\+C\+Can\+Access\+::m\+\_\+h\+Can\+Reconnection\+Thread, m\+\_\+h\+Can\+Scan\+Thread, m\+\_\+log\+It\+Handle\+Sock, m\+\_\+sock, M\+L\+O\+G\+S\+O\+CK, and sock\+Reconnect\+Mutex.

Here is the call graph for this function\+:
% FIG 7
\mbox{\Hypertarget{classCSockCanScan_ace6f7aa52fe582af6de098895fc91b83}\label{classCSockCanScan_ace6f7aa52fe582af6de098895fc91b83}} 
\index{CSockCanScan@{CSockCanScan}!emptyCanFrame@{emptyCanFrame}}
\index{emptyCanFrame@{emptyCanFrame}!CSockCanScan@{CSockCanScan}}
\doxysubsubsection{\texorpdfstring{emptyCanFrame()}{emptyCanFrame()}}
{\footnotesize\ttfamily static can\+\_\+frame C\+Sock\+Can\+Scan\+::empty\+Can\+Frame (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}

produce an empty can frame 

Definition at line 102 of file Sock\+Can\+Scan.\+h.



Referenced by send\+Message().

\mbox{\Hypertarget{classCSockCanScan_a177453d85f24c6b12b84468ac812cf5c}\label{classCSockCanScan_a177453d85f24c6b12b84468ac812cf5c}} 
\index{CSockCanScan@{CSockCanScan}!errorFrameToString@{errorFrameToString}}
\index{errorFrameToString@{errorFrameToString}!CSockCanScan@{CSockCanScan}}
\doxysubsubsection{\texorpdfstring{errorFrameToString()}{errorFrameToString()}}
{\footnotesize\ttfamily std\+::string C\+Sock\+Can\+Scan\+::error\+Frame\+To\+String (\begin{DoxyParamCaption}\item[{const struct can\+\_\+frame \&}]{can\+Frame }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}

Transforms an error frame into an error message (string format)\+: Provides textual representation of Socket\+C\+AN error. 

Definition at line 812 of file Sock\+Can\+Scan.\+cpp.

\mbox{\Hypertarget{classCSockCanScan_a5120fe6852dd4942e89fc23c3e09b20d}\label{classCSockCanScan_a5120fe6852dd4942e89fc23c3e09b20d}} 
\index{CSockCanScan@{CSockCanScan}!getHandler@{getHandler}}
\index{getHandler@{getHandler}!CSockCanScan@{CSockCanScan}}
\doxysubsubsection{\texorpdfstring{getHandler()}{getHandler()}}
{\footnotesize\ttfamily int C\+Sock\+Can\+Scan\+::get\+Handler (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Returns socket handler 

Definition at line 97 of file Sock\+Can\+Scan.\+h.

\mbox{\Hypertarget{classCSockCanScan_ad3404f38a5681bae4c0bbb6054a8ebaf}\label{classCSockCanScan_ad3404f38a5681bae4c0bbb6054a8ebaf}} 
\index{CSockCanScan@{CSockCanScan}!getPortBitrate@{getPortBitrate}}
\index{getPortBitrate@{getPortBitrate}!CSockCanScan@{CSockCanScan}}
\doxysubsubsection{\texorpdfstring{getPortBitrate()}{getPortBitrate()}}
{\footnotesize\ttfamily virtual uint32\+\_\+t C\+Sock\+Can\+Scan\+::get\+Port\+Bitrate (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

returns the bitrate of that port \mbox{[}bits/sec\mbox{]} according to what \mbox{\hyperlink{namespaceCanModule}{Can\+Module}} buffers say. This is the setting used for setting up the hardware, after any default rules have been applied, but B\+E\+F\+O\+RE any vendor specific encoding into obscure bitpatterns occurs. This happens at port opening and the bitrate can only be changed at that moment. So please call this method just after you have opened the port. But also since there is no hw interaction and it just returns a buffer, you may call it as often as you like. 

Implements \mbox{\hyperlink{classCanModule_1_1CCanAccess_aa8cb67096349fefc6e03aeb33e45ef81}{Can\+Module\+::\+C\+Can\+Access}}.



Definition at line 92 of file Sock\+Can\+Scan.\+h.

\mbox{\Hypertarget{classCSockCanScan_ad1caa327a98bc30012d2c5010a98cb05}\label{classCSockCanScan_ad1caa327a98bc30012d2c5010a98cb05}} 
\index{CSockCanScan@{CSockCanScan}!getPortStatus@{getPortStatus}}
\index{getPortStatus@{getPortStatus}!CSockCanScan@{CSockCanScan}}
\doxysubsubsection{\texorpdfstring{getPortStatus()}{getPortStatus()}}
{\footnotesize\ttfamily virtual uint32\+\_\+t C\+Sock\+Can\+Scan\+::get\+Port\+Status (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

return socketcan port status in vendor unified format (with implementation nibble set), from can\+\_\+netlink.\+h do not start a new statistics run for that. enum can\+\_\+state \{ C\+A\+N\+\_\+\+S\+T\+A\+T\+E\+\_\+\+E\+R\+R\+O\+R\+\_\+\+A\+C\+T\+I\+VE = 0, R\+X/\+TX error count $<$ 96 C\+A\+N\+\_\+\+S\+T\+A\+T\+E\+\_\+\+E\+R\+R\+O\+R\+\_\+\+W\+A\+R\+N\+I\+NG, R\+X/\+TX error count $<$ 128 C\+A\+N\+\_\+\+S\+T\+A\+T\+E\+\_\+\+E\+R\+R\+O\+R\+\_\+\+P\+A\+S\+S\+I\+VE, R\+X/\+TX error count $<$ 256 C\+A\+N\+\_\+\+S\+T\+A\+T\+E\+\_\+\+B\+U\+S\+\_\+\+O\+FF, R\+X/\+TX error count $>$= 256 C\+A\+N\+\_\+\+S\+T\+A\+T\+E\+\_\+\+S\+T\+O\+P\+P\+ED, Device is stopped C\+A\+N\+\_\+\+S\+T\+A\+T\+E\+\_\+\+S\+L\+E\+E\+P\+I\+NG, Device is sleeping C\+A\+N\+\_\+\+S\+T\+A\+T\+E\+\_\+\+M\+AX \};

update the C\+AN bus status I\+F\+LA from socketcan and make up a \mbox{\hyperlink{namespaceCanModule}{Can\+Module}} status bitpattern out from this.

int can\+\_\+get\+\_\+restart\+\_\+ms(const char $\ast$name, \+\_\+\+\_\+u32 $\ast$restart\+\_\+ms); int can\+\_\+get\+\_\+bittiming(const char $\ast$name, struct can\+\_\+bittiming $\ast$bt); int can\+\_\+get\+\_\+ctrlmode(const char $\ast$name, struct can\+\_\+ctrlmode $\ast$cm); int can\+\_\+get\+\_\+state(const char $\ast$name, int $\ast$state); int can\+\_\+get\+\_\+clock(const char $\ast$name, struct can\+\_\+clock $\ast$clock); int can\+\_\+get\+\_\+bittiming\+\_\+const(const char $\ast$name, struct can\+\_\+bittiming\+\_\+const $\ast$btc); int can\+\_\+get\+\_\+berr\+\_\+counter(const char $\ast$name, struct can\+\_\+berr\+\_\+counter $\ast$bc); int can\+\_\+get\+\_\+device\+\_\+stats(const char $\ast$name, struct can\+\_\+device\+\_\+stats $\ast$cds); 

Implements \mbox{\hyperlink{classCanModule_1_1CCanAccess_a33fe530d070cf35d096e967d543186a4}{Can\+Module\+::\+C\+Can\+Access}}.



Definition at line 86 of file Sock\+Can\+Scan.\+h.



References C\+A\+N\+M\+O\+D\+U\+L\+E\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+B\+P\+\_\+\+S\+O\+CK.

\mbox{\Hypertarget{classCSockCanScan_a03594b2fff9c61f37a5f68df2cfec05c}\label{classCSockCanScan_a03594b2fff9c61f37a5f68df2cfec05c}} 
\index{CSockCanScan@{CSockCanScan}!getReconnectAction@{getReconnectAction}}
\index{getReconnectAction@{getReconnectAction}!CSockCanScan@{CSockCanScan}}
\doxysubsubsection{\texorpdfstring{getReconnectAction()}{getReconnectAction()}}
{\footnotesize\ttfamily virtual \mbox{\hyperlink{namespaceCanModule_a2062089fa4fa87c8354295f2a8fe31a5}{Can\+Module\+::\+Reconnect\+Action}} C\+Sock\+Can\+Scan\+::get\+Reconnect\+Action (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

read back the r.\+action 

Implements \mbox{\hyperlink{classCanModule_1_1CCanAccess_aaf2312ff9074ce7a4ec2e7d0a5b6fa16}{Can\+Module\+::\+C\+Can\+Access}}.



Definition at line 121 of file Sock\+Can\+Scan.\+h.



Referenced by Can\+Reconnection\+Thread().

\mbox{\Hypertarget{classCSockCanScan_aa8cb4c89fe3a13bb787c4085f1e994e3}\label{classCSockCanScan_aa8cb4c89fe3a13bb787c4085f1e994e3}} 
\index{CSockCanScan@{CSockCanScan}!getReconnectCondition@{getReconnectCondition}}
\index{getReconnectCondition@{getReconnectCondition}!CSockCanScan@{CSockCanScan}}
\doxysubsubsection{\texorpdfstring{getReconnectCondition()}{getReconnectCondition()}}
{\footnotesize\ttfamily virtual \mbox{\hyperlink{namespaceCanModule_a2f4fee79cc7ba53467c2538fe6b9adbb}{Can\+Module\+::\+Reconnect\+Auto\+Condition}} C\+Sock\+Can\+Scan\+::get\+Reconnect\+Condition (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

read back the r.\+condition 

Implements \mbox{\hyperlink{classCanModule_1_1CCanAccess_a003566cbcdf4ce8195853bd8049a8800}{Can\+Module\+::\+C\+Can\+Access}}.



Definition at line 120 of file Sock\+Can\+Scan.\+h.



Referenced by Can\+Reconnection\+Thread().

\mbox{\Hypertarget{classCSockCanScan_a38110f02c2d12fa9b620ba5ff438a960}\label{classCSockCanScan_a38110f02c2d12fa9b620ba5ff438a960}} 
\index{CSockCanScan@{CSockCanScan}!getStatistics@{getStatistics}}
\index{getStatistics@{getStatistics}!CSockCanScan@{CSockCanScan}}
\doxysubsubsection{\texorpdfstring{getStatistics()}{getStatistics()}}
{\footnotesize\ttfamily void C\+Sock\+Can\+Scan\+::get\+Statistics (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classCanModule_1_1CanStatistics}{Can\+Statistics}} \&}]{result }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Implements \mbox{\hyperlink{classCanModule_1_1CCanAccess_ad3182c83b4c5d7e6aef982c36e731507}{Can\+Module\+::\+C\+Can\+Access}}.



Definition at line 949 of file Sock\+Can\+Scan.\+cpp.



References Can\+Module\+::\+Can\+Statistics\+::begin\+New\+Run(), Can\+Module\+::\+Can\+Statistics\+::compute\+Derived(), Can\+Module\+::\+C\+Can\+Access\+::m\+\_\+\+Can\+Parameters, Can\+Module\+::\+Can\+Parameters\+::m\+\_\+l\+Baud\+Rate, and m\+\_\+statistics.

Here is the call graph for this function\+:
% FIG 8
\mbox{\Hypertarget{classCSockCanScan_a81829633cb836d4a229b4267be2768d2}\label{classCSockCanScan_a81829633cb836d4a229b4267be2768d2}} 
\index{CSockCanScan@{CSockCanScan}!logItHandle@{logItHandle}}
\index{logItHandle@{logItHandle}!CSockCanScan@{CSockCanScan}}
\doxysubsubsection{\texorpdfstring{logItHandle()}{logItHandle()}}
{\footnotesize\ttfamily Log\+::\+Log\+Component\+Handle C\+Sock\+Can\+Scan\+::log\+It\+Handle (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line 112 of file Sock\+Can\+Scan.\+h.

\mbox{\Hypertarget{classCSockCanScan_a203a51239f8efc013d4b9df36f271317}\label{classCSockCanScan_a203a51239f8efc013d4b9df36f271317}} 
\index{CSockCanScan@{CSockCanScan}!openCanPort@{openCanPort}}
\index{openCanPort@{openCanPort}!CSockCanScan@{CSockCanScan}}
\doxysubsubsection{\texorpdfstring{openCanPort()}{openCanPort()}}
{\footnotesize\ttfamily int C\+Sock\+Can\+Scan\+::open\+Can\+Port (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}

Obtains a Socket\+C\+AN socket and opens it. The name of the port and parameters should have been specified by preceding call to configure\+Canboard()

\begin{DoxyReturn}{Returns}
less than zero in case of error, otherwise success
\end{DoxyReturn}
stop, set bitrate, start a C\+AN port, open a socket for it, set the socket to C\+AN, bind it and check any errors 

Definition at line 514 of file Sock\+Can\+Scan.\+cpp.



References Can\+Module\+::\+Can\+Moduleerrno\+To\+String(), Can\+Module\+::\+C\+Can\+Access\+::m\+\_\+\+Can\+Parameters, m\+\_\+channel\+Name, Can\+Module\+::\+Can\+Parameters\+::m\+\_\+dont\+Reconfigure, m\+\_\+error\+Code, Can\+Module\+::\+Can\+Parameters\+::m\+\_\+l\+Baud\+Rate, m\+\_\+sock, m\+\_\+statistics, M\+L\+OG, M\+L\+O\+G\+S\+O\+CK, Can\+Module\+::\+Can\+Statistics\+::set\+Time\+Since\+Opened(), and update\+Initial\+Error().



Referenced by Can\+Reconnection\+Thread(), and configure\+Can\+Board().

Here is the call graph for this function\+:
% FIG 9
\mbox{\Hypertarget{classCSockCanScan_afb0a16ec4e702d79d5fe5dfcabfefbdb}\label{classCSockCanScan_afb0a16ec4e702d79d5fe5dfcabfefbdb}} 
\index{CSockCanScan@{CSockCanScan}!operator=@{operator=}}
\index{operator=@{operator=}!CSockCanScan@{CSockCanScan}}
\doxysubsubsection{\texorpdfstring{operator=()}{operator=()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classCSockCanScan}{C\+Sock\+Can\+Scan}}\& C\+Sock\+Can\+Scan\+::operator= (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classCSockCanScan}{C\+Sock\+Can\+Scan}} const \&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [delete]}}

\mbox{\Hypertarget{classCSockCanScan_a485ec8621a98cdacad8e27433e09d919}\label{classCSockCanScan_a485ec8621a98cdacad8e27433e09d919}} 
\index{CSockCanScan@{CSockCanScan}!sendMessage@{sendMessage}}
\index{sendMessage@{sendMessage}!CSockCanScan@{CSockCanScan}}
\doxysubsubsection{\texorpdfstring{sendMessage()}{sendMessage()}}
{\footnotesize\ttfamily bool C\+Sock\+Can\+Scan\+::send\+Message (\begin{DoxyParamCaption}\item[{short}]{cob\+ID,  }\item[{unsigned char}]{len,  }\item[{unsigned char $\ast$}]{message,  }\item[{bool}]{rtr = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

Method that sends a message trough the can bus channel. If the method create\+B\+US was not called before this, send\+Message will fail, as there is no can bus channel to send a message through.


\begin{DoxyParams}{Parameters}
{\em cob\+ID} & Identifier that will be used for the message. \\
\hline
{\em len} & Length of the message. If the message is bigger than 8 characters, it will be split into separate 8 characters messages. \\
\hline
{\em message} & Message to be sent trough the can bus. \\
\hline
{\em rtr} & is the message a remote transmission request? \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Was the initialisation process successful?
\end{DoxyReturn}
O\+P\+C\+U\+A-\/2604\+: send\+Message must be non blocking. The reconnection behavior therefore must be managed in a separate thread.

returns\+: true for success, otherwise false 

Implements \mbox{\hyperlink{classCanModule_1_1CCanAccess_aee42ab7fb9e50c02a1812202f7863d8c}{Can\+Module\+::\+C\+Can\+Access}}.



Definition at line 609 of file Sock\+Can\+Scan.\+cpp.



References Can\+Module\+::can\+Message2\+To\+String(), empty\+Can\+Frame(), m\+\_\+\+Can\+Scan\+Thread\+Run\+Enable\+Flag, m\+\_\+sock, and M\+L\+O\+G\+S\+O\+CK.

Here is the call graph for this function\+:
% FIG 10
\mbox{\Hypertarget{classCSockCanScan_a4999204ff7166ee992a89b30a118af06}\label{classCSockCanScan_a4999204ff7166ee992a89b30a118af06}} 
\index{CSockCanScan@{CSockCanScan}!sendRemoteRequest@{sendRemoteRequest}}
\index{sendRemoteRequest@{sendRemoteRequest}!CSockCanScan@{CSockCanScan}}
\doxysubsubsection{\texorpdfstring{sendRemoteRequest()}{sendRemoteRequest()}}
{\footnotesize\ttfamily bool C\+Sock\+Can\+Scan\+::send\+Remote\+Request (\begin{DoxyParamCaption}\item[{short}]{cob\+ID }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

Method that sends a remote request trough the can bus channel. If the method create\+B\+US was not called before this, send\+Message will fail, as there is no can bus channel to send the request trough. Similar to send\+Message, but it sends an special message reserved for requests. 
\begin{DoxyParams}{Parameters}
{\em cob\+ID} & Identifier that will be used for the request. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\+: Was the initialisation process successful?
\end{DoxyReturn}
that is not tested or used until now, and I am not sure it works 

Implements \mbox{\hyperlink{classCanModule_1_1CCanAccess_acfefbc9be2696b1388cf6df2bba00aa1}{Can\+Module\+::\+C\+Can\+Access}}.



Definition at line 686 of file Sock\+Can\+Scan.\+cpp.



References Can\+Module\+::\+Can\+Moduleerrno\+To\+String(), m\+\_\+sock, m\+\_\+statistics, M\+L\+O\+G\+S\+O\+CK, and Can\+Module\+::\+Can\+Statistics\+::set\+Time\+Since\+Received().

Here is the call graph for this function\+:
% FIG 11
\mbox{\Hypertarget{classCSockCanScan_ab806e1738ba9778c038150f51968839d}\label{classCSockCanScan_ab806e1738ba9778c038150f51968839d}} 
\index{CSockCanScan@{CSockCanScan}!setReconnectBehavior@{setReconnectBehavior}}
\index{setReconnectBehavior@{setReconnectBehavior}!CSockCanScan@{CSockCanScan}}
\doxysubsubsection{\texorpdfstring{setReconnectBehavior()}{setReconnectBehavior()}}
{\footnotesize\ttfamily virtual void C\+Sock\+Can\+Scan\+::set\+Reconnect\+Behavior (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespaceCanModule_a2f4fee79cc7ba53467c2538fe6b9adbb}{Can\+Module\+::\+Reconnect\+Auto\+Condition}}}]{cond,  }\item[{\mbox{\hyperlink{namespaceCanModule_a2062089fa4fa87c8354295f2a8fe31a5}{Can\+Module\+::\+Reconnect\+Action}}}]{action }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

configuring the reconnection behavior\+: a condition triggers an action. The implementation is implementation-\/specific because not all vendor A\+P\+Is permit the same behavior\+: not all combinations are available for all vendors/implementations. The implemented reconnection behavior is standardized nevertheless\+: \char`\"{}you get what you see\char`\"{}. Foe each Can\+Bus you have to choose one condition and one action. Condition detection and action execution are then automatic inside \mbox{\hyperlink{namespaceCanModule}{Can\+Module}}.


\begin{DoxyParams}{Parameters}
{\em \mbox{\hyperlink{namespaceCanModule_a2f4fee79cc7ba53467c2538fe6b9adbb}{Can\+Module\+::\+Reconnect\+Auto\+Condition}}} & cond
\begin{DoxyItemize}
\item send\+Fail (default)\+: a reconnection is triggered automatically if a send on the can\+Bus fails. The number of failed sends can be set (default is 10). The failed sending must be strictly consecutive, if there is a succeeded sending, the internal counting restarts.
\item timeout\+On\+Reception\+: the last time of a successful reception on a given channel can be monitored. If the last reception is older than 120 sec a reset is triggered automatically. This last successful reception time is calculated each time a send is invoked. The timeout is specified in seconds, default is 120sec.
\item never\+: this condition is always false and therefore no automatic reconnection action will be triggered. You can still call the explicit method reconnect( $<$action$>$ ) but it is up to the client (server) to decide when.
\end{DoxyItemize}\\
\hline
{\em \mbox{\hyperlink{namespaceCanModule_a2062089fa4fa87c8354295f2a8fe31a5}{Can\+Module\+::\+Reconnect\+Action}}} & action
\begin{DoxyItemize}
\item single\+Bus (default)\+: a single connection (canbus, channel) is reset and reception handler is reconnected.
\item whole\+Bridge if available, the whole bridge is reset, affecting all physical channels on that bridge. Only available for anagate. If a bridge is shared between multiple tasks, all channels across tasks are reset, affecting all tasks connected to that bridge. Evidently, a given channel must only be used by at most one task. 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}


Implements \mbox{\hyperlink{classCanModule_1_1CCanAccess_ae1088edaf5444ff42ee094ae46240cc5}{Can\+Module\+::\+C\+Can\+Access}}.



Definition at line 114 of file Sock\+Can\+Scan.\+h.

\mbox{\Hypertarget{classCSockCanScan_aceab51e91b2c698211e5d563e4449c91}\label{classCSockCanScan_aceab51e91b2c698211e5d563e4449c91}} 
\index{CSockCanScan@{CSockCanScan}!setReconnectFailedSendCount@{setReconnectFailedSendCount}}
\index{setReconnectFailedSendCount@{setReconnectFailedSendCount}!CSockCanScan@{CSockCanScan}}
\doxysubsubsection{\texorpdfstring{setReconnectFailedSendCount()}{setReconnectFailedSendCount()}}
{\footnotesize\ttfamily virtual void C\+Sock\+Can\+Scan\+::set\+Reconnect\+Failed\+Send\+Count (\begin{DoxyParamCaption}\item[{unsigned int}]{c }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

set the counter for failed consecutive sending attempts, for reconnection. default is 10. 

Implements \mbox{\hyperlink{classCanModule_1_1CCanAccess_a665620fe5924cf87db0589a353d3d148}{Can\+Module\+::\+C\+Can\+Access}}.



Definition at line 119 of file Sock\+Can\+Scan.\+h.

\mbox{\Hypertarget{classCSockCanScan_afad122d886579de793f2b7b49e5c6d5f}\label{classCSockCanScan_afad122d886579de793f2b7b49e5c6d5f}} 
\index{CSockCanScan@{CSockCanScan}!setReconnectReceptionTimeout@{setReconnectReceptionTimeout}}
\index{setReconnectReceptionTimeout@{setReconnectReceptionTimeout}!CSockCanScan@{CSockCanScan}}
\doxysubsubsection{\texorpdfstring{setReconnectReceptionTimeout()}{setReconnectReceptionTimeout()}}
{\footnotesize\ttfamily virtual void C\+Sock\+Can\+Scan\+::set\+Reconnect\+Reception\+Timeout (\begin{DoxyParamCaption}\item[{unsigned int}]{timeout }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

set the timout interval for message reception, for the reconnection behaviour. Units is seconds, default is 120. 

Implements \mbox{\hyperlink{classCanModule_1_1CCanAccess_a3c902569c0712d165fc7e385e683dc95}{Can\+Module\+::\+C\+Can\+Access}}.



Definition at line 118 of file Sock\+Can\+Scan.\+h.

\mbox{\Hypertarget{classCSockCanScan_a7be2c075520b1cbf4baa4eb7d728fd2d}\label{classCSockCanScan_a7be2c075520b1cbf4baa4eb7d728fd2d}} 
\index{CSockCanScan@{CSockCanScan}!stopBus@{stopBus}}
\index{stopBus@{stopBus}!CSockCanScan@{CSockCanScan}}
\doxysubsubsection{\texorpdfstring{stopBus()}{stopBus()}}
{\footnotesize\ttfamily void C\+Sock\+Can\+Scan\+::stop\+Bus (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

notify the main thread to finish and delete the bus from the map of connections 

Implements \mbox{\hyperlink{classCanModule_1_1CCanAccess_a3fabe88b8e21638afd5d9886bb9c4aeb}{Can\+Module\+::\+C\+Can\+Access}}.



Definition at line 926 of file Sock\+Can\+Scan.\+cpp.



References m\+\_\+bus\+Map, m\+\_\+bus\+Name, m\+\_\+\+Can\+Scan\+Thread\+Run\+Enable\+Flag, m\+\_\+h\+Can\+Scan\+Thread, M\+L\+O\+G\+S\+O\+CK, and sock\+Reconnect\+Mutex.



Referenced by $\sim$\+C\+Sock\+Can\+Scan().

\mbox{\Hypertarget{classCSockCanScan_a623057580187ecb241adf143c64d711c}\label{classCSockCanScan_a623057580187ecb241adf143c64d711c}} 
\index{CSockCanScan@{CSockCanScan}!updateInitialError@{updateInitialError}}
\index{updateInitialError@{updateInitialError}!CSockCanScan@{CSockCanScan}}
\doxysubsubsection{\texorpdfstring{updateInitialError()}{updateInitialError()}}
{\footnotesize\ttfamily void C\+Sock\+Can\+Scan\+::update\+Initial\+Error (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}

Report an error when opening a can port 

Definition at line 959 of file Sock\+Can\+Scan.\+cpp.



References Can\+Module\+::\+C\+Can\+Access\+::can\+Message\+Error, clear\+Error\+Message(), Can\+Module\+::convert\+Timepoint\+To\+Timeval(), and m\+\_\+error\+Code.



Referenced by open\+Can\+Port().

Here is the call graph for this function\+:
% FIG 12


\doxysubsection{Member Data Documentation}
\mbox{\Hypertarget{classCSockCanScan_a7e4535b8435c633513fa1f9bd5a11ab7}\label{classCSockCanScan_a7e4535b8435c633513fa1f9bd5a11ab7}} 
\index{CSockCanScan@{CSockCanScan}!m\_busMap@{m\_busMap}}
\index{m\_busMap@{m\_busMap}!CSockCanScan@{CSockCanScan}}
\doxysubsubsection{\texorpdfstring{m\_busMap}{m\_busMap}}
{\footnotesize\ttfamily std\+::map$<$ std\+::string, std\+::string $>$ C\+Sock\+Can\+Scan\+::m\+\_\+bus\+Map\hspace{0.3cm}{\ttfamily [static]}}

Â© Copyright C\+E\+RN, 2015. All rights not expressly granted are reserved.

\mbox{\hyperlink{SockCanScan_8cpp}{Sock\+Can\+Scan.\+cpp}}

Created on\+: Jul 21, 2011 Based on work by vfilimon Rework and logging done by Piotr Nikiel \href{mailto:piotr@nikiel.info}{\texttt{ piotr@nikiel.\+info}} mludwig at cern dot ch

This file is part of Quasar.

Quasar is free software\+: you can redistribute it and/or modify it under the terms of the G\+NU Lesser General Public Licence as published by the Free Software Foundation, either version 3 of the Licence.

Quasar is distributed in the hope that it will be useful, but W\+I\+T\+H\+O\+UT A\+NY W\+A\+R\+R\+A\+N\+TY; without even the implied warranty of M\+E\+R\+C\+H\+A\+N\+T\+A\+B\+I\+L\+I\+TY or F\+I\+T\+N\+E\+SS F\+OR A P\+A\+R\+T\+I\+C\+U\+L\+AR P\+U\+R\+P\+O\+SE. See the G\+NU Lesser General Public Licence for more details.

You should have received a copy of the G\+NU Lesser General Public License along with Quasar. If not, see \href{http://www.gnu.org/licenses/}{\texttt{ http\+://www.\+gnu.\+org/licenses/}}. 

Definition at line 111 of file Sock\+Can\+Scan.\+h.



Referenced by create\+Bus(), and stop\+Bus().

\mbox{\Hypertarget{classCSockCanScan_a47b82a55c47a74e0918378baf82dd45a}\label{classCSockCanScan_a47b82a55c47a74e0918378baf82dd45a}} 
\index{CSockCanScan@{CSockCanScan}!m\_busName@{m\_busName}}
\index{m\_busName@{m\_busName}!CSockCanScan@{CSockCanScan}}
\doxysubsubsection{\texorpdfstring{m\_busName}{m\_busName}}
{\footnotesize\ttfamily std\+::string C\+Sock\+Can\+Scan\+::m\+\_\+bus\+Name\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 134 of file Sock\+Can\+Scan.\+h.



Referenced by create\+Bus(), and stop\+Bus().

\mbox{\Hypertarget{classCSockCanScan_ad77d913e61599d041a1237cfc169ef4d}\label{classCSockCanScan_ad77d913e61599d041a1237cfc169ef4d}} 
\index{CSockCanScan@{CSockCanScan}!m\_CanScanThreadRunEnableFlag@{m\_CanScanThreadRunEnableFlag}}
\index{m\_CanScanThreadRunEnableFlag@{m\_CanScanThreadRunEnableFlag}!CSockCanScan@{CSockCanScan}}
\doxysubsubsection{\texorpdfstring{m\_CanScanThreadRunEnableFlag}{m\_CanScanThreadRunEnableFlag}}
{\footnotesize\ttfamily volatile std\+::atomic\+\_\+bool C\+Sock\+Can\+Scan\+::m\+\_\+\+Can\+Scan\+Thread\+Run\+Enable\+Flag\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 125 of file Sock\+Can\+Scan.\+h.



Referenced by create\+Bus(), send\+Message(), and stop\+Bus().

\mbox{\Hypertarget{classCSockCanScan_a1810bdcb6beda833752d4ddb83efde7f}\label{classCSockCanScan_a1810bdcb6beda833752d4ddb83efde7f}} 
\index{CSockCanScan@{CSockCanScan}!m\_channelName@{m\_channelName}}
\index{m\_channelName@{m\_channelName}!CSockCanScan@{CSockCanScan}}
\doxysubsubsection{\texorpdfstring{m\_channelName}{m\_channelName}}
{\footnotesize\ttfamily std\+::string C\+Sock\+Can\+Scan\+::m\+\_\+channel\+Name\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 133 of file Sock\+Can\+Scan.\+h.



Referenced by configure\+Can\+Board(), and open\+Can\+Port().

\mbox{\Hypertarget{classCSockCanScan_a01a0096926dc8236ae11077deb5e02a2}\label{classCSockCanScan_a01a0096926dc8236ae11077deb5e02a2}} 
\index{CSockCanScan@{CSockCanScan}!m\_errorCode@{m\_errorCode}}
\index{m\_errorCode@{m\_errorCode}!CSockCanScan@{CSockCanScan}}
\doxysubsubsection{\texorpdfstring{m\_errorCode}{m\_errorCode}}
{\footnotesize\ttfamily int C\+Sock\+Can\+Scan\+::m\+\_\+error\+Code\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 129 of file Sock\+Can\+Scan.\+h.



Referenced by open\+Can\+Port(), and update\+Initial\+Error().

\mbox{\Hypertarget{classCSockCanScan_a344d3a2b2d61a0adbc364e980af7c740}\label{classCSockCanScan_a344d3a2b2d61a0adbc364e980af7c740}} 
\index{CSockCanScan@{CSockCanScan}!m\_hCanScanThread@{m\_hCanScanThread}}
\index{m\_hCanScanThread@{m\_hCanScanThread}!CSockCanScan@{CSockCanScan}}
\doxysubsubsection{\texorpdfstring{m\_hCanScanThread}{m\_hCanScanThread}}
{\footnotesize\ttfamily std\+::thread$\ast$ C\+Sock\+Can\+Scan\+::m\+\_\+h\+Can\+Scan\+Thread\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 132 of file Sock\+Can\+Scan.\+h.



Referenced by create\+Bus(), and stop\+Bus().

\mbox{\Hypertarget{classCSockCanScan_aa3406fed8265f9b21ae0b5de89bc3ce2}\label{classCSockCanScan_aa3406fed8265f9b21ae0b5de89bc3ce2}} 
\index{CSockCanScan@{CSockCanScan}!m\_logItHandleSock@{m\_logItHandleSock}}
\index{m\_logItHandleSock@{m\_logItHandleSock}!CSockCanScan@{CSockCanScan}}
\doxysubsubsection{\texorpdfstring{m\_logItHandleSock}{m\_logItHandleSock}}
{\footnotesize\ttfamily Log\+::\+Log\+Component\+Handle C\+Sock\+Can\+Scan\+::m\+\_\+log\+It\+Handle\+Sock\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 135 of file Sock\+Can\+Scan.\+h.



Referenced by configure\+Can\+Board(), and create\+Bus().

\mbox{\Hypertarget{classCSockCanScan_a7a476903f25b097ff4f5fc6031b55ffc}\label{classCSockCanScan_a7a476903f25b097ff4f5fc6031b55ffc}} 
\index{CSockCanScan@{CSockCanScan}!m\_sock@{m\_sock}}
\index{m\_sock@{m\_sock}!CSockCanScan@{CSockCanScan}}
\doxysubsubsection{\texorpdfstring{m\_sock}{m\_sock}}
{\footnotesize\ttfamily std\+::atomic\+\_\+int C\+Sock\+Can\+Scan\+::m\+\_\+sock\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 128 of file Sock\+Can\+Scan.\+h.



Referenced by Can\+Reconnection\+Thread(), clear\+Error\+Message(), create\+Bus(), open\+Can\+Port(), send\+Message(), and send\+Remote\+Request().

\mbox{\Hypertarget{classCSockCanScan_afe0c7cc23de0ac2d758a07bec4c2e2c8}\label{classCSockCanScan_afe0c7cc23de0ac2d758a07bec4c2e2c8}} 
\index{CSockCanScan@{CSockCanScan}!m\_statistics@{m\_statistics}}
\index{m\_statistics@{m\_statistics}!CSockCanScan@{CSockCanScan}}
\doxysubsubsection{\texorpdfstring{m\_statistics}{m\_statistics}}
{\footnotesize\ttfamily \mbox{\hyperlink{classCanModule_1_1CanStatistics}{Can\+Statistics}} C\+Sock\+Can\+Scan\+::m\+\_\+statistics\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 131 of file Sock\+Can\+Scan.\+h.



Referenced by C\+Sock\+Can\+Scan(), get\+Statistics(), open\+Can\+Port(), and send\+Remote\+Request().



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
Can\+Interface\+Implementations/sockcan/\mbox{\hyperlink{SockCanScan_8h}{Sock\+Can\+Scan.\+h}}\item 
Can\+Interface\+Implementations/sockcan/\mbox{\hyperlink{SockCanScan_8cpp}{Sock\+Can\+Scan.\+cpp}}\end{DoxyCompactItemize}
