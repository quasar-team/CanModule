%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
\edef\sphinxdqmaybe{\ifdefined\DeclareUnicodeCharacterAsOptional\string"\fi}
  \DeclareUnicodeCharacter{\sphinxdqmaybe00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Sonny]{fncychap}
\ChNameVar{\Large\normalfont\sffamily}
\ChTitleVar{\Large\normalfont\sffamily}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.\@ }}
\makeatletter
\def\fnum@figure{\figurename\thefigure{}}
\makeatother
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\makeatletter
\def\fnum@table{\tablename\thetable{}}
\makeatother
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}
\addto\captionsenglish{\renewcommand{\sphinxnonalphabeticalgroupname}{Non-alphabetical}}
\addto\captionsenglish{\renewcommand{\sphinxsymbolsname}{Symbols}}
\addto\captionsenglish{\renewcommand{\sphinxnumbersname}{Numbers}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{2}



\title{CanModule Developer Documentation}
\date{July 18, 2019}
\release{1.1.8}
\author{Michael Ludwig}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Downloading}
\label{\detokenize{downloading:downloading}}\label{\detokenize{downloading::doc}}

\section{The sources}
\label{\detokenize{downloading:the-sources}}
CanModule can be cloned from github, and are integrated in a cmake build chain:

the latest stable release (preferred):
git clone \sphinxstylestrong{-b latestStable} \sphinxurl{https://github.com/quasar-team/CanModule.git}

or

a specific version:
git clone \sphinxstylestrong{-b 1.1.0} \sphinxurl{https://github.com/quasar-team/CanModule.git}


\section{The binaries}
\label{\detokenize{downloading:the-binaries}}
(bin/exe) and libraries (so/dll) for the target platforms
\begin{itemize}
\item {} 
CERN CC7

\item {} 
windows 2016 server

\item {} 
windows 10

\item {} 
and windows 2008r2 (server) LEGACY

\end{itemize}

are available at \sphinxhref{https://repository.cern.ch/nexus/content/repositories/cern-can/}{NexusCan} from inside CERN.


\chapter{Quickstart}
\label{\detokenize{quickstart:quickstart}}\label{\detokenize{quickstart::doc}}
This is how to quick start CANX (if you know already what this is):
\begin{itemize}
\item {} 
download CANX and needed libs from \sphinxhref{https://repository.cern.ch/nexus/content/repositories/cern-can/}{nexus\_can} for your target platform

\item {} 
create a configuration file for CANX “to “play”. Download some examples from \sphinxhref{https://ics-fd-cpp-master.web.cern.ch/view/CAN/job/CANX-multi.cc7/lastSuccessfulBuild/artifact/}{jenkins\_can}
(Expand All-\textgreater{}View-\textgreater{}Config-\textgreater{}*.xml)

\item {} 
run it (on your target platform): CANX-tester -T -cfg ./myconfig.xml
enjoy the output

\end{itemize}
\begin{quote}
\end{quote}


\chapter{Objective}
\label{\detokenize{objective:objective}}\label{\detokenize{objective::doc}}
\sphinxstylestrong{CanModule} is a software abstraction layer, written in C++, to simplify integration
of CAN bridges from different vendors into cmake (C++) projects needing CAN connectivity
for windows and linux. A CAN bridge is - usually - an external module which is connected
on one side to a computer or network and offers CAN ports on the other side where CAN buses
can be connected.

The original authors are the CERN Atlas-DCS team, support is now done by BE-ICS-FD.


\section{Supported OS}
\label{\detokenize{objective:supported-os}}
These operating systems are supported for all vendors
\begin{itemize}
\item {} 
CERN CC7

\item {} 
Windows 2016 Server and Windows 10

\end{itemize}

other OS versions might be available on special request, or easily be ported to.


\section{compatible vendors}
\label{\detokenize{objective:compatible-vendors}}
CAN bridges from vendors are compatible with CanModule and are tested
\begin{itemize}
\item {} 
\sphinxhref{http://www.anagate.de/en/products/can-ethernet-gateways.htm}{AnaGate}

\item {} 
\sphinxhref{https://www.systec-electronic.com/}{SysTec}

\item {} 
\sphinxhref{https://www.peak-system.com/}{Peak}

\end{itemize}

These vendors produce many types of CAN bridges, \sphinxstylestrong{CanModule supports presently the USB (Peak, Systec)
and ethernet (Anagate) bridges}. Flexible datarate bridges (PEAK FD) and other interface types
(PEAK .m2 or also PCI) might be added if needed.


\section{Integration into projects}
\label{\detokenize{objective:integration-into-projects}}
In order to use CanModule in your  project/server/code there are two ways
\begin{itemize}
\item {} 
by source-clone from \sphinxhref{https://github.com/quasar-team/CanModule.git}{CanModuleGitlab} and integrated into a cmake build chain.

\item {} 
binaries to copy for other build chains are available CERN-wide from \sphinxhref{https://repository.cern.ch/nexus/content/repositories/cern-can/}{NexusCan} .

\end{itemize}


\chapter{Standard API}
\label{\detokenize{standardApi:standard-api}}\label{\detokenize{standardApi::doc}}
The user API is using \sphinxstylestrong{3 classes and hides all vendor specific details}.
Only a few common methods are needed:
\begin{itemize}
\item {} 
A \sphinxstylestrong{vendor is chosen} and specific details are then taken care of by loading any further dependencies:

\end{itemize}
\index{CanModule::CanLibLoader (C++ class)@\spxentry{CanModule::CanLibLoader}\spxextra{C++ class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{standardApi:_CPPv4N9CanModule12CanLibLoaderE}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{standardApi:classCanModule_1_1CanLibLoader}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{CanLibLoader}}}%
\pysigstopmultiline
Subclassed by CanModule::CanLibLoaderLin, CanModule::CanLibLoaderWin

\end{fulllineitems}

\begin{itemize}
\item {} 
Connection/access details to the \sphinxstylestrong{different vendors} are managed by sub-classing:

\end{itemize}
\index{CanModule::CCanAccess (C++ class)@\spxentry{CanModule::CCanAccess}\spxextra{C++ class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{standardApi:_CPPv4N9CanModule10CCanAccessE}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{standardApi:classCanModule_1_1CCanAccess}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{CCanAccess}}}%
\pysigstopmultiline
Subclassed by {\hyperref[\detokenize{vendors/anagate:classAnaCanScan}]{\sphinxcrossref{\DUrole{std,std-ref}{AnaCanScan}}}}, {\hyperref[\detokenize{vendors/systec:classCSockCanScan}]{\sphinxcrossref{\DUrole{std,std-ref}{CSockCanScan}}}}, MockCanAccess, {\hyperref[\detokenize{vendors/peak:classPKCanScan}]{\sphinxcrossref{\DUrole{std,std-ref}{PKCanScan}}}}, {\hyperref[\detokenize{vendors/systec:classSTCanScan}]{\sphinxcrossref{\DUrole{std,std-ref}{STCanScan}}}}

\end{fulllineitems}

\begin{itemize}
\item {} 
The \sphinxstylestrong{access to a CAN port} is through:

\end{itemize}
\index{CanModule::CanBusAccess (C++ class)@\spxentry{CanModule::CanBusAccess}\spxextra{C++ class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{standardApi:_CPPv4N9CanModule12CanBusAccessE}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{standardApi:classCanModule_1_1CanBusAccess}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{CanBusAccess}}}%
\pysigstopmultiline
{\hyperref[\detokenize{standardApi:classCanModule_1_1CanBusAccess}]{\sphinxcrossref{\DUrole{std,std-ref}{CanBusAccess}}}} class ensure a connection to can hardware. it can create the connection to different hardware at same time the syntax of the name is “name of component:name of the channel” 

\end{fulllineitems}

\begin{itemize}
\item {} 
This \sphinxstylestrong{snippet} gives an overview how the API is used to hide vendor details and achieve CAN connectivity:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{string} \PYG{n}{libName} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sock}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}         \PYG{c+c1}{// here: systec or peak through socketCan, linux}
\PYG{n}{string} \PYG{n}{port} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sock:can0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}       \PYG{c+c1}{// here: CAN port 0 via socket CAN, linux}
\PYG{n}{string} \PYG{n}{parameters} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Undefined}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;} \PYG{c+c1}{// here: use defaults}
\PYG{n}{CanMessage} \PYG{n}{cm}\PYG{p}{;}
\PYG{n}{CanModule}\PYG{o}{:}\PYG{o}{:}\PYG{n}{CanLibLoader} \PYG{o}{*}\PYG{n}{libloader} \PYG{o}{=} \PYG{n}{CanModule}\PYG{o}{:}\PYG{o}{:}\PYG{n}{CanLibLoader}\PYG{o}{:}\PYG{o}{:}\PYG{n}{createInstance}\PYG{p}{(} \PYG{n}{libName} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{cca} \PYG{o}{=} \PYG{n}{libloader}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{openCanBus}\PYG{p}{(} \PYG{n}{port}\PYG{p}{,} \PYG{n}{parameters} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{cca}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{sendMessage}\PYG{p}{(} \PYG{o}{\PYGZam{}}\PYG{n}{cm} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{cca}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{canMessageCame}\PYG{p}{.}\PYG{n}{connect}\PYG{p}{(} \PYG{o}{\PYGZam{}}\PYG{n}{onMessageRcvd} \PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// connect a reception handler}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Only two strings, “port” and “parameters”

\end{itemize}

have to defined to communicate with a CAN port for a module from a vendor.
\begin{itemize}
\item {} 
a connection handler method

\end{itemize}

must be registered to treat received messages (boost slot connected to boost signal):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{connection}\PYG{p}{.}\PYG{n+nl}{h} \PYG{p}{:}
\PYG{k}{class} \PYG{n+nc}{CONNECTION} \PYG{p}{\PYGZob{}}
   \PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}
   \PYG{k}{public}\PYG{o}{:}
      \PYG{k}{static} \PYG{k+kt}{void} \PYG{n}{onMessageRcvd}\PYG{p}{(}\PYG{k}{const} \PYG{n}{CanMsgStruct}\PYG{c+cm}{/*\PYGZam{}*/} \PYG{n}{message}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{connection}\PYG{p}{.}\PYG{n+nl}{cpp} \PYG{p}{:}
\PYG{c+cm}{/* static */} \PYG{k+kt}{void} \PYG{n}{CONNECTION}\PYG{o}{:}\PYG{o}{:}\PYG{n}{onMessageRcvd}\PYG{p}{(}\PYG{k}{const} \PYG{n}{CanMsgStruct}\PYG{c+cm}{/*\PYGZam{}*/} \PYG{n}{message}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{MYCLASS} \PYG{o}{*}\PYG{n}{myObject} \PYG{o}{=} \PYG{n}{MYCLASS}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getMyObject}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}\PYG{p}{;}
   \PYG{n}{myObject}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{processReceivedMessage}\PYG{p}{(} \PYG{n}{message} \PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
you can take a look at \sphinxhref{https://gitlab.cern.ch/mludwig/canx.git}{CANX} for a full multithreaded example using CanModule (CERN, gitlab)

\end{itemize}


\chapter{C-Wrapper}
\label{\detokenize{cwrapper:c-wrapper}}\label{\detokenize{cwrapper::doc}}
in order to call \sphinxstylestrong{CanModule} also from low-level vendor specific code, which is often implemented
in C, CanModule has a C-wrapper as well. The objective is to call the C++ objects of CanModule
from C-code. Still, a C++ compiler is needed for the build, but this type of
compiler is usually downward compatible to C.


\chapter{SysTec}
\label{\detokenize{vendors/systec:systec}}\label{\detokenize{vendors/systec::doc}}
All modules from vendor {\hyperref[\detokenize{vendors/systec:systec}]{\sphinxcrossref{SysTec}}} are handled by class STCanScan (windows) or CSockCanScan (linux) which
manage the modules through their underlying vendor specific API and provide the standard generic CanModule API.
Here the underlying vendor specific classes and the specific parameters are documented.

SysTec modules USB-CAN bridges are supported: sysWORXX 1,2,8,16


\section{The connection}
\label{\detokenize{vendors/systec:the-connection}}
To connect to a specific port for I/O, and send CAN messages, the following methods are used.


\subsection{windows}
\label{\detokenize{vendors/systec:windows}}
The connection to a specific port for I/O is created by calling
\index{STCanScan (C++ class)@\spxentry{STCanScan}\spxextra{C++ class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vendors/systec:_CPPv49STCanScan}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{vendors/systec:classSTCanScan}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{STCanScan}} : \sphinxbfcode{\sphinxupquote{public}} CanModule::{\hyperref[\detokenize{standardApi:_CPPv4N9CanModule10CCanAccessE}]{\sphinxcrossref{CCanAccess}}}}%
\pysigstopmultiline~\subsubsection*{Public Functions}
\index{STCanScan::createBus (C++ function)@\spxentry{STCanScan::createBus}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vendors/systec:_CPPv4N9STCanScan9createBusEK6stringK6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{vendors/systec:classSTCanScan_1aa99f9f23bdfd367a51efc40e228a6f88}}\pysiglinewithargsret{bool \sphinxbfcode{\sphinxupquote{createBus}}}{\sphinxbfcode{\sphinxupquote{const}} string \sphinxstyleemphasis{name}, \sphinxbfcode{\sphinxupquote{const}} string \sphinxstyleemphasis{parameters}}{}%
\pysigstopmultiline
Method that initialises a CAN bus channel for systec. All following methods called on the same object will be using this initialized channel.

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
was the initialisation process successful? 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{name}}: = 2 parameters separated by “:” like “n0:n1”\begin{itemize}
\item {} 
n0 = “st” for systec

\item {} 
n1 = CAN port number on the module, can be prefixed with “can”

\item {} 
ex.: “st:can1” speaks to port 1 on systec module at the ip

\item {} 
ex.: “st:1” works as well

\end{itemize}


\item {} 
\sphinxcode{\sphinxupquote{parameters}}: one parameter: “p0”, positive integers\begin{itemize}
\item {} 
”Unspecified” (or empty): using defaults = “125000” // params missing

\item {} 
p0: bitrate: 50000, 100000, 125000, 250000, 500000, 1000000 bit/s i.e. “250000”

\end{itemize}


\end{itemize}

\end{description}


\end{fulllineitems}

\index{STCanScan::sendMessage (C++ function)@\spxentry{STCanScan::sendMessage}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vendors/systec:_CPPv4N9STCanScan11sendMessageEshPhb}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{vendors/systec:classSTCanScan_1a45f0ec011022bf58a23e8370bac7f829}}\pysiglinewithargsret{bool \sphinxbfcode{\sphinxupquote{sendMessage}}}{short \sphinxstyleemphasis{cobID}, unsigned char \sphinxstyleemphasis{len}, unsigned char *\sphinxstyleemphasis{message}, bool \sphinxstyleemphasis{rtr} = false}{}%
\pysigstopmultiline
Method that sends a message trough the can bus channel. If the method createBUS was not called before this, sendMessage will fail, as there is no can bus channel to send a message through.

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
Was the sending process successful? 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{cobID}}: Identifier that will be used for the message. 

\item {} 
\sphinxcode{\sphinxupquote{len}}: Length of the message. If the message is bigger than 8 characters, it will be split into separate 8 characters messages. 

\item {} 
\sphinxcode{\sphinxupquote{message}}: Message to be sent trough the can bus. 

\item {} 
\sphinxcode{\sphinxupquote{rtr}}: is the message a remote transmission request? 

\end{itemize}

\end{description}


\end{fulllineitems}


\end{fulllineitems}


and communication takes place through systec’s closed-source windows library.


\subsection{linux}
\label{\detokenize{vendors/systec:linux}}
The open-source socketcan interface is used on top of systec’s open source driver:
\index{CSockCanScan (C++ class)@\spxentry{CSockCanScan}\spxextra{C++ class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vendors/systec:_CPPv412CSockCanScan}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{vendors/systec:classCSockCanScan}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{CSockCanScan}} : \sphinxbfcode{\sphinxupquote{public}} CanModule::{\hyperref[\detokenize{standardApi:_CPPv4N9CanModule10CCanAccessE}]{\sphinxcrossref{CCanAccess}}}}%
\pysigstopmultiline~\subsubsection*{Public Functions}
\index{CSockCanScan::createBus (C++ function)@\spxentry{CSockCanScan::createBus}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vendors/systec:_CPPv4N12CSockCanScan9createBusEK6string6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{vendors/systec:classCSockCanScan_1ac5c669f96d2d6cf7387f8a646bd65b3f}}\pysiglinewithargsret{bool \sphinxbfcode{\sphinxupquote{createBus}}}{\sphinxbfcode{\sphinxupquote{const}} string \sphinxstyleemphasis{name}, string \sphinxstyleemphasis{parameters}}{}%
\pysigstopmultiline
Method that initializes a can bus channel. The following methods called upon the same object will be using this initialized channel.

\begin{itemize}
\item {} 
i.e. “250000”

\end{itemize}
\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{name}}: = 2 parameters separated by “:”, like “n0:n1”\begin{itemize}
\item {} 
n0 = “sock” for sockets, used by systec and peak

\item {} 
n1 = CAN port number on the module, can be prefixed with “can”

\item {} 
ex.: “sock:can1” speaks to port 1 on systec or peak module

\item {} 
ex.: “sock:1” works as well

\end{itemize}


\item {} 
\sphinxcode{\sphinxupquote{parameters}}: one parameter: “p0”, positive integer\begin{itemize}
\item {} 
”Unspecified” (or empty): using defaults = “125000” // params missing

\item {} 
p0: bitrate: 50000, 100000, 125000, 250000, 500000, 1000000 bit/s, other values might be allowed by the module

\end{itemize}


\end{itemize}

\end{description}


\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
Was the initialization process successful? 

\end{description}


\end{fulllineitems}

\index{CSockCanScan::sendMessage (C++ function)@\spxentry{CSockCanScan::sendMessage}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vendors/systec:_CPPv4N12CSockCanScan11sendMessageEshPhb}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{vendors/systec:classCSockCanScan_1a485ec8621a98cdacad8e27433e09d919}}\pysiglinewithargsret{bool \sphinxbfcode{\sphinxupquote{sendMessage}}}{short \sphinxstyleemphasis{cobID}, unsigned char \sphinxstyleemphasis{len}, unsigned char *\sphinxstyleemphasis{message}, bool \sphinxstyleemphasis{rtr} = false}{}%
\pysigstopmultiline
Method that sends a message trough the can bus channel. If the method createBUS was not called before this, sendMessage will fail, as there is no can bus channel to send a message through.

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
Was the initialisation process successful? 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{cobID}}: Identifier that will be used for the message. 

\item {} 
\sphinxcode{\sphinxupquote{len}}: Length of the message. If the message is bigger than 8 characters, it will be split into separate 8 characters messages. 

\item {} 
\sphinxcode{\sphinxupquote{message}}: Message to be sent trough the can bus. 

\item {} 
\sphinxcode{\sphinxupquote{rtr}}: is the message a remote transmission request? 

\end{itemize}

\end{description}


\end{fulllineitems}


\end{fulllineitems}


sockets are used normally, using linux’ built-in CAN protocols:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mysock} \PYG{o}{=} \PYG{n}{socket}\PYG{p}{(}\PYG{n}{domain}\PYG{o}{=}\PYG{n}{PF\PYGZus{}CAN}\PYG{p}{,} \PYG{n}{type}\PYG{o}{=}\PYG{n}{SOCK\PYGZus{}RAW}\PYG{p}{,} \PYG{n}{protocol}\PYG{o}{=}\PYG{n}{CAN\PYGZus{}RAW}\PYG{p}{)}
\end{sphinxVerbatim}


\section{standard CanModule API example}
\label{\detokenize{vendors/systec:standard-canmodule-api-example}}
This is how the CanModule standard API is used for systec for linux.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{libloader} \PYG{o}{=} \PYG{n}{CanModule}\PYG{o}{:}\PYG{o}{:}\PYG{n}{CanLibLoader}\PYG{o}{:}\PYG{o}{:}\PYG{n}{createInstance}\PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sock}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// linux, use \PYGZdq{}st\PYGZdq{} for windows}
\PYG{n}{cca} \PYG{o}{=} \PYG{n}{libloader}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{openCanBus}\PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sock:can0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{250000}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// termination on frontpanel}
\PYG{n}{CanMessage} \PYG{n}{cm}\PYG{p}{;} \PYG{c+c1}{// empty}
\PYG{n}{cca}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{sendMessage}\PYG{p}{(} \PYG{o}{\PYGZam{}}\PYG{n}{cm} \PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\chapter{AnaGate}
\label{\detokenize{vendors/anagate:anagate}}\label{\detokenize{vendors/anagate::doc}}
All modules from vendor {\hyperref[\detokenize{vendors/anagate:anagate}]{\sphinxcrossref{AnaGate}}} are handled by class AnaCanScan which manages the modules through their underlying vendor specific API and provides
the standard generic CanModule API.

We support Anagate CAN-ethernet gateways: uno, duo, quattro, and the X2, X4 and X8.

Since these modules communicate to the host computer only via ethernet, at the fundamental level only classical
tcp/ip ethernet is needed. Nevertheless the specific contents of the IP frames are wrapped up in an Anagate API for convenience, which is linked
into the user code as a library. There are therefore no implementation differences between Linux and Windows.
Here the underlying vendor specific classes and the specific parameters are documented.

The downside of Anagate CAN-ethernet modules is of course that the latency of the network has to be added to the bridge latency.


\section{The connection}
\label{\detokenize{vendors/anagate:the-connection}}
To connect to a specific port for I/O, and send CAN messages, the following methods are used.
\index{AnaCanScan (C++ class)@\spxentry{AnaCanScan}\spxextra{C++ class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vendors/anagate:_CPPv410AnaCanScan}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{vendors/anagate:classAnaCanScan}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{AnaCanScan}} : \sphinxbfcode{\sphinxupquote{public}} CanModule::{\hyperref[\detokenize{standardApi:_CPPv4N9CanModule10CCanAccessE}]{\sphinxcrossref{CCanAccess}}}}%
\pysigstopmultiline~\subsubsection*{Public Functions}
\index{AnaCanScan::createBus (C++ function)@\spxentry{AnaCanScan::createBus}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vendors/anagate:_CPPv4N10AnaCanScan9createBusEK6stringK6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{vendors/anagate:classAnaCanScan_1a54a66154c956b4605ff18f93f552db60}}\pysiglinewithargsret{bool \sphinxbfcode{\sphinxupquote{createBus}}}{\sphinxbfcode{\sphinxupquote{const}} string \sphinxstyleemphasis{name}, \sphinxbfcode{\sphinxupquote{const}} string \sphinxstyleemphasis{parameters}}{}%
\pysigstopmultiline
Method that initialises a CAN bus channel for anagate. All following methods called on the same object will be using this initialized channel.

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
was the initialisation process successful? 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{name}}: 3 parameters separated by “:” like “n0:n1:n2” n0 = “an” for anagate n1 = port number on the module, 0=A, 1=B, etc etc n2 = ip number ex.: “an:can1:137.138.12.99” speaks to port B (=1) on anagate module at the ip ex.: “an:1:137.138.12.99” works as well

\item {} 
\sphinxcode{\sphinxupquote{parameters}}: up to 6 parameters separated by whitespaces : “p0 p1 p2 p3 p4 p5” in THAT order, positive integers\begin{itemize}
\item {} 
”Unspecified” (or empty): using defaults = “125000 0 0 0 0 0” // all params missing

\item {} 
p0: bitrate: 10000, 20000, 50000, 62000, 100000, 125000, 250000, 500000, 800000, 1000000 bit/s

\item {} 
p1: operatingMode: 0=default mode, values 1 (loop back) and 2 (listen) are not supported by CanModule

\item {} 
p2: termination: 0=not terminated (default), 1=terminated (120 Ohm for CAN bus)

\item {} 
p3: highSpeed: 0=deactivated (default), 1=activated. If activated, confirmation and filtering of CAN traffic are switched off

\item {} 
p4: TimeStamp: 0=deactivated (default), 1=activated. If activated, a timestamp is added to the CAN frame. Not all modules support this.

\item {} 
p5: syncMode: 0=default, unused but reserved for future use i.e. “250000 0 1 0 0 1” (see anagate manual for more details)

\end{itemize}


\end{itemize}

\end{description}


\end{fulllineitems}

\index{AnaCanScan::sendMessage (C++ function)@\spxentry{AnaCanScan::sendMessage}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vendors/anagate:_CPPv4N10AnaCanScan11sendMessageEshPhb}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{vendors/anagate:classAnaCanScan_1ad45666454318c891d7acd9fe16ae4c49}}\pysiglinewithargsret{bool \sphinxbfcode{\sphinxupquote{sendMessage}}}{short \sphinxstyleemphasis{cobID}, unsigned char \sphinxstyleemphasis{len}, unsigned char *\sphinxstyleemphasis{message}, bool \sphinxstyleemphasis{rtr} = false}{}%
\pysigstopmultiline
send a CAN message frame (8 byte) for anagate Method that sends a message through the can bus channel. If the method createBus was not called before this, sendMessage will fail, as there is no can bus channel to send a message trough. \begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
Was the sending process successful? 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{cobID:}}: Identifier that will be used for the message. 

\item {} 
\sphinxcode{\sphinxupquote{len:}}: Length of the message. If the message is bigger than 8 characters, it will be split into separate 8 characters messages. 

\item {} 
\sphinxcode{\sphinxupquote{message:}}: Message to be sent trough the can bus. 

\item {} 
\sphinxcode{\sphinxupquote{rtr:}}: is the message a remote transmission request? 

\end{itemize}

\end{description}


\end{fulllineitems}


\end{fulllineitems}



\section{standard CanModule API example}
\label{\detokenize{vendors/anagate:standard-canmodule-api-example}}
This is how the CanModule standard API is used for anagate. The code is identical for linux and windows.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{libloader} \PYG{o}{=} \PYG{n}{CanModule}\PYG{o}{:}\PYG{o}{:}\PYG{n}{CanLibLoader}\PYG{o}{:}\PYG{o}{:}\PYG{n}{createInstance}\PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{an}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{cca} \PYG{o}{=} \PYG{n}{libloader}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{openCanBus}\PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{an:can0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{250000 0 1}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// termination, ISEG controllers, p3, p4, p5 defaults}
\PYG{n}{CanMessage} \PYG{n}{cm}\PYG{p}{;} \PYG{c+c1}{// empty}
\PYG{n}{cca}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{sendMessage}\PYG{p}{(} \PYG{o}{\PYGZam{}}\PYG{n}{cm} \PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\chapter{Peak}
\label{\detokenize{vendors/peak:peak}}\label{\detokenize{vendors/peak::doc}}
All modules from vendor {\hyperref[\detokenize{vendors/peak:peak}]{\sphinxcrossref{Peak}}} are handled by class PKCanScan (windows) or CSockCanScan (linux) which
both manage the modules through their underlying vendor specific API according to the OS.
Both classes provide the standard generic CanModule API.
Here the underlying vendor specific classes and the specific parameters are documented.

The modules from the families PCAN USB and USB Pro are supported.


\section{The connection}
\label{\detokenize{vendors/peak:the-connection}}
To connect to a specific port for I/O, and send CAN messages, the following methods are used.


\subsection{windows}
\label{\detokenize{vendors/peak:windows}}
the connection to a specific port for I/O is created by calling
\index{PKCanScan (C++ class)@\spxentry{PKCanScan}\spxextra{C++ class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vendors/peak:_CPPv49PKCanScan}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{vendors/peak:classPKCanScan}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{PKCanScan}} : \sphinxbfcode{\sphinxupquote{public}} CanModule::{\hyperref[\detokenize{standardApi:_CPPv4N9CanModule10CCanAccessE}]{\sphinxcrossref{CCanAccess}}}}%
\pysigstopmultiline~\subsubsection*{Public Functions}
\index{PKCanScan::createBus (C++ function)@\spxentry{PKCanScan::createBus}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vendors/peak:_CPPv4N9PKCanScan9createBusEK6stringK6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{vendors/peak:classPKCanScan_1ae91999b9316ca127eecbabd9f27c3137}}\pysiglinewithargsret{bool \sphinxbfcode{\sphinxupquote{createBus}}}{\sphinxbfcode{\sphinxupquote{const}} string \sphinxstyleemphasis{name}, \sphinxbfcode{\sphinxupquote{const}} string \sphinxstyleemphasis{parameters}}{}%
\pysigstopmultiline
Method that initialises a CAN bus channel for peak (using PEAK Basic) All following methods called on the same object will be using this initialized channel. Only USB interfaces for PEAK modules, and only NON FD modules are supported for now.

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
was the initialisation process successful? 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{name}}: = 2 parameters separated by “:” like “n0:n1”\begin{itemize}
\item {} 
n0 = “pk” for peak

\item {} 
n1 = CAN port number on the module, can be prefixed with “can”: 0..N

\item {} 
ex.: “pk:can1” speaks to port 1 (the second port) on peak module at the ip

\item {} 
ex.: “pk:1” works as well

\end{itemize}


\item {} 
\sphinxcode{\sphinxupquote{parameters}}: one parameter: “p0”, positive integer\begin{itemize}
\item {} 
”Unspecified” (or empty): using defaults = “125000” // params missing

\item {} 
p0: bitrate: 50000, 100000, 125000, 250000, 500000, 1000000 bit/s i.e. “250000”

\end{itemize}


\end{itemize}

\end{description}


\end{fulllineitems}

\index{PKCanScan::sendMessage (C++ function)@\spxentry{PKCanScan::sendMessage}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vendors/peak:_CPPv4N9PKCanScan11sendMessageEshPhb}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{vendors/peak:classPKCanScan_1a48a2e9ba00dae1b1fe01f7b095430503}}\pysiglinewithargsret{bool \sphinxbfcode{\sphinxupquote{sendMessage}}}{short \sphinxstyleemphasis{cobID}, unsigned char \sphinxstyleemphasis{len}, unsigned char *\sphinxstyleemphasis{message}, bool \sphinxstyleemphasis{rtr} = false}{}%
\pysigstopmultiline
method to send a CAN message to the peak module. we use the standard API “PCAN-Basic” for this for windows and we talk only over USB to fixed bitrate modules. The flexible bitrate (FD) modules can be implemented later as well: for this we need more parameters to pass and a switch between CAN\_Write and CAN\_WriteFD. 

\end{fulllineitems}


\end{fulllineitems}


and communication takes place through peak’s open-source PCAN-Basic windows library. Only “plug-and-play”
modules with USB interface and fixed datarate are supported by CanModule for now. PEAK’s flexible datarate (FD)
modules can be added later on (they need some different API-calls and more complex parameters), and also
other interfaces like PCI are possible for windows.The implementation is based on the PCAN-Basic driver.


\subsection{linux}
\label{\detokenize{vendors/peak:linux}}
The open-source socketcan interface is used on top of peak’s open source netdev driver. Both Peak’s
fixed and flexible datarate are working, although the fixed modules are recommended for bus compatibility.
Only modules with USB interface are supported.
The peak driver source is freely available and it can be configured to build several
types of drivers, where we use peak’s netdev driver only. See \sphinxhref{https://readthedocs.web.cern.ch/display/CANDev/CAN+development?src=sidebar}{PeakDriver} for details on this.
A PCAN-Basic driver is also available but the netdev driver is more performant and modern. The
PCAN-Basic driver is used nevertheless for windows, and it offers better compatibility for all module
families.
\index{CSockCanScan (C++ class)@\spxentry{CSockCanScan}\spxextra{C++ class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vendors/peak:_CPPv412CSockCanScan}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{vendors/peak:classCSockCanScan}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{CSockCanScan}} : \sphinxbfcode{\sphinxupquote{public}} CanModule::{\hyperref[\detokenize{standardApi:_CPPv4N9CanModule10CCanAccessE}]{\sphinxcrossref{CCanAccess}}}}%
\pysigstopmultiline~\subsubsection*{Public Functions}
\index{CSockCanScan::createBus (C++ function)@\spxentry{CSockCanScan::createBus}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vendors/peak:_CPPv4N12CSockCanScan9createBusEK6string6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{vendors/peak:classCSockCanScan_1ac5c669f96d2d6cf7387f8a646bd65b3f}}\pysiglinewithargsret{bool \sphinxbfcode{\sphinxupquote{createBus}}}{\sphinxbfcode{\sphinxupquote{const}} string \sphinxstyleemphasis{name}, string \sphinxstyleemphasis{parameters}}{}%
\pysigstopmultiline
Method that initializes a can bus channel. The following methods called upon the same object will be using this initialized channel.

\begin{itemize}
\item {} 
i.e. “250000”

\end{itemize}
\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{name}}: = 2 parameters separated by “:”, like “n0:n1”\begin{itemize}
\item {} 
n0 = “sock” for sockets, used by systec and peak

\item {} 
n1 = CAN port number on the module, can be prefixed with “can”

\item {} 
ex.: “sock:can1” speaks to port 1 on systec or peak module

\item {} 
ex.: “sock:1” works as well

\end{itemize}


\item {} 
\sphinxcode{\sphinxupquote{parameters}}: one parameter: “p0”, positive integer\begin{itemize}
\item {} 
”Unspecified” (or empty): using defaults = “125000” // params missing

\item {} 
p0: bitrate: 50000, 100000, 125000, 250000, 500000, 1000000 bit/s, other values might be allowed by the module

\end{itemize}


\end{itemize}

\end{description}


\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
Was the initialization process successful? 

\end{description}


\end{fulllineitems}

\index{CSockCanScan::sendMessage (C++ function)@\spxentry{CSockCanScan::sendMessage}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vendors/peak:_CPPv4N12CSockCanScan11sendMessageEshPhb}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{vendors/peak:classCSockCanScan_1a485ec8621a98cdacad8e27433e09d919}}\pysiglinewithargsret{bool \sphinxbfcode{\sphinxupquote{sendMessage}}}{short \sphinxstyleemphasis{cobID}, unsigned char \sphinxstyleemphasis{len}, unsigned char *\sphinxstyleemphasis{message}, bool \sphinxstyleemphasis{rtr} = false}{}%
\pysigstopmultiline
Method that sends a message trough the can bus channel. If the method createBUS was not called before this, sendMessage will fail, as there is no can bus channel to send a message through.

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
Was the initialisation process successful? 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{cobID}}: Identifier that will be used for the message. 

\item {} 
\sphinxcode{\sphinxupquote{len}}: Length of the message. If the message is bigger than 8 characters, it will be split into separate 8 characters messages. 

\item {} 
\sphinxcode{\sphinxupquote{message}}: Message to be sent trough the can bus. 

\item {} 
\sphinxcode{\sphinxupquote{rtr}}: is the message a remote transmission request? 

\end{itemize}

\end{description}


\end{fulllineitems}


\end{fulllineitems}


sockets are used normally, using linux’ built-in CAN protocols:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mysock} \PYG{o}{=} \PYG{n}{socket}\PYG{p}{(}\PYG{n}{domain}\PYG{o}{=}\PYG{n}{PF\PYGZus{}CAN}\PYG{p}{,} \PYG{n}{type}\PYG{o}{=}\PYG{n}{SOCK\PYGZus{}RAW}\PYG{p}{,} \PYG{n}{protocol}\PYG{o}{=}\PYG{n}{CAN\PYGZus{}RAW}\PYG{p}{)}
\end{sphinxVerbatim}


\section{standard CanModule API example}
\label{\detokenize{vendors/peak:standard-canmodule-api-example}}
This is how the CanModule standard API is used for peak for windows.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{libloader} \PYG{o}{=} \PYG{n}{CanModule}\PYG{o}{:}\PYG{o}{:}\PYG{n}{CanLibLoader}\PYG{o}{:}\PYG{o}{:}\PYG{n}{createInstance}\PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{pk}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// windows, use \PYGZdq{}sock\PYGZdq{} for linux}
\PYG{n}{cca} \PYG{o}{=} \PYG{n}{libloader}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{openCanBus}\PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{pk:can0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{250000}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// termination on frontpanel}
\PYG{n}{CanMessage} \PYG{n}{cm}\PYG{p}{;} \PYG{c+c1}{// empty}
\PYG{n}{cca}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{sendMessage}\PYG{p}{(} \PYG{o}{\PYGZam{}}\PYG{n}{cm} \PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\chapter{Logging}
\label{\detokenize{logging:logging}}\label{\detokenize{logging::doc}}
CanModule uses \sphinxhref{https://github.com/quasar-team/LogIt}{LogIt} for reporting information during runtime. LogIt uses one component “CanModule”
\begin{itemize}
\item {} 
CanModule: general messages concerning CanModule itself

\item {} 
CanModule Anagate: messages related to AnaGate modules contain a string “anagate”

\item {} 
CanModule Systec: messages related to SysTec modules contain a string “systec”

\item {} 
CanModule Peak: messages related to Peak modules contain a string “peak”

\end{itemize}

for managing logging levels. The logging level of each component, if the component is used, can be set individually
at any time once initialized. Vendor specific messages can be filtered out by using the specific strings.
For windows the strings are as listed above, for linux the string “sock” is used for Systec and Peak modules.

You can of course add your own components for specific logging, like MYCOMP in the code below.

\sphinxstylestrong{The calling program (“main”) uses CanModule and LogIt like this}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}CanBusAccess.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}LogIt.h\PYGZgt{}}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LogComponentHandle} \PYG{n}{myHandle} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LogComponentHandle} \PYG{n}{canModuleHandle} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LOG\PYGZus{}LEVEL} \PYG{n}{loglevel} \PYG{o}{=} \PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{INF}\PYG{p}{;}    \PYG{c+c1}{// recommended default for production is WRN}
\PYG{k+kt}{bool} \PYG{n}{ret} \PYG{o}{=} \PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{initializeLogging}\PYG{p}{(} \PYG{n}{loglevel} \PYG{p}{)}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(} \PYG{n}{ret} \PYG{p}{)}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{LogIt initialized OK}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{k}{else}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{LogIt problem at initialisation}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setNonComponentLogLevel}\PYG{p}{(} \PYG{n}{loglevel} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Log level set to }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{loglevel} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{n}{LogItInstance} \PYG{o}{*}\PYG{n}{logIt} \PYG{o}{=} \PYG{n}{LogItInstance}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getInstance}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{c+cm}{/**}
\PYG{c+cm}{ * LogIt component MYCOMP for main}
\PYG{c+cm}{ */}
\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{registerLoggingComponent}\PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MYCOMP}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{loglevel} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{logIt}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getComponentHandle}\PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MYCOMP}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{myHandle} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setComponentLogLevel}\PYG{p}{(} \PYG{n}{myHandle}\PYG{p}{,} \PYG{n}{loglevel} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{LOG}\PYG{p}{(}\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{INF}\PYG{p}{,} \PYG{n}{myHandle}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{argv}\PYG{p}{[} \PYG{l+m+mi}{0} \PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ logging for component MYCOMP}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{c+c1}{// hourray, we should see this message because we are at INF}

\PYG{c+cm}{/**}
\PYG{c+cm}{ * LogIt component CanModule}
\PYG{c+cm}{ */}
\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{registerLoggingComponent}\PYG{p}{(} \PYG{n}{CanModule}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LogItComponentName}\PYG{p}{,} \PYG{n}{loglevel} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{logIt}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getComponentHandle}\PYG{p}{(}\PYG{n}{CanModule}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LogItComponentName}\PYG{p}{,} \PYG{n}{canModuleHandle} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setComponentLogLevel}\PYG{p}{(} \PYG{n}{canModuleHandle}\PYG{p}{,} \PYG{n}{loglevel} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{LOG}\PYG{p}{(}\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{INF}\PYG{p}{,} \PYG{n}{canModuleHandle}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ logging for component }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{CanModule}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LogItComponentName}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxstylestrong{then, some work is done i.e. like that:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// do sth useful with CanModule, i.e. talk to a port}
\PYG{n}{string} \PYG{n}{libName} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{st}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}           \PYG{c+c1}{// here: systec, windows}
\PYG{n}{string} \PYG{n}{port} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{st:can0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}         \PYG{c+c1}{// here: CAN port 0, windows}
\PYG{n}{string} \PYG{n}{parameters} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Undefined}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;} \PYG{c+c1}{// here: use defaults}
\PYG{n}{CanMessage} \PYG{n}{cm}\PYG{p}{;}
\PYG{n}{CanModule}\PYG{o}{:}\PYG{o}{:}\PYG{n}{CanLibLoader} \PYG{o}{*}\PYG{n}{libloader} \PYG{o}{=} \PYG{n}{CanModule}\PYG{o}{:}\PYG{o}{:}\PYG{n}{CanLibLoader}\PYG{o}{:}\PYG{o}{:}\PYG{n}{createInstance}\PYG{p}{(} \PYG{n}{libName} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{cca} \PYG{o}{=} \PYG{n}{libloader}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{openCanBus}\PYG{p}{(} \PYG{n}{port}\PYG{p}{,} \PYG{n}{parameters} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{cca}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{sendMessage}\PYG{p}{(} \PYG{o}{\PYGZam{}}\PYG{n}{cm} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{cca}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{canMessageCame}\PYG{p}{.}\PYG{n}{connect}\PYG{p}{(} \PYG{o}{\PYGZam{}}\PYG{n}{onMessageRcvd} \PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// connect a reception handler, see standardApi for details}
\end{sphinxVerbatim}

\sphinxstylestrong{and at any time the logging levels of the components can be changed. This is typically done by a user interaction
on a running server instance.}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/**}
\PYG{c+cm}{ * manipulate LogIt levels per component for testing, during runtime. Set loglevel to TRC (max verbosity)}
\PYG{c+cm}{ */}
\PYG{n}{loglevel} \PYG{o}{=} \PYG{n}{LOG}\PYG{o}{:}\PYG{o}{:}\PYG{n}{TRC}\PYG{p}{;}
\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LogComponentHandle} \PYG{n}{handle}\PYG{p}{;}
\PYG{n}{logIt}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getComponentHandle}\PYG{p}{(}\PYG{n}{CanModule}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LogItComponentName}\PYG{p}{,} \PYG{n}{handle} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setComponentLogLevel}\PYG{p}{(} \PYG{n}{handle}\PYG{p}{,} \PYG{n}{loglevel} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{LOG}\PYG{p}{(}\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{INF}\PYG{p}{,} \PYG{n}{handle}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ logging for component }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{CanModule}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LogItComponentName}\PYG{p}{;}
\end{sphinxVerbatim}


\chapter{Building}
\label{\detokenize{building:building}}\label{\detokenize{building::doc}}
We use \sphinxhref{https://cmake.org/}{cmake} 2.8 or higher for multi-OS building.
The dependencies are:
\begin{itemize}
\item {} 
xerces-c

\item {} 
boost (1.64.0 preferred, but any version \textgreater{}=1.59.0 should work)

\item {} 
socketcan libs (CC7) (not to be confused with the CanModule sockcan.so lib!)

\item {} 
dependencies for CanModule: LogIt (sources gto github pulled in by cmake)

\item {} 
vendor libs (to be installed on your build/target machine)

\item {} \begin{description}
\item[{you will have to switch off vendor builds if you want ONLY mockup, using the toolchain}] \leavevmode\begin{itemize}
\item {} 
SET( CANMODULE\_BUILD\_VENDORS “OFF”)

\item {} 
default is “ON”

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{you can switch off selected vendor which you do not need using the toolchain}] \leavevmode\begin{itemize}
\item {} 
SET(CANMODULE\_BUILD\_SYSTEC “OFF”)

\item {} 
SET(CANMODULE\_BUILD\_ANAGATE “OFF”)

\item {} 
SET(CANMODULE\_BUILD\_PEAK “OFF”)

\end{itemize}

\end{description}

\end{itemize}

\sphinxstylestrong{These dependencies should conveniently be injected into cmake using a toolchain file:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CMakeLists.txt:
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
(...other stuff)
\PYGZsh{}
\PYGZsh{} Load build toolchain file and internal checks before we start building
\PYGZsh{}
if( DEFINED CMAKE\PYGZus{}TOOLCHAIN\PYGZus{}FILE )
        message( STATUS \PYGZdq{}[\PYGZdl{}\PYGZob{}CMAKE\PYGZus{}CURRENT\PYGZus{}LIST\PYGZus{}FILE\PYGZcb{}:\PYGZdl{}\PYGZob{}CMAKE\PYGZus{}CURRENT\PYGZus{}LIST\PYGZus{}LINE\PYGZcb{}]: CMAKE\PYGZus{}TOOLCHAIN\PYGZus{}FILE is defined \PYGZhy{}\PYGZhy{} including [\PYGZdl{}\PYGZob{}CMAKE\PYGZus{}TOOLCHAIN\PYGZus{}FILE\PYGZcb{}]\PYGZdq{})
        include( \PYGZdl{}\PYGZob{}CMAKE\PYGZus{}TOOLCHAIN\PYGZus{}FILE\PYGZcb{} )
endif()
(...other stuff)
\end{sphinxVerbatim}

\sphinxstylestrong{The toolchain file would look like this (i.e. windows):}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
toolchain.cmake:
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
\PYGZsh{} toolchain for CANX\PYGZhy{}tester for CI jenkins, w10e
\PYGZsh{} mludwig at cern dot ch
\PYGZsh{} cmake \PYGZhy{}DCMAKE\PYGZus{}TOOLCHAIN\PYGZus{}FILE=jenkins\PYGZus{}CanModule\PYGZus{}w10e.cmake .
\PYGZsh{}
\PYGZsh{} boost
\PYGZsh{}
\PYGZsh{} bin download from sl
SET ( BOOST\PYGZus{}PATH\PYGZus{}LIBS \PYGZdq{}M:/3rdPartySoftware/boost\PYGZus{}1\PYGZus{}59\PYGZus{}0\PYGZhy{}msvc\PYGZhy{}14/lib64\PYGZdq{} )
SET ( BOOST\PYGZus{}HEADERS \PYGZdq{}M:/3rdPartySoftware/boost\PYGZus{}1\PYGZus{}59\PYGZus{}0\PYGZhy{}msvc\PYGZhy{}14\PYGZdq{} )
SET ( BOOST\PYGZus{}LIBS \PYGZhy{}lboost\PYGZus{}log \PYGZhy{}lboost\PYGZus{}log\PYGZus{}setup \PYGZhy{}lboost\PYGZus{}filesystem \PYGZhy{}lboost\PYGZus{}system \PYGZhy{}lboost\PYGZus{}chrono \PYGZhy{}lboost\PYGZus{}date\PYGZus{}time \PYGZhy{}lboost\PYGZus{}thread  )
message( STATUS \PYGZdq{}[\PYGZdl{}\PYGZob{}CMAKE\PYGZus{}CURRENT\PYGZus{}LIST\PYGZus{}FILE\PYGZcb{}:\PYGZdl{}\PYGZob{}CMAKE\PYGZus{}CURRENT\PYGZus{}LIST\PYGZus{}LINE\PYGZcb{}] toolchain defines [BOOST\PYGZus{}PATH\PYGZus{}LIBS:\PYGZdl{}\PYGZob{}BOOST\PYGZus{}PATH\PYGZus{}LIBS\PYGZcb{}]\PYGZdq{} )
message( STATUS \PYGZdq{}[\PYGZdl{}\PYGZob{}CMAKE\PYGZus{}CURRENT\PYGZus{}LIST\PYGZus{}FILE\PYGZcb{}:\PYGZdl{}\PYGZob{}CMAKE\PYGZus{}CURRENT\PYGZus{}LIST\PYGZus{}LINE\PYGZcb{}] toolchain defines [BOOST\PYGZus{}HEADERS:\PYGZdl{}\PYGZob{}BOOST\PYGZus{}HEADERS\PYGZcb{}]\PYGZdq{} )
message( STATUS \PYGZdq{}[\PYGZdl{}\PYGZob{}CMAKE\PYGZus{}CURRENT\PYGZus{}LIST\PYGZus{}FILE\PYGZcb{}:\PYGZdl{}\PYGZob{}CMAKE\PYGZus{}CURRENT\PYGZus{}LIST\PYGZus{}LINE\PYGZcb{}] toolchain defines [BOOST\PYGZus{}LIBS:\PYGZdl{}\PYGZob{}BOOST\PYGZus{}LIBS\PYGZcb{}]\PYGZdq{} )
\PYGZsh{}
\PYGZsh{} LogIt, used by CANX directly as well
\PYGZsh{}
SET ( LOGIT\PYGZus{}HEADERS   \PYGZdq{}\PYGZdl{}ENV\PYGZob{}JENKINSWS\PYGZcb{}/CanModule/LogIt/include\PYGZdq{} )
SET ( LOGIT\PYGZus{}PATH\PYGZus{}LIBS \PYGZdq{}\PYGZdl{}ENV\PYGZob{}JENKINSWS\PYGZcb{}/CanModule/LogIt/lib\PYGZdq{} )
SET ( LOGIT\PYGZus{}LIBS \PYGZdq{}\PYGZhy{}lLogIt\PYGZdq{} )
\PYGZsh{}
\PYGZsh{} xerces\PYGZhy{}c
\PYGZsh{}
SET ( XERCES\PYGZus{}PATH\PYGZus{}LIBS \PYGZdq{}M:/3rdPartySoftware/xerces\PYGZhy{}c\PYGZhy{}3.2.0\PYGZus{}64bit/src/Debug\PYGZdq{} )
SET ( XERCES\PYGZus{}HEADERS \PYGZdq{}M:/3rdPartySoftware/xerces\PYGZhy{}c\PYGZhy{}3.2.0\PYGZus{}64bit/src\PYGZdq{} )
SET ( XERCES\PYGZus{}LIBS \PYGZdq{}xerces\PYGZhy{}c\PYGZus{}3D.lib\PYGZdq{} )
\PYGZsh{}
\PYGZsh{} CanModule build behaviour:
\PYGZsh{} CANMODULE\PYGZus{}BUILD\PYGZus{}VENDORS OFF or not specified: only build mockup, do not build any vendor libs (default phony)
\PYGZsh{} CANMODULE\PYGZus{}BUILD\PYGZus{}VENDORS ON, nothing else: build mockup and all vendor libs (default all on)
\PYGZsh{} CANMODULE\PYGZus{}BUILD\PYGZus{}VENDORS ON, CANMODULE\PYGZus{}BUILD\PYGZus{}SYSTEC OFF: build mockup and all vendor libs except systec (drop systec)
\PYGZsh{} CANMODULE\PYGZus{}BUILD\PYGZus{}VENDORS ON, CANMODULE\PYGZus{}BUILD\PYGZus{}ANAGATE OFF: build mockup and all vendor libs except anagate (drop anagate)
\PYGZsh{} CANMODULE\PYGZus{}BUILD\PYGZus{}VENDORS ON, CANMODULE\PYGZus{}BUILD\PYGZus{}PEAK OFF: build mockup and all vendor libs except peak (drop peak)
SET(CANMODULE\PYGZus{}BUILD\PYGZus{}VENDORS \PYGZdq{}ON\PYGZdq{} )
\PYGZsh{} disable a vendor
\PYGZsh{}SET(CANMODULE\PYGZus{}BUILD\PYGZus{}SYSTEC \PYGZdq{}OFF\PYGZdq{})
\PYGZsh{}SET(CANMODULE\PYGZus{}BUILD\PYGZus{}ANAGATE \PYGZdq{}OFF\PYGZdq{})
\PYGZsh{}SET(CANMODULE\PYGZus{}BUILD\PYGZus{}PEAK \PYGZdq{}OFF\PYGZdq{})
\PYGZsh{}
\PYGZsh{} systec
\PYGZsh{} version 6.02 for windows 10 7may2018
SET( SYSTEC\PYGZus{}LIB\PYGZus{}FILE \PYGZdq{}M:/3rdPartySoftware/SYSTEC\PYGZhy{}electronic/USB\PYGZhy{}CANmodul Utility Disk/Examples/Lib/USBCAN64.lib\PYGZdq{})
SET( SYSTEC\PYGZus{}HEADERS \PYGZdq{}M:/3rdPartySoftware/SYSTEC\PYGZhy{}electronic/USB\PYGZhy{}CANmodul Utility Disk/Examples/Include\PYGZdq{})
SET( SYSTEC\PYGZus{}LIB\PYGZus{}PATH \PYGZdq{}M:/3rdPartySoftware/SYSTEC\PYGZhy{}electronic/USB\PYGZhy{}CANmodul Utility Disk/Examples/lib\PYGZdq{} )
\PYGZsh{}
\PYGZsh{} anagate
\PYGZsh{} version vc8 as it seems
SET( ANAGATE\PYGZus{}LIB\PYGZus{}FILE \PYGZdq{}AnaGateCanDll64.lib\PYGZdq{})
SET( ANAGATE\PYGZus{}HEADERS \PYGZdq{}M:/3rdPartySoftware/AnaGateCAN/win64/vc8/include\PYGZdq{} )
SET( ANAGATE\PYGZus{}LIB\PYGZus{}PATH \PYGZdq{}M:/3rdPartySoftware/AnaGateCAN/win64/vc8/Release\PYGZdq{} )
\PYGZsh{}
\PYGZsh{} peak
\PYGZsh{} version PCAN Basic 4.3.2
SET( PEAK\PYGZus{}LIB\PYGZus{}FILE \PYGZdq{}PCANBasic.lib\PYGZdq{})
SET( PEAK\PYGZus{}HEADERS \PYGZdq{}M:/3rdPartySoftware/PCAN\PYGZhy{}Basic API/Include\PYGZdq{} )
SET( PEAK\PYGZus{}LIB\PYGZus{}PATH \PYGZdq{}M:/3rdPartySoftware/PCAN\PYGZhy{}Basic API/x64/VC\PYGZus{}LIB\PYGZdq{} )
\end{sphinxVerbatim}

\sphinxstylestrong{The toolchain gets then injected by running cmake:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
cmake \PYGZhy{}DCMAKE\PYGZus{}TOOLCHAIN\PYGZus{}FILE=toolchain.cmake
\end{sphinxVerbatim}


\chapter{Running}
\label{\detokenize{running:running}}\label{\detokenize{running::doc}}
The proper kernel modules, drivers and libraries for the vendors used through CanModule
have to be present during runtime. Please also refer to \sphinxhref{https://edms.cern.ch/file/2089743/1/CanModuleStatus2019\_v4.pptx}{Status} for an overview over
runtime conditions (april 2019).


\section{general dependencies}
\label{\detokenize{running:general-dependencies}}\begin{itemize}
\item {} 
CanModule.dll/.so

\item {} 
LogIt (cloned from github during cmake)

\item {} 
boost 1.64.0

\item {} 
xerces 3.2 (xerces-c\_3\_2D.dll)

\end{itemize}


\section{Anagate}
\label{\detokenize{running:anagate}}\begin{itemize}
\item {} 
libancan.dll/.so  (standard API)

\item {} 
linux: libAPIRelease64.so, libCANDLLRelease64.so, libAnaGateExtRelease.so, libAnaGateRelease.so

\item {} 
windows: ANAGATECAN64.dll

\end{itemize}


\section{Systec}
\label{\detokenize{running:systec}}\begin{itemize}
\item {} 
linux: libsockcan.so (standard API), driver kernel module systec\_can.ko and dependent modules

\item {} 
windows: libstcan.dll (standard API), USBCAN64.dll

\end{itemize}


\section{Peak}
\label{\detokenize{running:peak}}\begin{itemize}
\item {} 
linux: libsockcan.so (standard API), driver kernel module pcan.ko and dependent modules

\item {} 
windows: libpkcan.dll (standard API), PKCANBASIC.dll

\end{itemize}


\chapter{Connection}
\label{\detokenize{connection:connection}}\label{\detokenize{connection::doc}}
CanModule tries to recuperate lost connections automatically, but presently there is no method
to interrogate CanModule on the status of it’s connected modules. This might be added later, though.


\section{anagate}
\label{\detokenize{connection:anagate}}
The anagate modules are easily and uniquely identified by their IP address, also several modules
per CanModule instance are straightforward. An anagate bridge can be disconnected in 3 ways:
\begin{itemize}
\item {} 
power loss - power back

\item {} 
network interruption

\item {} 
firmware reset by software through the API

\end{itemize}

the firmware reset is NOT implemented in the CanModule, but a module can be remotely accessed and
firmware reset using the vendor API, through code like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{AnaInt32} \PYG{n}{timeout} \PYG{o}{=} \PYG{l+m+mi}{10000}\PYG{p}{;} \PYG{c+c1}{// 10secs}
\PYG{n}{AnaInt32} \PYG{n}{anaRet} \PYG{o}{=} \PYG{n}{CANRestart}\PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{192.168.1.10}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{timeout} \PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

In all 3 cases CanModule detects a failure to send a message on a port, and tries to reconnect
all ports of that module. Sending messages are buffered for \textasciitilde{}20secs, and the reconnection
takes at least \textasciitilde{}20sec, so it takes \textasciitilde{}1 minute to reestablish communication. All received CAN frames
are lost, and not all sent frames are guaranteed, therefore some care has to be taken when the
connection is reestablished concerning the statuses of CAN slaves. CanModule reports reconnections
as warnings, but there is no systematic CanModule-API yet to handle reconnections
systematically (is it needed?).

The anagate duo reconnects somewhat faster than the X4/X8 modules, because of firmware differences.
The whole reconnection can take up to 60 secs until all buffers are cleared, so please be patient.


\section{peak}
\label{\detokenize{connection:peak}}
The module is receiving power through the USB port, if this connection is lost we need to reconnect.
Reconnection works for both normal (fixed) and flexible datarate (FD) modules under linux, as
socketcan is used. For windows only
normal datarate (fixed) are supported, and the reconnection also works for them.

Reconnection takes less than 30sec.


\section{systec}
\label{\detokenize{connection:systec}}
A power loss or a connection loss will trigger a reconnection. For linux, where socketcan is used,
this works like for peak.

For windows the reconnection is NOT WORKING, and it is not clear if it can actually
be achieved within CanModule. It seems that a library reload is needed to make the module work again.
This feature is therefore DROPPED for now, since also no strong user request for “systec reconnection
under windows” is presently stated. I tried, using the systec \sphinxhref{mailto:API@windows}{API@windows}, but did not manage.


\chapter{Support}
\label{\detokenize{support:support}}\label{\detokenize{support::doc}}
Support for CanModule is given CERN wide.

\sphinxstylestrong{Problems, Issues and Requests} should be created as CERN \sphinxhref{https://its.cern.ch/jira/secure/Dashboard.jspa}{Jira} Tickets:
\begin{itemize}
\item {} 
Project= OPC UA in JCOP (OPCUA)

\item {} 
Components= CanModule

\item {} 
Assignee= Michael Ludwig

\end{itemize}

Please provide traces of your situation and information about your project context. We will sort it out together.

More \sphinxstylestrong{personal} ways to get help or report problems:
\begin{itemize}
\item {} 
You can send me an \sphinxhref{mailto:michael.ludwig@cern.ch?subject=CanModule\_issue\_found\&body=HelloMichael,}{Email} or call me 163095 or visit me for a coffee.

\item {} 
Please also take a look at \sphinxhref{https://its.cern.ch/jira/browse/OPCUA-1362?jql=assignee\%20\%3D\%20currentUser()\%20AND\%20component\%20\%3D\%20CanModule\%20AND\%20project\%20\%3D\%20OPCUA}{JiraSearch} for already existing issues.

\end{itemize}


\chapter{alphabetical index}
\label{\detokenize{index:alphabetical-index}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}