%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
\edef\sphinxdqmaybe{\ifdefined\DeclareUnicodeCharacterAsOptional\string"\fi}
  \DeclareUnicodeCharacter{\sphinxdqmaybe00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Sonny]{fncychap}
\ChNameVar{\Large\normalfont\sffamily}
\ChTitleVar{\Large\normalfont\sffamily}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.\@ }}
\makeatletter
\def\fnum@figure{\figurename\thefigure{}}
\makeatother
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\makeatletter
\def\fnum@table{\tablename\thetable{}}
\makeatother
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}
\addto\captionsenglish{\renewcommand{\sphinxnonalphabeticalgroupname}{Non-alphabetical}}
\addto\captionsenglish{\renewcommand{\sphinxsymbolsname}{Symbols}}
\addto\captionsenglish{\renewcommand{\sphinxnumbersname}{Numbers}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{2}



\title{CanModule Developer Documentation}
\date{May 21, 2019}
\release{1.1.1}
\author{Michael Ludwig}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Downloading}
\label{\detokenize{downloading:downloading}}\label{\detokenize{downloading::doc}}

\section{The sources}
\label{\detokenize{downloading:the-sources}}
CanModule can be cloned from github, and are integrated in a cmake build chain:

the latest stable release (preferred):
git clone \sphinxstylestrong{-b latestStable} \sphinxurl{https://github.com/quasar-team/CanModule.git}

or

a specific version:
git clone \sphinxstylestrong{-b 1.1.0} \sphinxurl{https://github.com/quasar-team/CanModule.git}


\section{The binaries}
\label{\detokenize{downloading:the-binaries}}
(bin/exe) and libraries (so/dll) for the target platforms
\begin{itemize}
\item {} 
CERN CC7

\item {} 
windows 2016 server

\item {} 
windows 10

\item {} 
and windows 2008r2 (server) LEGACY

\end{itemize}

are available at \sphinxhref{https://repository.cern.ch/nexus/content/repositories/cern-can/}{NexusCan} from inside CERN.


\chapter{Objective}
\label{\detokenize{objective:objective}}\label{\detokenize{objective::doc}}
\sphinxstylestrong{CanModule} is a software abstraction layer, written in C++, to simplify integration
of CAN bridges from different vendors into cmake (C++) projects needing CAN connectivity
for windows and linux. A CAN bridge is - usually - an external module which is connected
on one side to a computer or network and offers CAN ports on the other side where CAN buses
can be connected.

The original authors are the CERN Atlas-DCS team, support is now done by BE-ICS-FD.


\section{Supported OS}
\label{\detokenize{objective:supported-os}}
These operating systems are supported for all vendors
\begin{itemize}
\item {} 
CERN CC7

\item {} 
Windows 2016 Server and Windows 10

\end{itemize}

other OS versions might be available on special request, or easily be ported to.


\section{compatible vendors}
\label{\detokenize{objective:compatible-vendors}}
CAN bridges from vendors are compatible with CanModule and are tested
\begin{itemize}
\item {} 
\sphinxhref{http://www.anagate.de/en/products/can-ethernet-gateways.htm}{AnaGate}

\item {} 
\sphinxhref{https://www.systec-electronic.com/}{SysTec}

\item {} 
\sphinxhref{https://www.peak-system.com/}{Peak}

\end{itemize}

These vendors produce many types of CAN bridges, \sphinxstylestrong{CanModule supports presently the USB (Peak, Systec)
and ethernet (Anagate) bridges}. Flexible datarate bridges (PEAK FD) and other interface types
(PEAK .m2 or also PCI) might be added if needed.


\section{Integration into projects}
\label{\detokenize{objective:integration-into-projects}}
In order to use CanModule in your  project/server/code there are two ways
\begin{itemize}
\item {} 
by source-clone from \sphinxhref{https://github.com/quasar-team/CanModule.git}{CanModuleGitlab} and integrated into a cmake build chain.

\item {} 
binaries to copy for other build chains are available CERN-wide from \sphinxhref{https://repository.cern.ch/nexus/content/repositories/cern-can/}{NexusCan} .

\end{itemize}


\chapter{Standard API}
\label{\detokenize{standardApi:standard-api}}\label{\detokenize{standardApi::doc}}
The user API is using \sphinxstylestrong{3 classes and hides all vendor specific details}.
Only a few common methods are needed:
\begin{itemize}
\item {} 
A \sphinxstylestrong{vendor is chosen} and specific details are then taken care of by loading any further dependencies:

\end{itemize}
\index{CanModule::CanLibLoader (C++ class)@\spxentry{CanModule::CanLibLoader}\spxextra{C++ class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{standardApi:_CPPv4N9CanModule12CanLibLoaderE}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{standardApi:classCanModule_1_1CanLibLoader}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{CanLibLoader}}}%
\pysigstopmultiline
Subclassed by CanModule::CanLibLoaderLin, CanModule::CanLibLoaderWin

\end{fulllineitems}

\begin{itemize}
\item {} 
Connection/access details to the \sphinxstylestrong{different vendors} are managed by sub-classing:

\end{itemize}
\index{CanModule::CCanAccess (C++ class)@\spxentry{CanModule::CCanAccess}\spxextra{C++ class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{standardApi:_CPPv4N9CanModule10CCanAccessE}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{standardApi:classCanModule_1_1CCanAccess}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{CCanAccess}}}%
\pysigstopmultiline
Subclassed by {\hyperref[\detokenize{vendors/anagate:classAnaCanScan}]{\sphinxcrossref{\DUrole{std,std-ref}{AnaCanScan}}}}, {\hyperref[\detokenize{vendors/systec:classCSockCanScan}]{\sphinxcrossref{\DUrole{std,std-ref}{CSockCanScan}}}}, MockCanAccess, {\hyperref[\detokenize{vendors/peak:classPKCanScan}]{\sphinxcrossref{\DUrole{std,std-ref}{PKCanScan}}}}, {\hyperref[\detokenize{vendors/systec:classSTCanScan}]{\sphinxcrossref{\DUrole{std,std-ref}{STCanScan}}}}

\end{fulllineitems}

\begin{itemize}
\item {} 
The \sphinxstylestrong{access to a CAN port} is through:

\end{itemize}
\index{CanModule::CanBusAccess (C++ class)@\spxentry{CanModule::CanBusAccess}\spxextra{C++ class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{standardApi:_CPPv4N9CanModule12CanBusAccessE}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{standardApi:classCanModule_1_1CanBusAccess}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{CanBusAccess}}}%
\pysigstopmultiline
{\hyperref[\detokenize{standardApi:classCanModule_1_1CanBusAccess}]{\sphinxcrossref{\DUrole{std,std-ref}{CanBusAccess}}}} class ensure a connection to can hardware. it can create the connection to different hardware at same time the syntax of the name is “name of component:name of the channel” 

\end{fulllineitems}

\begin{itemize}
\item {} 
This \sphinxstylestrong{snippet} gives an overview how the API is used to hide vendor details and achieve CAN connectivity:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{string} \PYG{n}{libName} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sock}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}         \PYG{c+c1}{// here: systec or peak through socketCan, linux}
\PYG{n}{string} \PYG{n}{port} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sock:can0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}       \PYG{c+c1}{// here: CAN port 0 via socket CAN, linux}
\PYG{n}{string} \PYG{n}{parameters} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Undefined}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;} \PYG{c+c1}{// here: use defaults}
\PYG{n}{CanMessage} \PYG{n}{cm}\PYG{p}{;}
\PYG{n}{CanModule}\PYG{o}{:}\PYG{o}{:}\PYG{n}{CanLibLoader} \PYG{o}{*}\PYG{n}{libloader} \PYG{o}{=} \PYG{n}{CanModule}\PYG{o}{:}\PYG{o}{:}\PYG{n}{CanLibLoader}\PYG{o}{:}\PYG{o}{:}\PYG{n}{createInstance}\PYG{p}{(} \PYG{n}{libName} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{cca} \PYG{o}{=} \PYG{n}{libloader}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{openCanBus}\PYG{p}{(} \PYG{n}{port}\PYG{p}{,} \PYG{n}{parameters} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{cca}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{sendMessage}\PYG{p}{(} \PYG{o}{\PYGZam{}}\PYG{n}{cm} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{cca}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{canMessageCame}\PYG{p}{.}\PYG{n}{connect}\PYG{p}{(} \PYG{o}{\PYGZam{}}\PYG{n}{onMessageRcvd} \PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// connect a reception handler}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Only two strings, “port” and “parameters”

\end{itemize}

have to defined to communicate with a CAN port for a module from a vendor.
\begin{itemize}
\item {} 
a connection handler method

\end{itemize}

must be registered to treat received messages (boost slot connected to boost signal):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{connection}\PYG{p}{.}\PYG{n+nl}{h} \PYG{p}{:}
\PYG{k}{class} \PYG{n+nc}{CONNECTION} \PYG{p}{\PYGZob{}}
   \PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}
   \PYG{k}{public}\PYG{o}{:}
      \PYG{k}{static} \PYG{k+kt}{void} \PYG{n}{onMessageRcvd}\PYG{p}{(}\PYG{k}{const} \PYG{n}{CanMsgStruct}\PYG{c+cm}{/*\PYGZam{}*/} \PYG{n}{message}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{connection}\PYG{p}{.}\PYG{n+nl}{cpp} \PYG{p}{:}
\PYG{c+cm}{/* static */} \PYG{k+kt}{void} \PYG{n}{CONNECTION}\PYG{o}{:}\PYG{o}{:}\PYG{n}{onMessageRcvd}\PYG{p}{(}\PYG{k}{const} \PYG{n}{CanMsgStruct}\PYG{c+cm}{/*\PYGZam{}*/} \PYG{n}{message}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{MYCLASS} \PYG{o}{*}\PYG{n}{myObject} \PYG{o}{=} \PYG{n}{MYCLASS}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getMyObject}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}\PYG{p}{;}
   \PYG{n}{myObject}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{processReceivedMessage}\PYG{p}{(} \PYG{n}{message} \PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
you can take a look at \sphinxhref{https://gitlab.cern.ch/mludwig/canx.git}{CANX} for a full multithreaded example using CanModule (CERN, gitlab)

\end{itemize}


\chapter{C-Wrapper}
\label{\detokenize{cwrapper:c-wrapper}}\label{\detokenize{cwrapper::doc}}
in order to call \sphinxstylestrong{CanModule} also from low-level vendor specific code, which is often implemented
in C, CanModule has a C-wrapper as well. The objective is to call the C++ objects of CanModule
from C-code. Still, a C++ compiler is needed for the build, but this type of
compiler is usually downward compatible to C.


\chapter{SysTec}
\label{\detokenize{vendors/systec:systec}}\label{\detokenize{vendors/systec::doc}}
All modules from vendor {\hyperref[\detokenize{vendors/systec:systec}]{\sphinxcrossref{SysTec}}} are handled by class STCanScan (windows) or CSockCanScan (linux) which
manage the modules through their underlying vendor specific API and provide the standard generic CanModule API.
Here the underlying vendor specific classes and the specific parameters are documented.

SysTec modules USB-CAN bridges are supported: sysWORXX 1,2,8,16


\section{The connection}
\label{\detokenize{vendors/systec:the-connection}}
To connect to a specific port for I/O, and send CAN messages, the following methods are used.


\subsection{windows}
\label{\detokenize{vendors/systec:windows}}
The connection to a specific port for I/O is created by calling
\index{STCanScan (C++ class)@\spxentry{STCanScan}\spxextra{C++ class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vendors/systec:_CPPv49STCanScan}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{vendors/systec:classSTCanScan}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{STCanScan}} : \sphinxbfcode{\sphinxupquote{public}} CanModule::{\hyperref[\detokenize{standardApi:_CPPv4N9CanModule10CCanAccessE}]{\sphinxcrossref{CCanAccess}}}}%
\pysigstopmultiline~\subsubsection*{Public Functions}
\index{STCanScan::createBus (C++ function)@\spxentry{STCanScan::createBus}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vendors/systec:_CPPv4N9STCanScan9createBusEK6stringK6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{vendors/systec:classSTCanScan_1aa99f9f23bdfd367a51efc40e228a6f88}}\pysiglinewithargsret{bool \sphinxbfcode{\sphinxupquote{createBus}}}{\sphinxbfcode{\sphinxupquote{const}} string \sphinxstyleemphasis{name}, \sphinxbfcode{\sphinxupquote{const}} string \sphinxstyleemphasis{parameters}}{}%
\pysigstopmultiline
Method that initialises a CAN bus channel for systec. All following methods called on the same object will be using this initialized channel.

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
was the initialisation process successful? 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{name}}: = 2 parameters separated by “:” like “n0:n1”\begin{itemize}
\item {} 
n0 = “st” for systec

\item {} 
n1 = CAN port number on the module, can be prefixed with “can”

\item {} 
ex.: “st:can1” speaks to port 1 on systec module at the ip

\item {} 
ex.: “st:1” works as well

\end{itemize}


\item {} 
\sphinxcode{\sphinxupquote{parameters}}: one parameter: “p0”, positive integers\begin{itemize}
\item {} 
”Unspecified” (or empty): using defaults = “125000” // params missing

\item {} 
p0: bitrate: 50000, 100000, 125000, 250000, 500000, 1000000 bit/s i.e. “250000”

\end{itemize}


\end{itemize}

\end{description}


\end{fulllineitems}

\index{STCanScan::sendMessage (C++ function)@\spxentry{STCanScan::sendMessage}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vendors/systec:_CPPv4N9STCanScan11sendMessageEshPhb}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{vendors/systec:classSTCanScan_1a45f0ec011022bf58a23e8370bac7f829}}\pysiglinewithargsret{bool \sphinxbfcode{\sphinxupquote{sendMessage}}}{short \sphinxstyleemphasis{cobID}, unsigned char \sphinxstyleemphasis{len}, unsigned char *\sphinxstyleemphasis{message}, bool \sphinxstyleemphasis{rtr} = false}{}%
\pysigstopmultiline
Method that sends a message trough the can bus channel. If the method createBUS was not called before this, sendMessage will fail, as there is no can bus channel to send a message through.

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
Was the sending process successful? 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{cobID}}: Identifier that will be used for the message. 

\item {} 
\sphinxcode{\sphinxupquote{len}}: Length of the message. If the message is bigger than 8 characters, it will be split into separate 8 characters messages. 

\item {} 
\sphinxcode{\sphinxupquote{message}}: Message to be sent trough the can bus. 

\item {} 
\sphinxcode{\sphinxupquote{rtr}}: is the message a remote transmission request? 

\end{itemize}

\end{description}


\end{fulllineitems}


\end{fulllineitems}


and communication takes place through systec’s closed-source windows library.


\subsection{linux}
\label{\detokenize{vendors/systec:linux}}
The open-source socketcan interface is used on top of systec’s open source driver:
\index{CSockCanScan (C++ class)@\spxentry{CSockCanScan}\spxextra{C++ class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vendors/systec:_CPPv412CSockCanScan}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{vendors/systec:classCSockCanScan}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{CSockCanScan}} : \sphinxbfcode{\sphinxupquote{public}} CanModule::{\hyperref[\detokenize{standardApi:_CPPv4N9CanModule10CCanAccessE}]{\sphinxcrossref{CCanAccess}}}}%
\pysigstopmultiline~\subsubsection*{Public Functions}
\index{CSockCanScan::createBus (C++ function)@\spxentry{CSockCanScan::createBus}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vendors/systec:_CPPv4N12CSockCanScan9createBusEK6string6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{vendors/systec:classCSockCanScan_1ac5c669f96d2d6cf7387f8a646bd65b3f}}\pysiglinewithargsret{bool \sphinxbfcode{\sphinxupquote{createBus}}}{\sphinxbfcode{\sphinxupquote{const}} string \sphinxstyleemphasis{name}, string \sphinxstyleemphasis{parameters}}{}%
\pysigstopmultiline
Method that initializes a can bus channel. The following methods called upon the same object will be using this initialized channel.

\begin{itemize}
\item {} 
i.e. “250000”

\end{itemize}
\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{name}}: = 2 parameters separated by “:”, like “n0:n1”\begin{itemize}
\item {} 
n0 = “sock” for sockets, used by systec and peak

\item {} 
n1 = CAN port number on the module, can be prefixed with “can”

\item {} 
ex.: “sock:can1” speaks to port 1 on systec or peak module

\item {} 
ex.: “sock:1” works as well

\end{itemize}


\item {} 
\sphinxcode{\sphinxupquote{parameters}}: one parameter: “p0”, positive integer\begin{itemize}
\item {} 
”Unspecified” (or empty): using defaults = “125000” // params missing

\item {} 
p0: bitrate: 50000, 100000, 125000, 250000, 500000, 1000000 bit/s, other values might be allowed by the module

\end{itemize}


\end{itemize}

\end{description}


\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
Was the initialization process successful? 

\end{description}


\end{fulllineitems}

\index{CSockCanScan::sendMessage (C++ function)@\spxentry{CSockCanScan::sendMessage}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vendors/systec:_CPPv4N12CSockCanScan11sendMessageEshPhb}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{vendors/systec:classCSockCanScan_1a485ec8621a98cdacad8e27433e09d919}}\pysiglinewithargsret{bool \sphinxbfcode{\sphinxupquote{sendMessage}}}{short \sphinxstyleemphasis{cobID}, unsigned char \sphinxstyleemphasis{len}, unsigned char *\sphinxstyleemphasis{message}, bool \sphinxstyleemphasis{rtr} = false}{}%
\pysigstopmultiline
Method that sends a message trough the can bus channel. If the method createBUS was not called before this, sendMessage will fail, as there is no can bus channel to send a message through.

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
Was the initialisation process successful? 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{cobID}}: Identifier that will be used for the message. 

\item {} 
\sphinxcode{\sphinxupquote{len}}: Length of the message. If the message is bigger than 8 characters, it will be split into separate 8 characters messages. 

\item {} 
\sphinxcode{\sphinxupquote{message}}: Message to be sent trough the can bus. 

\item {} 
\sphinxcode{\sphinxupquote{rtr}}: is the message a remote transmission request? 

\end{itemize}

\end{description}


\end{fulllineitems}


\end{fulllineitems}


sockets are used normally, using linux’ built-in CAN protocols:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mysock} \PYG{o}{=} \PYG{n}{socket}\PYG{p}{(}\PYG{n}{domain}\PYG{o}{=}\PYG{n}{PF\PYGZus{}CAN}\PYG{p}{,} \PYG{n}{type}\PYG{o}{=}\PYG{n}{SOCK\PYGZus{}RAW}\PYG{p}{,} \PYG{n}{protocol}\PYG{o}{=}\PYG{n}{CAN\PYGZus{}RAW}\PYG{p}{)}
\end{sphinxVerbatim}


\section{standard CanModule API example}
\label{\detokenize{vendors/systec:standard-canmodule-api-example}}
This is how the CanModule standard API is used for systec for linux.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{libloader} \PYG{o}{=} \PYG{n}{CanModule}\PYG{o}{:}\PYG{o}{:}\PYG{n}{CanLibLoader}\PYG{o}{:}\PYG{o}{:}\PYG{n}{createInstance}\PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sock}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// linux, use \PYGZdq{}st\PYGZdq{} for windows}
\PYG{n}{cca} \PYG{o}{=} \PYG{n}{libloader}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{openCanBus}\PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sock:can0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{250000}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// termination on frontpanel}
\PYG{n}{CanMessage} \PYG{n}{cm}\PYG{p}{;} \PYG{c+c1}{// empty}
\PYG{n}{cca}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{sendMessage}\PYG{p}{(} \PYG{o}{\PYGZam{}}\PYG{n}{cm} \PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\chapter{AnaGate}
\label{\detokenize{vendors/anagate:anagate}}\label{\detokenize{vendors/anagate::doc}}
All modules from vendor {\hyperref[\detokenize{vendors/anagate:anagate}]{\sphinxcrossref{AnaGate}}} are handled by class AnaCanScan which manages the modules through their underlying vendor specific API and provides
the standard generic CanModule API.

We support Anagate CAN-ethernet gateways: uno, duo, quattro, and the X2, X4 and X8.

Since these modules communicate to the host computer only via ethernet, at the fundamental level only classical
tcp/ip ethernet is needed. Nevertheless the specific contents of the IP frames are wrapped up in an Anagate API for convenience, which is linked
into the user code as a library. There are therefore no implementation differences between Linux and Windows.
Here the underlying vendor specific classes and the specific parameters are documented.

The downside of Anagate CAN-ethernet modules is of course that the latency of the network has to be added to the bridge latency.


\section{The connection}
\label{\detokenize{vendors/anagate:the-connection}}
To connect to a specific port for I/O, and send CAN messages, the following methods are used.
\index{AnaCanScan (C++ class)@\spxentry{AnaCanScan}\spxextra{C++ class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vendors/anagate:_CPPv410AnaCanScan}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{vendors/anagate:classAnaCanScan}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{AnaCanScan}} : \sphinxbfcode{\sphinxupquote{public}} CanModule::{\hyperref[\detokenize{standardApi:_CPPv4N9CanModule10CCanAccessE}]{\sphinxcrossref{CCanAccess}}}}%
\pysigstopmultiline~\subsubsection*{Public Functions}
\index{AnaCanScan::createBus (C++ function)@\spxentry{AnaCanScan::createBus}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vendors/anagate:_CPPv4N10AnaCanScan9createBusEK6stringK6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{vendors/anagate:classAnaCanScan_1a54a66154c956b4605ff18f93f552db60}}\pysiglinewithargsret{bool \sphinxbfcode{\sphinxupquote{createBus}}}{\sphinxbfcode{\sphinxupquote{const}} string \sphinxstyleemphasis{name}, \sphinxbfcode{\sphinxupquote{const}} string \sphinxstyleemphasis{parameters}}{}%
\pysigstopmultiline
Method that initialises a CAN bus channel for anagate. All following methods called on the same object will be using this initialized channel.

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
was the initialisation process successful? 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{name}}: 3 parameters separated by “:” like “n0:n1:n2” n0 = “an” for anagate n1 = port number on the module, 0=A, 1=B, etc etc n2 = ip number ex.: “an:can1:137.138.12.99” speaks to port B (=1) on anagate module at the ip ex.: “an:1:137.138.12.99” works as well

\item {} 
\sphinxcode{\sphinxupquote{parameters}}: up to 6 parameters separated by whitespaces : “p0 p1 p2 p3 p4 p5” in THAT order, positive integers\begin{itemize}
\item {} 
”Unspecified” (or empty): using defaults = “125000 0 0 0 0 0” // all params missing

\item {} 
p0: bitrate: 10000, 20000, 50000, 62000, 100000, 125000, 250000, 500000, 800000, 1000000 bit/s

\item {} 
p1: operatingMode: 0=default mode, values 1 (loop back) and 2 (listen) are not supported by CanModule

\item {} 
p2: termination: 0=not terminated (default), 1=terminated (120 Ohm for CAN bus)

\item {} 
p3: highSpeed: 0=deactivated (default), 1=activated. If activated, confirmation and filtering of CAN traffic are switched off

\item {} 
p4: TimeStamp: 0=deactivated (default), 1=activated. If activated, a timestamp is added to the CAN frame. Not all modules support this.

\item {} 
p5: syncMode: 0=default, unused but reserved for future use i.e. “250000 0 1 0 0 1” (see anagate manual for more details)

\end{itemize}


\end{itemize}

\end{description}


\end{fulllineitems}

\index{AnaCanScan::sendMessage (C++ function)@\spxentry{AnaCanScan::sendMessage}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vendors/anagate:_CPPv4N10AnaCanScan11sendMessageEshPhb}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{vendors/anagate:classAnaCanScan_1ad45666454318c891d7acd9fe16ae4c49}}\pysiglinewithargsret{bool \sphinxbfcode{\sphinxupquote{sendMessage}}}{short \sphinxstyleemphasis{cobID}, unsigned char \sphinxstyleemphasis{len}, unsigned char *\sphinxstyleemphasis{message}, bool \sphinxstyleemphasis{rtr} = false}{}%
\pysigstopmultiline
send a CAN message frame (8 byte) for anagate Method that sends a message through the can bus channel. If the method createBus was not called before this, sendMessage will fail, as there is no can bus channel to send a message trough. \begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
Was the sending process successful? 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{cobID:}}: Identifier that will be used for the message. 

\item {} 
\sphinxcode{\sphinxupquote{len:}}: Length of the message. If the message is bigger than 8 characters, it will be split into separate 8 characters messages. 

\item {} 
\sphinxcode{\sphinxupquote{message:}}: Message to be sent trough the can bus. 

\item {} 
\sphinxcode{\sphinxupquote{rtr:}}: is the message a remote transmission request? 

\end{itemize}

\end{description}


\end{fulllineitems}


\end{fulllineitems}



\section{standard CanModule API example}
\label{\detokenize{vendors/anagate:standard-canmodule-api-example}}
This is how the CanModule standard API is used for anagate. The code is identical for linux and windows.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{libloader} \PYG{o}{=} \PYG{n}{CanModule}\PYG{o}{:}\PYG{o}{:}\PYG{n}{CanLibLoader}\PYG{o}{:}\PYG{o}{:}\PYG{n}{createInstance}\PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{an}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{cca} \PYG{o}{=} \PYG{n}{libloader}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{openCanBus}\PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{an:can0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{250000 0 1}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// termination, ISEG controllers, p3, p4, p5 defaults}
\PYG{n}{CanMessage} \PYG{n}{cm}\PYG{p}{;} \PYG{c+c1}{// empty}
\PYG{n}{cca}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{sendMessage}\PYG{p}{(} \PYG{o}{\PYGZam{}}\PYG{n}{cm} \PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\chapter{Peak}
\label{\detokenize{vendors/peak:peak}}\label{\detokenize{vendors/peak::doc}}
All modules from vendor {\hyperref[\detokenize{vendors/peak:peak}]{\sphinxcrossref{Peak}}} are handled by class PKCanScan (windows) or CSockCanScan (linux) which
both manage the modules through their underlying vendor specific API according to the OS.
Both classes provide the standard generic CanModule API.
Here the underlying vendor specific classes and the specific parameters are documented.

The modules from the families PCAN USB and USB Pro are supported.


\section{The connection}
\label{\detokenize{vendors/peak:the-connection}}
To connect to a specific port for I/O, and send CAN messages, the following methods are used.


\subsection{windows}
\label{\detokenize{vendors/peak:windows}}
the connection to a specific port for I/O is created by calling
\index{PKCanScan (C++ class)@\spxentry{PKCanScan}\spxextra{C++ class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vendors/peak:_CPPv49PKCanScan}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{vendors/peak:classPKCanScan}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{PKCanScan}} : \sphinxbfcode{\sphinxupquote{public}} CanModule::{\hyperref[\detokenize{standardApi:_CPPv4N9CanModule10CCanAccessE}]{\sphinxcrossref{CCanAccess}}}}%
\pysigstopmultiline~\subsubsection*{Public Functions}
\index{PKCanScan::createBus (C++ function)@\spxentry{PKCanScan::createBus}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vendors/peak:_CPPv4N9PKCanScan9createBusEK6stringK6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{vendors/peak:classPKCanScan_1ae91999b9316ca127eecbabd9f27c3137}}\pysiglinewithargsret{bool \sphinxbfcode{\sphinxupquote{createBus}}}{\sphinxbfcode{\sphinxupquote{const}} string \sphinxstyleemphasis{name}, \sphinxbfcode{\sphinxupquote{const}} string \sphinxstyleemphasis{parameters}}{}%
\pysigstopmultiline
Method that initialises a CAN bus channel for peak (using PEAK Basic) All following methods called on the same object will be using this initialized channel. Only USB interfaces for PEAK modules, and only NON FD modules are supported for now.

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
was the initialisation process successful? 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{name}}: = 2 parameters separated by “:” like “n0:n1”\begin{itemize}
\item {} 
n0 = “pk” for peak

\item {} 
n1 = CAN port number on the module, can be prefixed with “can”: 0..N

\item {} 
ex.: “pk:can1” speaks to port 1 (the second port) on peak module at the ip

\item {} 
ex.: “pk:1” works as well

\end{itemize}


\item {} 
\sphinxcode{\sphinxupquote{parameters}}: one parameter: “p0”, positive integer\begin{itemize}
\item {} 
”Unspecified” (or empty): using defaults = “125000” // params missing

\item {} 
p0: bitrate: 50000, 100000, 125000, 250000, 500000, 1000000 bit/s i.e. “250000”

\end{itemize}


\end{itemize}

\end{description}


\end{fulllineitems}

\index{PKCanScan::sendMessage (C++ function)@\spxentry{PKCanScan::sendMessage}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vendors/peak:_CPPv4N9PKCanScan11sendMessageEshPhb}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{vendors/peak:classPKCanScan_1a48a2e9ba00dae1b1fe01f7b095430503}}\pysiglinewithargsret{bool \sphinxbfcode{\sphinxupquote{sendMessage}}}{short \sphinxstyleemphasis{cobID}, unsigned char \sphinxstyleemphasis{len}, unsigned char *\sphinxstyleemphasis{message}, bool \sphinxstyleemphasis{rtr} = false}{}%
\pysigstopmultiline
method to send a CAN message to the peak module. we use the standard API “PCAN-Basic” for this for windows and we talk only over USB to fixed bitrate modules. The flexible bitrate (FD) modules can be implemented later as well: for this we need more parameters to pass and a switch between CAN\_Write and CAN\_WriteFD. 

\end{fulllineitems}


\end{fulllineitems}


and communication takes place through peak’s open-source PCAN-Basic windows library. Only “plug-and-play”
modules with USB interface and fixed datarate are supported by CanModule for now. PEAK’s flexible datarate (FD)
modules can be added later on (they need some different API-calls and more complex parameters), and also
other interfaces like PCI are possible for windows.The implementation is based on the PCAN-Basic driver.


\subsection{linux}
\label{\detokenize{vendors/peak:linux}}
The open-source socketcan interface is used on top of peak’s open source netdev driver. Both Peak’s
fixed and flexible datarate are working, although the fixed modules are recommended for bus compatibility.
Only modules with USB interface are supported.
The peak driver source is freely available and it can be configured to build several
types of drivers, where we use peak’s netdev driver only. See \sphinxhref{https://readthedocs.web.cern.ch/display/CANDev/CAN+development?src=sidebar}{PeakDriver} for details on this.
A PCAN-Basic driver is also available but the netdev driver is more performant and modern. The
PCAN-Basic driver is used nevertheless for windows, and it offers better compatibility for all module
families.
\index{CSockCanScan (C++ class)@\spxentry{CSockCanScan}\spxextra{C++ class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vendors/peak:_CPPv412CSockCanScan}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{vendors/peak:classCSockCanScan}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{CSockCanScan}} : \sphinxbfcode{\sphinxupquote{public}} CanModule::{\hyperref[\detokenize{standardApi:_CPPv4N9CanModule10CCanAccessE}]{\sphinxcrossref{CCanAccess}}}}%
\pysigstopmultiline~\subsubsection*{Public Functions}
\index{CSockCanScan::createBus (C++ function)@\spxentry{CSockCanScan::createBus}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vendors/peak:_CPPv4N12CSockCanScan9createBusEK6string6string}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{vendors/peak:classCSockCanScan_1ac5c669f96d2d6cf7387f8a646bd65b3f}}\pysiglinewithargsret{bool \sphinxbfcode{\sphinxupquote{createBus}}}{\sphinxbfcode{\sphinxupquote{const}} string \sphinxstyleemphasis{name}, string \sphinxstyleemphasis{parameters}}{}%
\pysigstopmultiline
Method that initializes a can bus channel. The following methods called upon the same object will be using this initialized channel.

\begin{itemize}
\item {} 
i.e. “250000”

\end{itemize}
\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{name}}: = 2 parameters separated by “:”, like “n0:n1”\begin{itemize}
\item {} 
n0 = “sock” for sockets, used by systec and peak

\item {} 
n1 = CAN port number on the module, can be prefixed with “can”

\item {} 
ex.: “sock:can1” speaks to port 1 on systec or peak module

\item {} 
ex.: “sock:1” works as well

\end{itemize}


\item {} 
\sphinxcode{\sphinxupquote{parameters}}: one parameter: “p0”, positive integer\begin{itemize}
\item {} 
”Unspecified” (or empty): using defaults = “125000” // params missing

\item {} 
p0: bitrate: 50000, 100000, 125000, 250000, 500000, 1000000 bit/s, other values might be allowed by the module

\end{itemize}


\end{itemize}

\end{description}


\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
Was the initialization process successful? 

\end{description}


\end{fulllineitems}

\index{CSockCanScan::sendMessage (C++ function)@\spxentry{CSockCanScan::sendMessage}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{vendors/peak:_CPPv4N12CSockCanScan11sendMessageEshPhb}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{vendors/peak:classCSockCanScan_1a485ec8621a98cdacad8e27433e09d919}}\pysiglinewithargsret{bool \sphinxbfcode{\sphinxupquote{sendMessage}}}{short \sphinxstyleemphasis{cobID}, unsigned char \sphinxstyleemphasis{len}, unsigned char *\sphinxstyleemphasis{message}, bool \sphinxstyleemphasis{rtr} = false}{}%
\pysigstopmultiline
Method that sends a message trough the can bus channel. If the method createBUS was not called before this, sendMessage will fail, as there is no can bus channel to send a message through.

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode
Was the initialisation process successful? 

\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{cobID}}: Identifier that will be used for the message. 

\item {} 
\sphinxcode{\sphinxupquote{len}}: Length of the message. If the message is bigger than 8 characters, it will be split into separate 8 characters messages. 

\item {} 
\sphinxcode{\sphinxupquote{message}}: Message to be sent trough the can bus. 

\item {} 
\sphinxcode{\sphinxupquote{rtr}}: is the message a remote transmission request? 

\end{itemize}

\end{description}


\end{fulllineitems}


\end{fulllineitems}


sockets are used normally, using linux’ built-in CAN protocols:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mysock} \PYG{o}{=} \PYG{n}{socket}\PYG{p}{(}\PYG{n}{domain}\PYG{o}{=}\PYG{n}{PF\PYGZus{}CAN}\PYG{p}{,} \PYG{n}{type}\PYG{o}{=}\PYG{n}{SOCK\PYGZus{}RAW}\PYG{p}{,} \PYG{n}{protocol}\PYG{o}{=}\PYG{n}{CAN\PYGZus{}RAW}\PYG{p}{)}
\end{sphinxVerbatim}


\section{standard CanModule API example}
\label{\detokenize{vendors/peak:standard-canmodule-api-example}}
This is how the CanModule standard API is used for peak for windows.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{libloader} \PYG{o}{=} \PYG{n}{CanModule}\PYG{o}{:}\PYG{o}{:}\PYG{n}{CanLibLoader}\PYG{o}{:}\PYG{o}{:}\PYG{n}{createInstance}\PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{pk}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// windows, use \PYGZdq{}sock\PYGZdq{} for linux}
\PYG{n}{cca} \PYG{o}{=} \PYG{n}{libloader}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{openCanBus}\PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{pk:can0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{250000}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// termination on frontpanel}
\PYG{n}{CanMessage} \PYG{n}{cm}\PYG{p}{;} \PYG{c+c1}{// empty}
\PYG{n}{cca}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{sendMessage}\PYG{p}{(} \PYG{o}{\PYGZam{}}\PYG{n}{cm} \PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\chapter{Logging}
\label{\detokenize{logging:logging}}\label{\detokenize{logging::doc}}
CanModule uses \sphinxhref{https://github.com/quasar-team/LogIt}{LogIt} for reporting information during runtime. LogIt uses the four components
\begin{itemize}
\item {} 
CanModule: general messages concerning CanModule itself

\item {} 
CanModuleAnagate: messages related to AnaGate modules

\item {} 
CanModuleSystec: messages related to SysTec modules

\item {} 
CanModulePeak: messages related to Peak modules

\end{itemize}

for managing logging levels per vendor. The logging level of each component, if the component is used, can be set individually
at any time once initialized. For windows the component names are as listed above, for linux the component CanModuleSock is used
for Systec and Peak modules, but also both CanModuleSystec and CanModulePeak are mapped to CanModuleSock for convenience.

You can of course add your own components for specific logging, like MYCOMP in the code below.

\sphinxstylestrong{The calling program (“main”) uses CanModule and LogIt like this}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}CanBusAccess.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}LogIt.h\PYGZgt{}}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LogComponentHandle} \PYG{n}{myHandle} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LogComponentHandle} \PYG{n}{canModuleHandle} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LOG\PYGZus{}LEVEL} \PYG{n}{loglevel} \PYG{o}{=} \PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{INF}\PYG{p}{;}    \PYG{c+c1}{// recommended default for production is WRN}
\PYG{k+kt}{bool} \PYG{n}{ret} \PYG{o}{=} \PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{initializeLogging}\PYG{p}{(} \PYG{n}{loglevel} \PYG{p}{)}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(} \PYG{n}{ret} \PYG{p}{)}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{LogIt initialized OK}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{k}{else}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{LogIt problem at initialisation}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setNonComponentLogLevel}\PYG{p}{(} \PYG{n}{loglevel} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Log level set to }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{loglevel} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{n}{LogItInstance} \PYG{o}{*}\PYG{n}{logIt} \PYG{o}{=} \PYG{n}{LogItInstance}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getInstance}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{c+cm}{/**}
\PYG{c+cm}{ * LogIt component MYCOMP for main}
\PYG{c+cm}{ */}
\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{registerLoggingComponent}\PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MYCOMP}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{loglevel} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{logIt}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getComponentHandle}\PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MYCOMP}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{myHandle} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setComponentLogLevel}\PYG{p}{(} \PYG{n}{myHandle}\PYG{p}{,} \PYG{n}{loglevel} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{LOG}\PYG{p}{(}\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{INF}\PYG{p}{,} \PYG{n}{myHandle}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{argv}\PYG{p}{[} \PYG{l+m+mi}{0} \PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ logging for component MYCOMP}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{c+c1}{// hourray, we should see this message because we are at INF}

\PYG{c+cm}{/**}
\PYG{c+cm}{ * LogIt component CanModule for generic Canmodule}
\PYG{c+cm}{ */}
\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{registerLoggingComponent}\PYG{p}{(} \PYG{n}{CanModule}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LogItComponentName}\PYG{p}{,} \PYG{n}{loglevel} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{logIt}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getComponentHandle}\PYG{p}{(}\PYG{n}{CanModule}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LogItComponentName}\PYG{p}{,} \PYG{n}{canModuleHandle} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setComponentLogLevel}\PYG{p}{(} \PYG{n}{canModuleHandle}\PYG{p}{,} \PYG{n}{loglevel} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{LOG}\PYG{p}{(}\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{INF}\PYG{p}{,} \PYG{n}{canModuleHandle}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ logging for component }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{CanModule}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LogItComponentName}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxstylestrong{then, some work is done i.e. like that:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// do sth useful with CanModule, i.e. talk to a port}
\PYG{n}{string} \PYG{n}{libName} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{st}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}           \PYG{c+c1}{// here: systec, windows}
\PYG{n}{string} \PYG{n}{port} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{st:can0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}         \PYG{c+c1}{// here: CAN port 0, windows}
\PYG{n}{string} \PYG{n}{parameters} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Undefined}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;} \PYG{c+c1}{// here: use defaults}
\PYG{n}{CanMessage} \PYG{n}{cm}\PYG{p}{;}
\PYG{n}{CanModule}\PYG{o}{:}\PYG{o}{:}\PYG{n}{CanLibLoader} \PYG{o}{*}\PYG{n}{libloader} \PYG{o}{=} \PYG{n}{CanModule}\PYG{o}{:}\PYG{o}{:}\PYG{n}{CanLibLoader}\PYG{o}{:}\PYG{o}{:}\PYG{n}{createInstance}\PYG{p}{(} \PYG{n}{libName} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{cca} \PYG{o}{=} \PYG{n}{libloader}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{openCanBus}\PYG{p}{(} \PYG{n}{port}\PYG{p}{,} \PYG{n}{parameters} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{cca}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{sendMessage}\PYG{p}{(} \PYG{o}{\PYGZam{}}\PYG{n}{cm} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{cca}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{canMessageCame}\PYG{p}{.}\PYG{n}{connect}\PYG{p}{(} \PYG{o}{\PYGZam{}}\PYG{n}{onMessageRcvd} \PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// connect a reception handler, see standardApi for details}
\end{sphinxVerbatim}

\sphinxstylestrong{and at any time the logging levels of the components can be changed. This is typically done by a user interaction
on a running server instance.}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/**}
\PYG{c+cm}{ * manipulate LogIt levels per component for testing, during runtime. Set loglevel to TRC (max verbosity)}
\PYG{c+cm}{ */}
\PYG{n}{loglevel} \PYG{o}{=} \PYG{n}{LOG}\PYG{o}{:}\PYG{o}{:}\PYG{n}{TRC}\PYG{p}{;}
\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LogComponentHandle} \PYG{n}{anagateHandle}\PYG{p}{;}
\PYG{n}{logIt}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getComponentHandle}\PYG{p}{(}\PYG{n}{CanModule}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LogItComponentNameAnagate}\PYG{p}{,} \PYG{n}{anagateHandle} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setComponentLogLevel}\PYG{p}{(} \PYG{n}{anagateHandle}\PYG{p}{,} \PYG{n}{loglevel} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{LOG}\PYG{p}{(}\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{INF}\PYG{p}{,} \PYG{n}{anagateHandle}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ logging for component }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{CanModule}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LogItComponentNameAnagate}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef \PYGZus{}WIN32}

\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LogComponentHandle} \PYG{n}{stHandle}\PYG{p}{;}
\PYG{n}{logIt}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getComponentHandle}\PYG{p}{(}\PYG{n}{CanModule}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LogItComponentNameSystec}\PYG{p}{,} \PYG{n}{stHandle} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setComponentLogLevel}\PYG{p}{(} \PYG{n}{stHandle}\PYG{p}{,} \PYG{n}{loglevel} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{LOG}\PYG{p}{(}\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{INF}\PYG{p}{,} \PYG{n}{stHandle}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ logging for component }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{CanModule}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LogItComponentNameSystec}\PYG{p}{;}

\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LogComponentHandle} \PYG{n}{pkHandle}\PYG{p}{;}
\PYG{n}{logIt}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getComponentHandle}\PYG{p}{(}\PYG{n}{CanModule}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LogItComponentNamePeak}\PYG{p}{,} \PYG{n}{pkHandle} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setComponentLogLevel}\PYG{p}{(} \PYG{n}{pkHandle}\PYG{p}{,} \PYG{n}{loglevel} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{LOG}\PYG{p}{(}\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{INF}\PYG{p}{,} \PYG{n}{pkHandle}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ logging for component }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{CanModule}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LogItComponentNamePeak}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{else}
\PYG{c+c1}{// for linux we can also just use LogItComponentNameSystec and LogItComponentNamePeak}
\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LogComponentHandle} \PYG{n}{sockHandle}\PYG{p}{;}
\PYG{n}{logIt}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getComponentHandle}\PYG{p}{(}\PYG{n}{CanModule}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LogItComponentNameSock}\PYG{p}{,} \PYG{n}{sockHandle} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setComponentLogLevel}\PYG{p}{(} \PYG{n}{sockHandle}\PYG{p}{,} \PYG{n}{loglevel} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{LOG}\PYG{p}{(}\PYG{n}{Log}\PYG{o}{:}\PYG{o}{:}\PYG{n}{INF}\PYG{p}{,} \PYG{n}{sockHandle}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ logging for component }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{CanModule}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LogItComponentNameSock}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\end{sphinxVerbatim}


\chapter{Building}
\label{\detokenize{building:building}}\label{\detokenize{building::doc}}

\chapter{Running}
\label{\detokenize{running:running}}\label{\detokenize{running::doc}}
The proper kernel modules, drivers and libraries for the vendors used through CanModule
have to be present during runtime. Please also refer to \sphinxhref{https://edms.cern.ch/file/2089743/1/CanModuleStatus2019\_v4.pptx}{Status} for an overview over
runtime conditions (april 2019).


\section{general dependencies}
\label{\detokenize{running:general-dependencies}}\begin{itemize}
\item {} 
CanModule.dll/.so

\item {} 
LogIt (cloned from github during cmake)

\item {} 
boost 1.64.0

\item {} 
xerces 3.2 (xerces-c\_3\_2D.dll)

\end{itemize}


\section{Anagate}
\label{\detokenize{running:anagate}}\begin{itemize}
\item {} 
libancan.dll/.so  (standard API)

\item {} 
linux: libAPIRelease64.so, libCANDLLRelease64.so, libAnaGateExtRelease.so, libAnaGateRelease.so

\item {} 
windows: ANAGATECAN64.dll

\end{itemize}


\section{Systec}
\label{\detokenize{running:systec}}\begin{itemize}
\item {} 
linux: libsockcan.so (standard API), driver kernel module systec\_can.ko and dependent modules

\item {} 
windows: libstcan.dll (standard API), USBCAN64.dll

\end{itemize}


\section{Peak}
\label{\detokenize{running:peak}}\begin{itemize}
\item {} 
linux: libsockcan.so (standard API), driver kernel module pcan.ko and dependent modules

\item {} 
windows: libpkcan.dll (standard API), PKCANBASIC.dll

\end{itemize}


\chapter{Support}
\label{\detokenize{support:support}}\label{\detokenize{support::doc}}
Support for CanModule is given CERN wide.

\sphinxstylestrong{Problems, Issues and Requests} should be created as CERN \sphinxhref{https://its.cern.ch/jira/secure/Dashboard.jspa}{Jira} Tickets:
\begin{itemize}
\item {} 
Project= OPC UA in JCOP (OPCUA)

\item {} 
Components= CanModule

\item {} 
Assignee= Michael Ludwig

\end{itemize}

Please provide traces of your situation and information about your project context. We will sort it out together.

More \sphinxstylestrong{personal} ways to get help or report problems:
\begin{itemize}
\item {} 
You can send me an \sphinxhref{mailto:michael.ludwig@cern.ch?subject=CanModule\_issue\_found\&body=HelloMichael,}{Email} or call me 163095 or visit me for a coffee.

\item {} 
Please also take a look at \sphinxhref{https://its.cern.ch/jira/browse/OPCUA-1362?jql=assignee\%20\%3D\%20currentUser()\%20AND\%20component\%20\%3D\%20CanModule\%20AND\%20project\%20\%3D\%20OPCUA}{JiraSearch} for already existing issues.

\end{itemize}


\chapter{alphabetical index}
\label{\detokenize{index:alphabetical-index}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}